<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: codeforces334 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/codeforces334/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-02-22T23:04:07+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Codeforces334-div2C Alternative Thinking]]></title>
    <link href="http://ry0u.github.io/blog/2015/12/15/codeforces334-div2c-alternative-thinking/"/>
    <updated>2015-12-15T09:50:00+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/12/15/codeforces334-div2c-alternative-thinking</id>
    <content type="html"><![CDATA[<p>長さ<script type="math/tex">N</script>の'0'と'1'で構成された文字列が与えられる．ある区間を1度だけ反転して'0'と'1'が交互となる列の長さを最大化する．</p>

<h1>考察</h1>

<p>まず，文字列の交互列の長さを<script type="math/tex"> m </script>とすると，一度の反転で最大2しか増えないことが分かる．例えば，
<script type="math/tex; mode=display">
    1111(m = 1) \Rightarrow 11\color{red}01(m = 3) \
    1101(m = 3) \Rightarrow \color{red}0101(m = 4) \
    1100(m = 2) \Rightarrow 1\color{red}0\color{red}10(m = 4) \
</script>
のように出来る．また，<script type="math/tex"> m = N </script>の時以外に，区間を反転して長さが増えないケースを考えると，そのようなケースは無いと分かる．反転する区間で01を内包している場合，反転後をその部分は10で交互列になるからである．
<script type="math/tex; mode=display">
11 0101 00(m = 4) \Rightarrow 1 \color{red}0 \color{red}1\color{red}0\color{red}1\color{red}0 \color{red}1 0(m = 6) \
</script></p>

<p>よって，<script type="math/tex">N</script>を超えないように，+1，+2したらACが貰えた</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    string s;
    cin &gt;&gt; s;

    int cnt = 0;
    bool flag = true;

    if(s[0] == '1') cnt++;

    rep(i, n) {
        if(flag) {
            if(s[i] == '1') continue;
            else {
                cnt++;
                flag = false;
            }
        } else {
            if(s[i] == '1') {
                cnt++;
                flag = true;
            } else continue;
        }
    }

    if(cnt + 2 &lt;= n) cout &lt;&lt; cnt + 2 &lt;&lt; endl;
    else if(cnt + 1 &lt;= n) cout &lt;&lt; cnt + 1 &lt;&lt; endl;
    else cout &lt;&lt; cnt &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
