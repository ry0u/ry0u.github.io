<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 回文 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/hui-wen/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-10T01:42:35+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM330 D2H NextPalindromicNumber]]></title>
    <link href="http://ry0u.github.io/blog/2016/12/02/srm330-d2h-nextpalindromicnumber/"/>
    <updated>2016-12-02T00:12:34+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/12/02/srm330-d2h-nextpalindromicnumber</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7257&rd=10010">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

与えられた数より大きいく最も小さい回文数を答える．文字列で与えられて最大50桁あるので，愚直に回文数を列挙しても間に合わない．桁の半分まで見て，それを反転して繋げたものがすでに大きければ解になる．そうではない場合は$1$足して反転する．気をつけなければいけないケースは$9, 99, 999$などの$1$足した時に桁が増えるもので，元の数よりも$1$桁増やせば十分なので偶奇で場合分けして調整する．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

string func(string a,string b) {
	string ret;
	if(a.size() < b.size()) swap(a,b);

	reverse(a.begin(),a.end());
	reverse(b.begin(),b.end());

	int carry = 0;
	rep(i,b.size()) {
		int x = a[i] - '0';
		int y = b[i] - '0';
		int z = x + y + carry;

		carry = z / 10;
		ret.push_back('0' + (z%10));
	}

	REP(i,b.size(),a.size()) {
		int x = a[i] - '0';
		int z = x + carry;

		carry = z / 10;
		ret.push_back('0' + (z%10));
	}

	if(carry) ret.push_back('0' + carry);
	reverse(ret.begin(),ret.end());
	return ret;
}

class NextPalindromicNumber {
	public:
	string getNext(string n) {
		int sz = n.size();
		string s = n.substr(0, (sz + 1) / 2), t;
		if(sz % 2 == 0) {
			t = s;
		} else {
			t = s.substr(0, s.size()-1);
		}
		reverse(t.begin(), t.end());
		t = s + t;

		if(sz == t.size() && t > n) {
			return t;
		}


		string a = func(s, "1");
		string b;
		if(a.size() == (sz + 1) / 2) {
			if(sz % 2 == 0) {
				b = a;
			} else {
				b = a.substr(0, a.size()-1);
			}
		} else {
			b = a.substr(0, a.size()-1);
			if(sz % 2 == 1) {
				a = a.substr(0, a.size()-1);
			}
		}

		// if(sz % 2 == 0 && a.size() == (sz + 1) / 2) {
		// 	b = a;
		// } else {
		// 	b = a.substr(0, a.size()-1);
		// }
		reverse(b.begin(), b.end());
		return a + b;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM317 D1E-D2M PalindromicNumbers]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/26/srm317-d1e-d2m-palindromicnumbers/"/>
    <updated>2016-10-26T14:44:30+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/26/srm317-d1e-d2m-palindromicnumbers</id>
    <content type="html"><![CDATA[<!-- more -->

何故か
https://competitiveprogramming.info/topcoder/srm
に317のlinkが無い．

---

回文となっている数字が$lower \sim upper$まで数えていくつあるか．制約は$\leq 10 ^9$と大きいが，大きい数の回文数というのは$1 \sim 10000$の数字を反転させたものになっているはずなので，偶数桁の場合はそのまま反転，奇数桁の場合は真ん中に$0 \sim 9$をはさんだ数をsetに突っ込んでいく．答えはsetの大きさになる．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

bool ch(int x) {
	string s = "";
	while(x) {
		s += char('0' + x % 10);
		x /= 10;
	}

	reverse(s.begin(), s.end());
	rep(i, s.size()/2) {
		if(s[i] == s[s.size()-1-i]) continue;
		return false;
	}
	return true;
}

vector<ll> rev(int x) {
	string s = "";
	while(x) {
		s += char('0' + x % 10);
		x /= 10;
	}
	string t = s;
	reverse(s.begin(), s.end());

	vector<string> v;
	v.push_back(s + t);

	rep(i, 10) {
		string ns = s + char('0' + i) + t;
		v.push_back(ns);
	}

	vector<ll> res;
	rep(i, v.size()) {
		ll ret = 0, k = 1;
		for(int j = v[i].size()-1; j >= 0; j--) {
			ret += int(v[i][j] - '0') * k;
			k *= 10;
		}
		res.push_back(ret);
	}

	return res;
}

class PalindromicNumbers {

    public:

    int countPalNums(int lower, int upper) {
		set<int> st;
		for(ll i = 1; i <= 10000; i++) {
			if(lower <= i && i <= upper && ch(i) && st.find(i) == st.end()) {
				st.insert(i);
			}
			
			vector<ll> ret = rev(i);
			rep(j, ret.size()) {
				int x = ret[j];
				if(lower <= x && x <= upper && ch(x) && st.find(x) == st.end()) {
					st.insert(x);
				}
			}
		}

		return st.size();
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM303 D2H PrimePalindromic]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/22/srm303-d2h-primepalindromic/"/>
    <updated>2016-08-22T21:35:53+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/22/srm303-d2h-primepalindromic</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6063&rd=9824">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$prime-palindromic$とは，素因数の並び替えで回文が作れることを言う．$A \sim B$に何個$prime-palindromic$があるか．

---

事前に10000までの数の素因数を出してみると少ないことが分かるので，愚直に全パターン並び替えを行って，連結して回文判定をした．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

vector<ll> prime_factor(ll n) {
	vector<ll> res;
	if(n == 1) return res;

	for(ll i = 2; i*i <= n; i++) {
		while(n%i == 0) {
			res.push_back(i);
			n /= i;
		}
	}

	if(n != 1) res.push_back(n);
	return res;
}

string f(ll x) {
	string ret = "";
	while(x) {
		ret = char('0' + x % 10) + ret;
		x /= 10;
	}
	return ret;
}

class PrimePalindromic {
	public:
	int count(int A, int B) {
		int ans = 0;
		REP(i, A, B + 1) {
			vector<ll> ret = prime_factor(i);
			sort(ret.begin(), ret.end());

			do {
				string s = "";
				rep(j, ret.size()) s += f(ret[j]);

				bool flag = true;
				rep(j, s.size() / 2) {
					if(s[j] == s[s.size()-1-j]) continue;
					flag = false;
				}

				if(flag) {
					ans++;
					break;
				}
			} while (next_permutation(ret.begin(), ret.end()));
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
</feed>
