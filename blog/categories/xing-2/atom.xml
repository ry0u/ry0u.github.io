<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 星2 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/xing-2/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2015-09-03T14:22:20+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[yukicoder No.45 回転寿司]]></title>
    <link href="http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-45-hui-zhuan-shou-si/"/>
    <updated>2015-09-03T14:00:37+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-45-hui-zhuan-shou-si</id>
    <content type="html"><![CDATA[<p><a href="http://yukicoder.me/problems/78">http://yukicoder.me/problems/78</a></p>

<h1>考察</h1>

<p>動的計画法で解く．[i][0]をi番目を取らない，[i][1]をi番目を取るとして，dp[i][j]をi番目までの最大値とする．dp[i][0] = max(i-1番目を取った，i-2番目を取った)，dp[i][1] = max(i-1番目を取らない+i番目の価値，i-2番目を取った+i番目の価値)で求める．</p>

<p><script type="math/tex; mode=display">
\begin{eqnarray}
\begin{cases}
dp[0][1] = v[0] \
dp[1][0] = v[0] \
dp[1][1] = v[1] \
dp[i][0] = max(dp[i-1][1],dp[i-2][1]) (i \geq 2) \
dp[i][1] = max(dp[i-1][0]+v[i],dp[i-2][1]+v[i]) (i \geq 2)
\end{cases}
\end{eqnarray}
</script></p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; v(n);
    rep(i,n) cin &gt;&gt; v[i];

    int dp[1005][2];
    memset(dp,0,sizeof(dp));

    dp[0][1] = v[0];
    dp[1][0] = v[0];
    dp[1][1] = v[1];

    REP(i,2,n) {
        dp[i][0] = max(dp[i-1][1],dp[i-2][1]);
        dp[i][1] = max(dp[i-1][0] + v[i],dp[i-2][1] + v[i]);
    }

    cout &lt;&lt; max(dp[n-1][0],dp[n-1][1]) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yukicoder No.44 DPなすごろく]]></title>
    <link href="http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-44-dpnasugoroku/"/>
    <updated>2015-09-03T13:53:47+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-44-dpnasugoroku</id>
    <content type="html"><![CDATA[<p><a href="http://yukicoder.me/problems/76">http://yukicoder.me/problems/76</a></p>

<h1>考察</h1>

<p>1または2前に進むことが出来るので，i+2番目にマスに訪れるにはi番目のマス，またはi+1番目のマスから来るしかない．よって</p>

<p><script type="math/tex; mode=display">
\begin{eqnarray}
\begin{cases}
dp[0] = 1 \
dp[1] = 1 \
dp[i+2] = dp[i+1] + dp[i] (i \geq 2)
\end{cases}
\end{eqnarray}
</script></p>

<p>が成り立つ．フィボナッチ階段を同じ考えである．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;ll&gt; dp(55);
    dp[0] = 1;
    dp[1] = 1;

    rep(i,n-1) {
        dp[i+2] = dp[i] + dp[i+1];
    }

    cout &lt;&lt; dp[n] &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yukicoder No.43 野球の試合]]></title>
    <link href="http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-43-ye-qiu-falseshi-he/"/>
    <updated>2015-09-03T13:39:56+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-43-ye-qiu-falseshi-he</id>
    <content type="html"><![CDATA[<p><a href="http://yukicoder.me/problems/8">http://yukicoder.me/problems/8</a></p>

<h1>考察</h1>

<p>0番目のチームに"-&ldquo;がある場合は必ず，勝ちにする．それ以外の場合はより勝っているチームが負け，負けているチームが勝つようにする，という貪欲は上手くいきそうにない．Nが最大6なので，全てが&rdquo;-&ldquo;だとしても状態数は2<sup>18</sup>．よって全ての状態を列挙して，最大で何位になれるかを見る．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;string&gt; v(n);
    rep(i,n) cin &gt;&gt; v[i];

    vector&lt;int&gt; cnt(n);

    rep(i,n) {
        rep(j,n) {
            if(v[i][j] == '#') continue;
            if(v[i][j] == 'o') cnt[i]++;
        }
    }

    set&lt;P&gt; st;
    rep(i,n) {
        rep(j,n) {
            if(v[i][j] == '-') {
                int s = i, t = j;
                if(s &gt; t) swap(s,t);

                st.insert(P(s,t));
            }
        }
    }

    int ans = n;
    int m = st.size();
    if(m == 0) {
        int val = cnt[0];

        sort(cnt.begin(),cnt.end());
        cnt.erase(unique(cnt.begin(),cnt.end()),cnt.end());
        reverse(cnt.begin(),cnt.end());

        rep(i,cnt.size()) {
            if(val == cnt[i]) {
                ans = i;
                break;
            }
        }
    } else {

        vector&lt;P&gt; v2(st.begin(), st.end());

        rep(i,1&lt;&lt;m) {
            vector&lt;int&gt; res(cnt.begin(), cnt.end());
            rep(j,m) {
                P p = v2[j];
                if(i &amp; (1&lt;&lt;j)) {
                    res[p.first]++;
                } else {
                    res[p.second]++;
                }
            }

            int val = res[0];
            sort(res.begin(),res.end());
            res.erase(unique(res.begin(),res.end()),res.end());
            reverse(res.begin(),res.end());

            int id = 0;
            rep(j,res.size()) {
                if(res[j] == val) {
                    id = j;
                    break;
                }
            }

            ans = min(ans,id);
        }
    }

    cout &lt;&lt; ans + 1 &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yukicoder No.17 2つの地点に泊まりたい]]></title>
    <link href="http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-17-2tufalsedi-dian-nibo-maritai/"/>
    <updated>2015-09-03T13:26:09+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-17-2tufalsedi-dian-nibo-maritai</id>
    <content type="html"><![CDATA[<p><a href="http://yukicoder.me/problems/61">http://yukicoder.me/problems/61</a></p>

<h1>考察</h1>

<p>nが50と小さいので，0とn-1以外の2つの地点(i,j)を列挙する．0~i，i~j，j~n-1の最短距離，i，jの滞在コストの和の最小値を求める．それぞれの地点からのdijkstraをやったが最初にwarshall_floydをしたほうがスマートに書けそう．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[55];
int d[55];

void dijkstra(int s,int n) {
    priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; que;
    fill(d,d+n,INF);

    d[s] = 0;
    que.push(P(0,s));

    while(que.size()) {
        P p = que.top();
        que.pop();

        int v = p.second;
        if(d[v] &lt; p.first) continue;

        rep(i,G[v].size()) {
            edge e = G[v][i];
            if(d[e.to] &gt; d[v] + e.cost) {
                d[e.to] = d[v] + e.cost;
                que.push(P(d[e.to],e.to));
            }
        }
    }
}

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; w(n);
    rep(i,n) cin &gt;&gt; w[i];

    int m;
    cin &gt;&gt; m;

    rep(i,m) {
        int a,b,c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;

        G[a].push_back(edge(b,c));
        G[b].push_back(edge(a,c));
    }

    int ans = INF;
    REP(i,1,n-1) {
        REP(j,1,n-1) {
            if(i == j) continue;
            int cost = 0;

            dijkstra(0,n);
            if(d[i] == INF) continue;
            cost += d[i];

            dijkstra(i,n);
            if(d[j] == INF) continue;
            cost += d[j];

            dijkstra(j,n);
            if(d[n-1] == INF) continue;
            cost += d[n-1];

            cost += w[i] + w[j];

            ans = min(ans,cost);
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
