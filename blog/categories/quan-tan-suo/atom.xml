<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 全探索 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/quan-tan-suo/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-02-16T22:59:07+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ0546 Lining up the cards]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/10/aoj0546-lining-up-the-cards/"/>
    <updated>2016-02-10T21:50:42+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/10/aoj0546-lining-up-the-cards</id>
    <content type="html"><![CDATA[<p>問題文<br/>
<a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0546">http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0546</a></p>

<!-- more-->


<p>最大<script type="math/tex"> Nが10</script>なので全探索してsetにぶっ込んで終了だと思ったけどTLEした．k番目より後ろが変更してもできる整数は一緒なので，k番目までの状態もsetにぶっ込んだらACした．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;

#define REP(i,k,n) for(int i=0;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)

using namespace std;

typedef long long ll;
typedef pair&lt;int, int&gt; P;

int func(vector&lt;int&gt; v, int k) {
    stringstream ss;
    rep(i, k) {
        ss &lt;&lt; v[i];
    }

    int ret;
    ss &gt;&gt; ret;

    return ret;
}

int main() {
    int n;
    while(cin &gt;&gt; n) {
        if(n == 0) break;

        int k;
        cin &gt;&gt; k;

        vector&lt;int&gt; v(n);
        rep(i, n) cin &gt;&gt; v[i];

        sort(v.begin(), v.end());

        set&lt;int&gt; ans;
        set&lt;vector&lt;int&gt; &gt; st;


        do {
            vector&lt;int&gt; ret(k);
            rep(i, k)  ret[i] = v[i];

            if(st.find(ret) == st.end()) {
                st.insert(ret);
                ans.insert(func(v, k));
            } else continue;
        }while(next_permutation(v.begin(), v.end()));

        cout &lt;&lt; ans.size() &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yukicoder No.77 レンガのピラミッド]]></title>
    <link href="http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-77-rengafalsepiramitudo/"/>
    <updated>2015-09-03T21:06:33+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-77-rengafalsepiramitudo</id>
    <content type="html"><![CDATA[<p><a href="http://yukicoder.me/problems/186">http://yukicoder.me/problems/186</a></p>

<h1>考察</h1>

<p>移動とは</p>

<blockquote><p>任意の列の一番上にある1つのレンガを持ち，別の列に移動するか，もしくは捨て置き場に移動すること．</p></blockquote>

<p>なので，ピラミッドの長さを決めたら，それに対応する長さとのdiffを取る．もし超えている部分のほうが大きくても捨て置き場に置けばよいので，長さを決め打ちすれば，その長さにするための移動数が求まる．ピラミッドの長さはNよりも大きくてもよいので(特に考えず出してWAを生やした)，十分な回数まで調べた．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

vector&lt;int&gt; init(int n) {
    vector&lt;int&gt; ret;
    rep(i,n/2) {
        ret.push_back(i+1);
    }
    ret.push_back(n/2+1);
    for(int i=n/2; i&gt;0; i--) {
        ret.push_back(i);
    }
    return ret;
}

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; v(1005);
    rep(i,n) cin &gt;&gt; v[i];

    int ans = INF;

    REP(size,1,1005) {
        if(size % 2 == 0) continue;
        vector&lt;int&gt; t = init(size);

        rep(i,n) {
            int a = 0, b = 0;

            rep(j,i) a += v[j];

            REP(j,i,size) {
                if(v[j] &gt; t[j-i]) {
                    a += v[j] - t[j-i];
                }
                if(v[j] &lt; t[j-i]) {
                    b += t[j-i] - v[j];
                }
            }

            REP(j,size,n) a += v[j];

            if(a &gt;= b) {
                ans = min(ans,a);
            }
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yukicoder No.43 野球の試合]]></title>
    <link href="http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-43-ye-qiu-falseshi-he/"/>
    <updated>2015-09-03T13:39:56+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-43-ye-qiu-falseshi-he</id>
    <content type="html"><![CDATA[<p><a href="http://yukicoder.me/problems/8">http://yukicoder.me/problems/8</a></p>

<h1>考察</h1>

<p>0番目のチームに"-&ldquo;がある場合は必ず，勝ちにする．それ以外の場合はより勝っているチームが負け，負けているチームが勝つようにする，という貪欲は上手くいきそうにない．Nが最大6なので，全てが&rdquo;-&ldquo;だとしても状態数は2<sup>18</sup>．よって全ての状態を列挙して，最大で何位になれるかを見る．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;string&gt; v(n);
    rep(i,n) cin &gt;&gt; v[i];

    vector&lt;int&gt; cnt(n);

    rep(i,n) {
        rep(j,n) {
            if(v[i][j] == '#') continue;
            if(v[i][j] == 'o') cnt[i]++;
        }
    }

    set&lt;P&gt; st;
    rep(i,n) {
        rep(j,n) {
            if(v[i][j] == '-') {
                int s = i, t = j;
                if(s &gt; t) swap(s,t);

                st.insert(P(s,t));
            }
        }
    }

    int ans = n;
    int m = st.size();
    if(m == 0) {
        int val = cnt[0];

        sort(cnt.begin(),cnt.end());
        cnt.erase(unique(cnt.begin(),cnt.end()),cnt.end());
        reverse(cnt.begin(),cnt.end());

        rep(i,cnt.size()) {
            if(val == cnt[i]) {
                ans = i;
                break;
            }
        }
    } else {

        vector&lt;P&gt; v2(st.begin(), st.end());

        rep(i,1&lt;&lt;m) {
            vector&lt;int&gt; res(cnt.begin(), cnt.end());
            rep(j,m) {
                P p = v2[j];
                if(i &amp; (1&lt;&lt;j)) {
                    res[p.first]++;
                } else {
                    res[p.second]++;
                }
            }

            int val = res[0];
            sort(res.begin(),res.end());
            res.erase(unique(res.begin(),res.end()),res.end());
            reverse(res.begin(),res.end());

            int id = 0;
            rep(j,res.size()) {
                if(res[j] == val) {
                    id = j;
                    break;
                }
            }

            ans = min(ans,id);
        }
    }

    cout &lt;&lt; ans + 1 &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces315-div2C Prime or Palindromes?]]></title>
    <link href="http://ry0u.github.io/blog/2015/08/11/codeforces315-div2c-prime-or-palindromes/"/>
    <updated>2015-08-11T04:21:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/08/11/codeforces315-div2c-prime-or-palindromes</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/569/problem/C">http://codeforces.com/contest/569/problem/C</a><br/>
<script type="math/tex; mode=display">
\pi (n) := nをこえない素数の数 \
rub (n) := nをこえない回分の数
</script></p>

<p>と定義する．比<script type="math/tex">A = \frac{p}{q}</script>が与えられるので，<script type="math/tex">\pi (n) \leq A \cdot rub(n)</script>を満たす最大のnを求めたい．</p>

<h1>考察</h1>

<p>まず，<script type="math/tex">\pi (n)</script>と，<script type="math/tex">rub (n)</script>を求める．これをどこまで必要かを自分で判断しなければならない．<script type="math/tex"> A \leq 42</script>とあるので，多くでも<script type="math/tex">\pi (n)</script>が<script type="math/tex">rub (n)</script>の42倍になっているnまででよいと分かる．実際に値を試した所，n = 1500000で十分だとわかった．後は，後ろから見ていき，条件を満たす最大のnを答えた．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

bool prime[10000000];
void Eratosthenes(int n) {
    rep(i,n) prime[i] = true;
    prime[0] = false;
    prime[1] = false;

    REP(i,2,(int)sqrt(n)) {
        if(prime[i]) {
            for(int j=0;i*(j+2)&lt;n;j++) {
                prime[i*(j+2)] = 0;
            }
        }
    }
}

bool check(string s) {
    rep(i,s.size()/2) {
        if(s[i] != s[s.size()-1-i]) return false;
    }

    return true;
}

int main() {
    double p,q;
    cin &gt;&gt; p &gt;&gt; q;

    int N = 1500000;

    Eratosthenes(N);
    vector&lt;int&gt; pi(N);
    int cnt = 0;

    rep(i,N+5) {
        if(prime[i]) {
            cnt++;
        }

        pi[i] = cnt;
    }


    vector&lt;int&gt; rub(N);
    cnt = 0;
    REP(i,1,N+5) {
        stringstream ss;
        ss &lt;&lt; i;

        if(check(ss.str())) {
            cnt++;
        }

        rub[i] = cnt;
    }

    double A = p/q;
    int ans = 0;

    for(int i=N;i&gt;=1;i--) {
        ll a = pi[i];
        ll b = rub[i];

        if(a &lt;=  A * b) {
            cout &lt;&lt; i &lt;&lt; endl;
            break;
        }
        else {
            continue;
        }
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
