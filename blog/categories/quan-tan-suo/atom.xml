<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 全探索 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/quan-tan-suo/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-10-27T03:35:54+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM316 D1E-D2M InboxCleanup]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/26/srm316-d1e-d2m-inboxcleanup/"/>
    <updated>2016-10-26T12:15:42+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/26/srm316-d1e-d2m-inboxcleanup</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6619&rd=9996">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

文字列が与えられるので，その中に含まれているDを消したい．pageの単位を$low \sim high$文字にすることが出来る．出来る操作として

* 今見ているページの中にあるメッセージを1つ選択する
* 今見ているページの中にある選択しているものを1つ解除する
* 今見ているページを全て選択する
* 今見てるページで選択されているもの全てを削除する
* 次のページに行く

最小何回で全てのDを消すことが出来るか．

---

全て選択して，選択しているものを削除すれば全てのページは少なくとも2回でいけると勘違いしていたが，D以外を選択している状態で全ての削除をすることはできない．ページを何文字単位にするかは$low \sim high$全て試して，それぞれのページ事に1つ1つ消した方が良いのか，全てのを選択してD以外を解除して全て消すかのどちらが最小となるかをチェックした．

# Code

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<28
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

class InboxCleanup {

    public:

    int fewestClicks(string messages, int low, int high) {
		int n = messages.size();
		int ans = INF;
		REP(t, low, high + 1) {
			int D = 0, len = 0, res = n / t - (n % t == 0);

			rep(i, n) {
				if(messages[i] == 'D') D++;
				len++;

				if(len % t == 0) {
					len = 0;
					if(D != 0) {
						res += min(t - D + 1 + 1, D + 1);
						D = 0;
					}
				}
			}

			if(len != 0 && D != 0) {
				res += min(len - D + 1 + 1, D + 1);
			}

			ans = min(ans, res);
		}
		return ans;
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM309 D1H-D2M ScoreRecomposition]]></title>
    <link href="http://ry0u.github.io/blog/2016/09/03/srm309-d1h-d2m-scorerecomposition/"/>
    <updated>2016-09-03T00:55:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/09/03/srm309-d1h-d2m-scorerecomposition</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6241&rd=9989">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

各問題の正解している問題の点数の合計が$score$であり，不正解の問題の点数と番号の差の絶対値の最大値を最小化する．  
$n \leq 10$なので，全部列挙して点数の合計と差の絶対値を全て計算する．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

class ScoreRecomposition {
	public:
	int minError(string questions, int score) {
		int n = questions.size();
		vector<int> id;
		rep(i, n) id.push_back(i + 1);

		int ans = INF;
		do {
			int sum = 0, res = 0;
			rep(i, n) {
				if(questions[i] == 'C') {
					sum += id[i];
				}
				res = max(res, abs(i + 1 - id[i]));
			}

			if(sum == score) {
				ans = min(ans, res);
			}

		} while(next_permutation(id.begin(), id.end()));

		if(ans == INF) return -1;
		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM303 D2H PrimePalindromic]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/22/srm303-d2h-primepalindromic/"/>
    <updated>2016-08-22T21:35:53+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/22/srm303-d2h-primepalindromic</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6063&rd=9824">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$prime-palindromic$とは，素因数の並び替えで回文が作れることを言う．$A \sim B$に何個$prime-palindromic$があるか．

---

事前に10000までの数の素因数を出してみると少ないことが分かるので，愚直に全パターン並び替えを行って，連結して回文判定をした．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

vector<ll> prime_factor(ll n) {
	vector<ll> res;
	if(n == 1) return res;

	for(ll i = 2; i*i <= n; i++) {
		while(n%i == 0) {
			res.push_back(i);
			n /= i;
		}
	}

	if(n != 1) res.push_back(n);
	return res;
}

string f(ll x) {
	string ret = "";
	while(x) {
		ret = char('0' + x % 10) + ret;
		x /= 10;
	}
	return ret;
}

class PrimePalindromic {
	public:
	int count(int A, int B) {
		int ans = 0;
		REP(i, A, B + 1) {
			vector<ll> ret = prime_factor(i);
			sort(ret.begin(), ret.end());

			do {
				string s = "";
				rep(j, ret.size()) s += f(ret[j]);

				bool flag = true;
				rep(j, s.size() / 2) {
					if(s[j] == s[s.size()-1-j]) continue;
					flag = false;
				}

				if(flag) {
					ans++;
					break;
				}
			} while (next_permutation(ret.begin(), ret.end()));
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1175 And Then. How Many Any There?]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/21/and-then-how-many-any-there/"/>
    <updated>2016-05-21T01:35:44+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/21/and-then-how-many-any-there</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1175&lang=jp">And Then. How Many Are There? | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

別の円盤が上に無い状態の円盤は同じ色が偶数の場合は全部消し，奇数の場合は {% m %} 1 {% em %}個消さないのを選ぶ，というやり方でやっていたが，消す順番によりそれより多く消せるパターンというのがありこれは間違いだった．  
選ぶ順番によって消せる枚数が違ってくるので，各状態毎に {% m %} (i, j) {% em %}を列挙して消せるかどうかを調べる． {% m %} n {% em %}は最大で {% m %} 4 * 6 = 24 {% em %}なので，状態数は {% m %} 2 ^{24} {% em %}．intのbitでどの円盤を使ったかを管理した． {% m %} O(2 ^n n ^2)  {% em %}．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;

struct P {
	int x, y, r, c;

	P() : x(0), y(0), r(0), c(0) {}
	P(int x, int y, int r, int c) : x(x), y(y), r(r), c(c) {}
};

int n, ans;
vector<P> v;
set<int> memo;

void dfs(int S) {
	if(memo.find(S) != memo.end()) return;
	memo.insert(S);

	ans = max(ans, __builtin_popcount(S));
	if(ans == n) return;

	bool up[50];
	memset(up, 0, sizeof(up));
	for(int i = n-1; i >= 0; i--) {
		if(S & (1<<i)) continue;

		bool flag = true;
		for(int j = i-1; j >= 0; j--) {
			if(S & (1<<j)) continue;
			int dist = (v[j].x - v[i].x) * (v[j].x - v[i].x) + (v[j].y - v[i].y) * (v[j].y - v[i].y);
			int len = (v[i].r + v[j].r) * (v[i].r + v[j].r);

			if(dist < len) {
				flag = false;
			}
		}

		if(!flag) up[i] = true;
	}

	set<int> st[5];
	for(int i = n-1; i >= 0; i--) {
		if((S & (1<<i)) || up[i]) continue;

		bool flag = true;

		for(int j = i-1; j >= 0; j--) {
			if((S & (1<<j)) || up[j]) continue;

			int dist = (v[j].x - v[i].x) * (v[j].x - v[i].x) + (v[j].y - v[i].y) * (v[j].y - v[i].y);
			int len = (v[i].r + v[j].r) * (v[i].r + v[j].r);

			if(dist >= len && v[i].c == v[j].c) {
				dfs(S + (1<<i) + (1<<j));
			}
		}
	}
}

int main() {
	while(cin >> n && n) {

		v.clear();
		memo.clear();

		rep(i, n) {
			int x, y, r, c;
			cin >> x >> y >> r >> c;
			v.push_back(P(x, y, r, c));
		}

		vector<bool> used(n);
		rep(i, n) used[i] = false;

		ans = 0;
		int S = 0;
		dfs(S);

		cout << ans << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces353-div2B Restoring Painting]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/17/codeforces353-div2b-restoring-painting/"/>
    <updated>2016-05-17T17:43:57+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/17/codeforces353-div2b-restoring-painting</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/675/problem/B">Problem - B - Codeforces</a></h4><p>Vasya works as a watchman in the gallery. Unfortunately, one of the most expensive paintings was stolen while he was on duty. He doesn't want to be fired, so he has to quickly restore the painting. He remembers some facts about it.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

　{% m %} 3 \times 3 {% em %}のマスで {% m %} a, b, c, d {% em %}が与えられる． {% m %} 2 \times 2 {% em %}の マスの和が全て等しくなるような ?を埋める {% m %} 1 \sim n {% em %}数字の組はいくつあるか？  
{% img /images/Codeforces/353/b.png %}
  

　?のマスをそれぞれ {% m %} x, y, z, h, m {% em %} と置くと，それぞれ {% m %} 4 {% em %}つの正方形の和は  
{% img /images/Codeforces/353/b2.png %}

1. {% m %} a + b + x + m {% em %}
2. {% m %} a + c + y + m {% em %}
3. {% m %} b + d + z + m {% em %}
4. {% m %} c + d + h + m {% em %}

となり，全て {% m %} m {% em %}が入っていて，{% m %} m {% em %}の値は関係ないことがわかる．なので{% m %} x, y, z, h {% em %}の組の{% m %} n {% em %}倍でいい．  
まず， {% m %} x {% em %}の値を全探索する． {% m %} x = i {% em %}と置くと， {% m %} y, z, h {% em %}が

* {% m %} y = b + x - c {% em %}
* {% m %} z = a + x - d {% em %}
* {% m %} h = a + y - d {% em %}

と決まるので，その値が {% m %} 1 \sim n {% em %}の間に収まっていれば，正しい組となる．その組の場合に {% m %} n {% em %}を足していった({% m %} m {% em %}は何でも良い)．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	ll n, a, b, c, d;
	cin >> n >> a >> b >> c >> d;

	ll ans = 0;

	REP(i, 1, n + 1) {
		ll x = i;
		ll y = b + x - c;
		ll z = a + x - d;
		ll h = a + y - d;

		if(1 <= y && y <= n && 1 <= z && z <= n && 1 <= h && h <= n) {
			ans += n;
		}
	}

	cout << ans << endl;

	return 0;
}
```



]]></content>
  </entry>
  
</feed>
