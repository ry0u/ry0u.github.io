<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 全探索 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/quan-tan-suo/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-11-19T01:27:19+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM323 D2H UnrepeatableWords]]></title>
    <link href="http://ry0u.github.io/blog/2016/11/18/srm323-d2h-unrepeatablewords/"/>
    <updated>2016-11-18T21:07:21+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/11/18/srm323-d2h-unrepeatablewords</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6603&rd=10003">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

文字列が*k-unrepeatable*であるとは，全ての部分文字列がその文字列の中に$k$個未満のことである．全探索で通らないと思ったけど通るらしい．多分$A$から始めていって条件を満たさないときに，戻るのがそんなに戻らなくて大丈夫なのかな(適当)．  
条件を満たすのをチェックするのは部分文字列が$k$個未満であればいいので，文字列の区間$[i, j]$を$k$個に分割して，先頭から確かめていく．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

string ans = "";
int a[55];
int k, n, allowed;

int f(int sz) {
	rep(i, sz) {
		REP(j, i + 1, sz) {
			if((j - i + 1) % k == 0) {
				int len = (j - i + 1) / k;
				bool flag = true;

				REP(u, i, j - len + 1) {
					if(a[u] != a[u + len]) {
						flag = false;
						break;
					}
				}
				if(flag) return true;
			}
		}
	}
	return false;
}

bool flag;
void dfs(int sz) {
	if(flag) return;

	if(sz == n) {
		rep(i, n) {
			ans += char('A' + a[i]);
		}
		flag = true;
		return;
	}

	rep(i, allowed) {
		a[sz] = i;
		if(f(sz + 1)) continue;
		dfs(sz + 1);
	}
}

class UnrepeatableWords {
	public:
	string getWord(int _k, int _n, int _allowed) {
		k = _k;
		n = _n;
		allowed = _allowed;

		ans = "";
		flag = false;
		memset(a, 0, sizeof(a));

		dfs(0);
		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM322 D2H BattleshipChecker]]></title>
    <link href="http://ry0u.github.io/blog/2016/11/18/srm322-d2h-battleshipchecker/"/>
    <updated>2016-11-18T20:27:02+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/11/18/srm322-d2h-battleshipchecker</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6800&rd=10002">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->


* 長さ$1$の船が$4$つ
* 長さ$2$の船が$3$つ
* 長さ$3$の船が$2$つ
* 長さ$4$の船が$1$つ

以上の船があり，なおかつ船がひとつもない行と列の数を返す．愚直に全部あるか確かめる．斜めもあるので注意する．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

int x[20][20];

bool check(vector<string> s) {
	int n = s.size();
	map<int, int> m;
	memset(x, -1, sizeof(x));

	int id = 0;
	rep(i, n) {
		rep(j, n) {
			if(s[i][j] != 'X') continue;
			if(x[i][j] != -1) continue;

			x[i][j] = id;
			int w = 1, h = 1;
			REP(k, j+1, n) {
				if(s[i][k] == 'X') {
					w++;
					x[i][k] = id;
					continue;
				} else break;
			}

			REP(k, i+1, n) {
				if(s[k][j] == 'X') {
					h++;
					x[k][j] = id;
					continue;
				} else break;
			}

			if(max(w, h) > 4) return false;

			m[max(w, h)]++;
			id++;
		}
	}

	bool flag = m[1] == 4 && m[2] == 3 && m[3] == 2 && m[4] == 1;
	if(!flag) return false;

	int dy[8] = {-1,-1,-1, 0, 0, 1, 1, 1};
	int dx[8] = {-1, 0, 1,-1, 1,-1, 0, 1};

	rep(i, n) {
		rep(j, n) {
			if(x[i][j] == -1) continue;

			rep(k, 8) {
				int ni = i + dy[k];
				int nj = j + dx[k];

				if(0 <= ni && ni < n && 0 <= nj && nj < n) {
					if(x[ni][nj] != -1 && x[ni][nj] != x[i][j]) {
						return false;
					}
				}
			}
		}
	}


	return true;
}

class BattleshipChecker {
	public:
	string checkBoard(vector <string> board) {

		if(!check(board)) {
			return "REJECTED";
		}

		int n = board.size(), cnt = 0;
		rep(i, n) {
			bool flag = true;
			rep(j, n) {
				if(board[i][j] != 'X') continue;
				flag = false;
			}

			if(flag) cnt++;
			flag = true;

			rep(j, n) {
				if(board[j][i] != 'X') continue;
				flag = false;
			}

			if(flag) cnt++;
		}

		stringstream ss;
		ss << "ACCEPTED, ";
		ss << cnt;
		ss << " POINTS";

		return ss.str();
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM316 D1E-D2M InboxCleanup]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/26/srm316-d1e-d2m-inboxcleanup/"/>
    <updated>2016-10-26T12:15:42+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/26/srm316-d1e-d2m-inboxcleanup</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6619&rd=9996">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

文字列が与えられるので，その中に含まれているDを消したい．pageの単位を$low \sim high$文字にすることが出来る．出来る操作として

* 今見ているページの中にあるメッセージを1つ選択する
* 今見ているページの中にある選択しているものを1つ解除する
* 今見ているページを全て選択する
* 今見てるページで選択されているもの全てを削除する
* 次のページに行く

最小何回で全てのDを消すことが出来るか．

---

全て選択して，選択しているものを削除すれば全てのページは少なくとも2回でいけると勘違いしていたが，D以外を選択している状態で全ての削除をすることはできない．ページを何文字単位にするかは$low \sim high$全て試して，それぞれのページ事に1つ1つ消した方が良いのか，全てのを選択してD以外を解除して全て消すかのどちらが最小となるかをチェックした．

# Code

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<28
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

class InboxCleanup {

    public:

    int fewestClicks(string messages, int low, int high) {
		int n = messages.size();
		int ans = INF;
		REP(t, low, high + 1) {
			int D = 0, len = 0, res = n / t - (n % t == 0);

			rep(i, n) {
				if(messages[i] == 'D') D++;
				len++;

				if(len % t == 0) {
					len = 0;
					if(D != 0) {
						res += min(t - D + 1 + 1, D + 1);
						D = 0;
					}
				}
			}

			if(len != 0 && D != 0) {
				res += min(len - D + 1 + 1, D + 1);
			}

			ans = min(ans, res);
		}
		return ans;
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM309 D1H-D2M ScoreRecomposition]]></title>
    <link href="http://ry0u.github.io/blog/2016/09/03/srm309-d1h-d2m-scorerecomposition/"/>
    <updated>2016-09-03T00:55:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/09/03/srm309-d1h-d2m-scorerecomposition</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6241&rd=9989">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

各問題の正解している問題の点数の合計が$score$であり，不正解の問題の点数と番号の差の絶対値の最大値を最小化する．  
$n \leq 10$なので，全部列挙して点数の合計と差の絶対値を全て計算する．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

class ScoreRecomposition {
	public:
	int minError(string questions, int score) {
		int n = questions.size();
		vector<int> id;
		rep(i, n) id.push_back(i + 1);

		int ans = INF;
		do {
			int sum = 0, res = 0;
			rep(i, n) {
				if(questions[i] == 'C') {
					sum += id[i];
				}
				res = max(res, abs(i + 1 - id[i]));
			}

			if(sum == score) {
				ans = min(ans, res);
			}

		} while(next_permutation(id.begin(), id.end()));

		if(ans == INF) return -1;
		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM303 D2H PrimePalindromic]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/22/srm303-d2h-primepalindromic/"/>
    <updated>2016-08-22T21:35:53+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/22/srm303-d2h-primepalindromic</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6063&rd=9824">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$prime-palindromic$とは，素因数の並び替えで回文が作れることを言う．$A \sim B$に何個$prime-palindromic$があるか．

---

事前に10000までの数の素因数を出してみると少ないことが分かるので，愚直に全パターン並び替えを行って，連結して回文判定をした．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

vector<ll> prime_factor(ll n) {
	vector<ll> res;
	if(n == 1) return res;

	for(ll i = 2; i*i <= n; i++) {
		while(n%i == 0) {
			res.push_back(i);
			n /= i;
		}
	}

	if(n != 1) res.push_back(n);
	return res;
}

string f(ll x) {
	string ret = "";
	while(x) {
		ret = char('0' + x % 10) + ret;
		x /= 10;
	}
	return ret;
}

class PrimePalindromic {
	public:
	int count(int A, int B) {
		int ans = 0;
		REP(i, A, B + 1) {
			vector<ll> ret = prime_factor(i);
			sort(ret.begin(), ret.end());

			do {
				string s = "";
				rep(j, ret.size()) s += f(ret[j]);

				bool flag = true;
				rep(j, s.size() / 2) {
					if(s[j] == s[s.size()-1-j]) continue;
					flag = false;
				}

				if(flag) {
					ans++;
					break;
				}
			} while (next_permutation(ret.begin(), ret.end()));
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
</feed>
