<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dag | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/dag/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-10T01:42:35+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM313 D1E-D2H ParallelProgramming]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/03/srm313-d1e-d2h-parallelprogramming/"/>
    <updated>2016-10-03T00:55:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/03/srm313-d1e-d2h-parallelprogramming</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6517&rd=9993">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

$i$番目のプロセスは$time[i]$かかって，プロセスの優先順位が与えられる．全てのプロセスが終わる時間を求める．

---

閉路がある場合，そこでぐるぐるしてしまうのでDAGであるのが全てのプロセスが終わる条件となる．DAGかどうかはトポロジカルソートが完了しているかで見た．もしDAGの場合トポロジカル順序が求まっているので，その順番で$dp[i] := i$番目のプロセスが終わる時間として更新していった．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

int n;
vector<int> G[55], out;

bool isDAG() {
	int indeg[55];
	memset(indeg, 0, sizeof(indeg));

	rep(i, n) {
		rep(j, G[i].size()) indeg[ G[i][j] ]++;
	}

	queue<int> que;
	rep(i, n) {
		if(indeg[i] == 0) que.push(i);
	}

	while(que.size()) {
		int u = que.front(); que.pop();
		out.push_back(u);

		rep(i, G[u].size()) {
			int v = G[u][i];
			indeg[v]--;

			if(indeg[v] == 0) que.push(v);
		}
	}

	return (out.size() == n);
}

class ParallelProgramming {
	public:
	int minTime(vector <int> time, vector <string> prec) {
		n = time.size();

		out.clear();
		rep(i, 55) G[i].clear();

		rep(i, n) {
			rep(j, n) {
				if(prec[i][j] == 'Y') {
					G[i].push_back(j);
				}
			}
		}

		if(isDAG()) {
			int dp[55];
			memset(dp, 0, sizeof(dp));

			rep(i, out.size()) {
				int v = out[i];
				dp[v] = max(dp[v], time[v]);

				rep(j, G[v].size()) {
					int to = G[v][j];
					dp[to] = max(dp[to], dp[v] + time[to]);
				}
			}

			int ans = 0;
			rep(i, n) ans = max(ans, dp[i]);

			return ans;

		} else return -1;
	}
};
```
]]></content>
  </entry>
  
</feed>
