<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: srm | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/srm/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-05-16T08:41:29+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM684D2H Autohamil]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/16/srm684d2h-autohamil/"/>
    <updated>2016-03-16T00:01:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/16/srm684d2h-autohamil</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14183&rd=16688">TopCoder Statistics - Problem Statement</a></h4><p>In this problem, all strings are binary strings. That is, each character of a string is either '0' or '1'. A deterministic finite automaton is a machine that processes strings. The automaton has a finite set of possible states. The states are numbered 0 through n-1, where n is the number of states.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>有向グラフが与えられるので，ハミルトン路があるかどうかを判定せよ．</p>

<hr />

<p>閉路があるので，強連結成分分解する．分解後のグラフで<script type="math/tex"> 0 </script>を始点に探索を始め，分かれ道があれば出来ないと思ったが，全然違うしサンプルも合わない．こういう場合は出来る．</p>

<p><img src="/images/SRM/684d2h.png"></p>

<p>強連結成分分解をしDAGになったので，トポロジカルソートしてトポロジカル順序で<script type="math/tex"> i \to i+1 </script>の辺があるかを調べる．また，トポロジカル順序の開始が<script type="math/tex"> 0 </script>で無い場合も出来ないことを忘れない(分からなかった)．</p>

<h1>Code</h1>

<pre><code class="cpp">struct SCC {
    int n;
    vector&lt;vector&lt;int&gt; &gt; g, rg, ng, scc; // rg: 逆グラフ, ng: 分解後のグラフ
    vector&lt;int&gt; res; // scc: 強連結成分に属する頂点, res:強連結成分の番号
    bool used[100005];

    SCC(int _n) {
        n = _n;
        g.resize(n); rg.resize(n) ; scc.resize(n); res.resize(n);
    }

    SCC(const vector&lt;vector&lt;int&gt; &gt; &amp;g) : n(g.size()), g(g), rg(n), scc(n), res(n) {
        rep(i, n) {
            rep(j, g[i].size()) rg[g[i][j]].push_back(i);
        }
    }

    // i-jに辺を追加する
    void add(int i, int j) {
        g[i].push_back(j);
        rg[j].push_back(i);
    }

    vector&lt;int&gt; vs;
    void dfs(int v) {
        used[v] = true;
        rep(i, g[v].size()) {
            if(!used[ g[v][i] ]) dfs(g[v][i]);
        }
        vs.push_back(v);
    }

    void rdfs(int v, int k) {
        used[v] = true;
        res[v] = k; 
        scc[k].push_back(v);
        rep(i, rg[v].size()) {
            if(!used[ rg[v][i] ]) rdfs(rg[v][i], k);
        }
    }

    void ng_make(int k) {
        ng.resize(k);
        rep(i, n) {
            set&lt;int&gt; S;
            rep(j, g[i].size()) {
                int to = g[i][j];
                if(res[i] == res[to]) continue;
                if(S.find(res[to]) != S.end()) continue;
                ng[res[i]].push_back(res[to]);
                S.insert(res[to]);
            }
        }
    }

    int run() {
        memset(used, 0, sizeof(used));
        rep(i, n) {
            if (!used[i]) dfs(i);
        }

        memset(used, 0, sizeof(used));
        int k = 0;
        for (int i = vs.size()-1; i &gt;= 0; i--) {
            if (!used[vs[i]]) rdfs(vs[i], k++);
        }

        ng_make(k);
        return k;
    }
};

bool used[55];
vector&lt; vector&lt;int&gt; &gt; ng;
vector&lt;int&gt; out;

void dfs(int cur) {
    used[cur] = true;
    rep(i, ng[cur].size()) {
        int v = ng[cur][i];
        if(!used[v]) dfs(v);
    }
    out.push_back(cur);
}

class Autohamil {
    public:
    string check(vector &lt;int&gt; z0, vector &lt;int&gt; z1) {
        int n = z0.size();
        SCC scc(n);

        rep(i, n) {
            if(i != z0[i]) scc.add(i, z0[i]);
            if(i != z1[i]) scc.add(i, z1[i]);
        }

        int m = scc.run();
        ng.resize(m);
        rep(i, m) {
            ng[i].resize(scc.ng[i].size());
            rep(j, scc.ng[i].size()) {
                ng[i][j] = scc.ng[i][j];
            }
        }

        int cnt[55];
        memset(cnt, 0, sizeof(cnt));
        rep(i, m) {
            rep(j, ng[i].size()) {
                cnt[ng[i][j]]++;
            }
        }

        REP(i, 1, m) {
            if(cnt[i] == 0) return "Does not exist";
        }

        int s = scc.res[0];
        memset(used, 0, sizeof(used));
        out.clear();
        dfs(s);
        reverse(out.begin(), out.end());

        if(out[0] != 0) return "Does not exist";

        rep(i, out.size()-1) {
            bool ch = false;
            rep(j, ng[out[i]].size()) {
                if(ng[out[i]][j] == out[i+1]) {
                    ch = true;
                }
            }

            if(ch) continue;
            return "Does not exist";
        }
        return "Exists";
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM684D2M DivFreed2]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/15/srm684d2m-divfreed2/"/>
    <updated>2016-03-15T23:11:13+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/15/srm684d2m-divfreed2</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14186&rd=16688">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>数列の隣り合う全ての要素<script type="math/tex"> A(1 \leq A \leq k), B(1 \leq B \leq k) </script>が</p>

<ul>
<li><script type="math/tex"> A \leq B </script></li>
<li><script type="math/tex"> A \ \rm{mod} \  B \neq 0 </script></li>
</ul>


<p>のどちらかを満たす数列の数を<script type="math/tex"> \rm{mod} \ 10 ^9 + 7 </script> で求める．</p>

<hr />

<p><script type="math/tex; mode=display">
    dp[i][j] := i番目にjを選んだ時の数列の数
</script></p>

<p>とする．数列に追加する可能なものを選ぶので<script type="math/tex"> B </script>から考えると，<script type="math/tex"> B </script>より大きい，または<script type="math/tex"> AがB </script>を約数に持たなければ良い．基本的に全て遷移可能として(<script type="math/tex"> dp[i+1][j] += \sum_{l = 1} ^{k} dp[i][l]</script>)，後に約数の場所の遷移を無かったことにすれば良い．</p>

<h1>Code</h1>

<pre><code class="cpp">ll dp[15][100005];
vector&lt;ll&gt; d[100005];

vector&lt;ll&gt; divisor(ll n) {
    vector&lt;ll&gt; res;
    for(ll i = 2; i*i &lt;= n; i++) {
        if(n % i == 0) {
            res.push_back(i);
            if(i != n/i) res.push_back(n/i);
        }
    }
    return res;
}

class DivFreed2 {
    public:
    int count(int n, int k) {
        memset(dp, 0, sizeof(dp));

        rep(i, k + 1) {
            d[i].clear();
        }

        REP(i, 2, k + 1) {
            vector&lt;ll&gt; ret = divisor(i);
            ret.push_back(1);

            d[i].resize(ret.size());
            rep(j, ret.size()) {
                d[i][j] = ret[j];
            }
        }

        REP(i, 1, k + 1) {
            dp[1][i] = 1;
        }

        REP(i, 1, n) {
            ll sum = 0;
            REP(j, 1, k + 1) {
                sum += dp[i][j];
                sum %= MOD;
            }

            REP(j, 1, k + 1) {
                dp[i+1][j] += sum;
                dp[i+1][j] %= MOD;
            }

            REP(j, 1, k + 1) {
                rep(l, d[j].size()) {
                    dp[i+1][d[j][l]] -= dp[i][j];
                }
            }
        }

        ll ans = 0;
        rep(j, k + 1) {
            ans += dp[n][j];
            ans %= MOD;
        }

        return ans;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM683 D2H SubtreesCounting]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/04/srm683-d2h-subtreescounting/"/>
    <updated>2016-03-04T16:38:35+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/04/srm683-d2h-subtreescounting</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14179&rd=16653">TopCoder Statistics - Problem Statement</a></h4><p>You are given an undirected tree T. (The input format is specified below.) The vertices of the tree are numbered 0 through n-1. A subtree of T is any subgraph of T that is connected. The size of a subtree is the number of vertices it contains.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<h3>Sample1</h3>

<p>Sample1で構成される木は
<img src="/images/SRM/683d2h-0.png">
である．この木の全ての部分木の頂点数は</p>

<p>頂点数 <script type="math/tex"> 1 \to </script>
<img src="/images/SRM/683d2h-1.png">
<img src="/images/SRM/683d2h-2.png">
<img src="/images/SRM/683d2h-3.png"></p>

<p>頂点数 <script type="math/tex"> 2 \to </script>
<img src="/images/SRM/683d2h-4.png">
<img src="/images/SRM/683d2h-5.png"></p>

<p>頂点数 <script type="math/tex"> 3 \to </script>
<img src="/images/SRM/683d2h-6.png"></p>

<p>よって<script type="math/tex"> 1 + 1 + 1 + 2 + 2 + 3 = 10 </script>である．</p>

<hr />

<p>頂点<script type="math/tex"> i </script>を根とする木に頂点<script type="math/tex"> j </script>を根とする木を付け加える場合を考える．<br/>
<img src="/images/SRM/683d2h-7.png">
を
<img src="/images/SRM/683d2h-8.png">
としたい．<br/>
この時，
<script type="math/tex; mode=display">
\begin{eqnarray}
    dp[i] &amp;:=&amp; iを根とする全ての部分木の頂点数の和 \
    num[i] &amp;:=&amp; iを根とする部分木の個数
\end{eqnarray}
</script>
とすると，頂点数<script type="math/tex">dp[i]はdp[j] * num[i] + dp[i] * num[j] </script>だけ増加する．</p>

<ul>
<li><script type="math/tex"> dp[j] * num[i] </script><br/>
  <img src="/images/SRM/683d2h-9.png">
  <img src="/images/SRM/683d2h-10.png">
  <img src="/images/SRM/683d2h-11.png">
  <img src="/images/SRM/683d2h-12.png"></li>
<li><script type="math/tex"> dp[i] * num[j] </script><br/>
  <img src="/images/SRM/683d2h-12.png">
  <img src="/images/SRM/683d2h-13.png">
  <img src="/images/SRM/683d2h-14.png">
  <img src="/images/SRM/683d2h-15.png">
  <img src="/images/SRM/683d2h-16.png">
  <img src="/images/SRM/683d2h-17.png">
  <img src="/images/SRM/683d2h-18.png">
  <img src="/images/SRM/683d2h-19.png">
  <img src="/images/SRM/683d2h-20.png"></li>
</ul>


<p>同様に部分木の個数<script type="math/tex"> num[i]はnum[i] * num[j] </script>だけ増加する．適当に根を決め，潜って元の頂点に戻る時に足していく．自分の全ての子を潜り終わったらそれ以上変更があることはないので数える．</p>

<h1>Code</h1>

<pre><code class="cpp">struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[100005];
ll dp[100005], num[100005], cnt[100005];
bool used[100005];

void dfs(int cur) {
    used[cur] = true;
    dp[cur] = 1;
    num[cur] = 1;

    rep(i, G[cur].size()) {
        int to = G[cur][i].to;

        if(!used[to]) {
            dfs(to);

            dp[cur] += (dp[cur] * num[to]) + (dp[to] * num[cur]);
            num[cur] += num[cur] * num[to];

            dp[cur] %= MOD;
            num[cur] %= MOD;
        }
    }

    cnt[cur] = dp[cur];
}

class SubtreesCounting {
    public:
    int sumOfSizes(int n, int a0, int b, int c, int m) {

        rep(i, 100005) G[i].clear();

        vector&lt;ll&gt; v(n);
        v[0] = a0;

        REP(i, 1, n-1) {
            v[i] = (b * v[i-1]) % m + c;
            v[i] %= m;
        }

        REP(i, 1, n) {
            int j = v[i-1] % i;
            G[i].push_back(edge(j, 1));
            G[j].push_back(edge(i, 1));
        }

        memset(dp, 0, sizeof(dp));
        memset(num, 0, sizeof(num));
        memset(cnt, 0, sizeof(cnt));
        memset(used, 0, sizeof(used));

        dfs(0);

        ll ans = 0;
        rep(i, n) {
            ans += cnt[i];
            ans %= MOD;
        }

        return ans;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM683 D2M MoveStonesEasy]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/03/srm683-d2m-movestoneseasy/"/>
    <updated>2016-03-03T23:54:40+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/03/srm683-d2m-movestoneseasy</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14182&rd=16653">TopCoder Statistics - Problem Statement</a></h4><p>There are n piles of stones arranged in a line. The piles are numbered 0 through n-1, in order. In other words, for each valid i, piles i and i+1 are adjacent. You are given two int[]s a and b, each with n elements.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>現在の石の山と目的の石の山が渡されるので，左から順番に目的の石の山にしていく．</p>

<h1>Code</h1>

<pre><code class="cpp">    public:
    int get(vector &lt;int&gt; a, vector &lt;int&gt; b) {
        int n = a.size();

        ll ans = 0;
        ll asum = 0, bsum = 0;

        rep(i, n) asum += a[i];
        rep(i, n) bsum += b[i];

        if(asum != bsum) return -1;

        rep(i, n) {
            if(a[i] == b[i]) continue;
            if(a[i] &gt; b[i]) {
                a[i+1] += a[i] - b[i];
                ans += a[i] - b[i];
            } else {
                int len = 1, j = i+1;
                while(a[i] &lt; b[i]) {
                    int d = b[i] - a[i];
                    if(a[j] &gt;= d) {
                        a[j] -= d;
                        a[i] += d;
                        ans += d * len;
                    } else {
                        a[i] += a[j];
                        ans += a[j] * len;
                        a[j] = 0;
                        j++;
                        len++;
                    }
                }
            }
        }

        return ans;
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM682 D2H FriendlyRobot]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/srm682-d2h-friendlyrobot/"/>
    <updated>2016-02-29T01:13:10+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/srm682-d2h-friendlyrobot</id>
    <content type="html"><![CDATA[<p>文字列<script type="math/tex"> U,D,R,L </script>の命令で動くロボットがある．この文字列を<script type="math/tex"> K </script>回書き換えられることが出来るときに，最大で何回<script type="math/tex">(0,0)</script>を通ることが出来るか．</p>

<!-- more -->


<hr />

<p>移動回数が奇数回の時に<script type="math/tex"> (0,0) </script>に戻ることは出来ない．また偶数回の場合でも横方向，縦方向の移動量が共に偶数回，共に奇数回の場合のみ戻ることが出来る．<br/>
また，<script type="math/tex"> +を-に，-を+</script>に変えることで<script type="math/tex"> 2 </script>移動量が変わる．<br/>
そして，戻るために命令を書き換えなければならない回数も以下のように一意に求まる．
<script type="math/tex; mode=display">
\begin{eqnarray}
    共に偶数回 &amp;:=&amp;  \frac{横方向}{2} + \frac{縦方向}{2} \
    共に奇数回 &amp;:=&amp;  \frac{横方向}{2} + \frac{縦方向}{2} + 1\
\end{eqnarray}
</script>
共に奇数回の場合に<script type="math/tex"> +1 </script>されるのは，例えば命令が<script type="math/tex"> UR </script>の場合に<script type="math/tex"> UD </script>に書き換えることで<script type="math/tex"> (0, 0) </script>に戻れるためである．</p>

<p>これより
<script type="math/tex; mode=display">
    dp[i][j] := i番目までの命令列をj回変更した時の(0, 0)を訪れる最大値
</script>
として，総当りしてmaxを取った．</p>

<h1>Code</h1>

<pre><code class="cpp">    public:
    int findMaximumReturns(string s, int K) {

        vector&lt;int&gt; X(s.size() + 1), Y(s.size() + 1);
        int x = 0, y = 0;
        rep(i, s.size()) {
            if(s[i] == 'U') y++;
            if(s[i] == 'D') y--;
            if(s[i] == 'R') x++;
            if(s[i] == 'L') x--;

            X[i+1] = x; Y[i+1] = y;
        }

        rep(i, s.size() + 1) {
            rep(j, K + 1) {
                dp[i][j] = -1;
            }
        }
        dp[0][0] = 0;

        rep(i, s.size() + 1) {
            rep(j, K + 1) {
                if(dp[i][j] == -1) continue;
                for(int k = i + 2; k &lt; s.size() + 1; k += 2) {
                    int s = abs(X[k] - X[i]), t = abs(Y[k] - Y[i]);
                    int res = 0;

                    if(s % 2 == 0 &amp;&amp; t % 2 == 1) continue;
                    if(s % 2 == 1 &amp;&amp; t % 2 == 0) continue;
                    if(s % 2 == 0 &amp;&amp; t % 2 == 0) res = s / 2 + t / 2;
                    if(s % 2 == 1 &amp;&amp; t % 2 == 1) res = s / 2 + t / 2 + 1;

                    if(j + res &gt; K) continue;
                    dp[k][j + res] = max(dp[k][j + res], dp[i][j] + 1);
                }
            }
        }

        ll ans = 0;
        rep(i, s.size() + 1) {
            rep(j, K + 1) {
                ans = max(ans, dp[i][j]);
            }
        }

        return ans;
    }
</code></pre>
]]></content>
  </entry>
  
</feed>
