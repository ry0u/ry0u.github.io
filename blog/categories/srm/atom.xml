<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: srm | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/srm/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-09-03T02:19:57+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM309 D1M KMonotonic]]></title>
    <link href="http://ry0u.github.io/blog/2016/09/03/srm309-d1m-kmonotonic/"/>
    <updated>2016-09-03T01:31:15+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/09/03/srm309-d1m-kmonotonic</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6516&rd=9989">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

数列を$K$個に分けた時に，それぞれの数列に狭義での単調増加数列か，単調減少数列にしたい．要素の値を$1$変更するには$1$コストがかかる時，その最小コストを求める．

---

区間$[l, r)$を単調増加，単調減少の数列にする最小コストがわかれば，後はどこで区切るか，何回区切るかを持ってメモ化再起すれば良いと分かったが，区間$[l, r)$の最小の出し方が分からなかった．解説を見てしまった．

<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://d.hatena.ne.jp/simezi_tan/20120613/1339542749">TopCoder SRM 309 Div1 Medium KMonotonic - simezi_tanの日記</a></h4><p>問題 n本の相異なる直線が与えられる。 n本の直線の集合の、点対称の中心の個数を求めよ。 無限にある場合..</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
単純に区間$[l, r)$だけを状態として持つわけではなく右端の値も持って

$$
	dp[l][r][k] := [l, r)の右端の値をk変更した時の最小値
$$

として動的計画法をした．この$k$変更するという範囲は$-n \sim n$までやっておけば大丈夫という勘違いをして，単調増加の場合には

```cpp
rep(i, n) {
	REP(j, i + 1, n) {
		REP(k, -n, n) {
			REP(l, -n, n) {
				int a = sequence[j-1] + k;
				int b = sequence[j] + l;

				if(a < b) {
					dp[i][j+1][l] = min(dp[i][j+1][l], dp[i][j][k] + abs(sequence[j] - l));
				}
			}
		}
	}
}
```
としていた．これでは$[0, 10000, 0]$といったようなケースには対応出来ないため，変化させるのは各要素に$-n \sim n$足したものを候補としなければならない．となると$n$個の要素に対して$-n \sim n$足した$2n ^2$個の候補が出来るため，上の方法では計算量が$n ^6$となってしまい間に合わない．$[l, r)$の右端が$k(index)$の時，単調増加数列になっているという時は$[l, r-1)$の右端が$k$より小さければ何でも良いので，一番小さいものからの遷移で大丈夫ということが分かる．

```cpp
rep(i, n) {
	int res = INF;
	rep(j, m) {
		res = min(res, abs(sequence[i] - v[j])); //それより以前にコストが少ないものがあればそれで良い
		dp[i][i+1][j] = res;
	}
}

rep(i, n) {
	REP(j, i + 1, n) {
		REP(k, 1, m) {
			dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j][k-1] + abs(sequence[j] - v[k])); //[l, r-1)の右端がv[k]より小さい時の最適コスト + jをv[k]に変えるコスト
			dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j+1][k-1]); // 以前より小さいものがあればそれを採用
		}
	}
}
```
後は区間$[l, r)$の最小コストは$k$に対してループを回した時の最小値となる．単調減少の場合は，候補のvectorをひっくり返して同じことをやった．これが出ると，あとは再起で区間$[l, r)$を残り$k$回分解しなければならない時の最小値として，区切る場所を全て試した．メモリが厳しくて適当に配列を取ったたらMLEした．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

int dp[50][51][50*51*2], up[55][55], down[55][55];

// int memo[50][51][50*51*2];

int dfs(int l, int r, int k) {
	if(dp[l][r][k] != -1) return dp[l][r][k];
	if(k == 1) return min(up[l][r], down[l][r]);

	int ret = INF;
	REP(i, l + 1, r) {
		ret = min(ret, dfs(l, i, 1) + dfs(i, r, k - 1));
	}

	return dp[l][r][k] = ret;
}

class KMonotonic {
	public:
	int transform(vector <int> sequence, int K) {
		int n = sequence.size();
		vector<int> v;
		rep(i, n) {
			REP(j, -n, n + 1) v.push_back(sequence[i] + j);
		}
		sort(v.begin(), v.end());
		v.erase(unique(v.begin(),v.end()),v.end());
		int m = v.size();

		{
			rep(i, 50) rep(j, 51) {
				up[i][j] = INF;
				rep(k, 50 * 51 * 2) dp[i][j][k] = INF;
			}

			rep(i, n) {
				int res = INF;
				rep(j, m) {
					res = min(res, abs(sequence[i] - v[j]));
					dp[i][i+1][j] = res;
				}
			}

			rep(i, n) {
				REP(j, i + 1, n) {
					REP(k, 1, m) {
						dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j][k-1] + abs(sequence[j] - v[k]));
						dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j+1][k-1]);
					}
				}
			}

			rep(i, n) {
				REP(j, i + 1, n + 1) {
					rep(k, m) {
						up[i][j] = min(up[i][j], dp[i][j][k]);
					}
				}
			}
		}
		{
			reverse(v.begin(), v.end());
			rep(i, 50) rep(j, 51) {
				down[i][j] = INF;
				rep(k, 50 * 51 * 2) dp[i][j][k] = INF;
			}

			rep(i, n) {
				int res = INF;
				rep(j, m) {
					res = min(res, abs(sequence[i] - v[j]));
					dp[i][i+1][j] = res;
				}
			}

			rep(i, n) {
				REP(j, i + 1, n) {
					REP(k, 1, m) {
						dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j][k-1] + abs(sequence[j] - v[k]));
						dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j+1][k-1]);
					}
				}
			}
			
			rep(i, n) {
				REP(j, i + 1, n + 1) {
					rep(k, m) {
						down[i][j] = min(down[i][j], dp[i][j][k]);
					}
				}
			}
		}

		rep(i, n) rep(j, n + 1) rep(k, m) dp[i][j][k] = -1;
		int ret = dfs(0, n, K);
		return ret;
	}

};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM309 D2H SynchronizingGuideposts]]></title>
    <link href="http://ry0u.github.io/blog/2016/09/03/srm309-d2h-synchronizingguideposts/"/>
    <updated>2016-09-03T01:15:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/09/03/srm309-d2h-synchronizingguideposts</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6242&rd=9989">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

guidepostsの$position\ distance\ limit$が与えられる．$limit$以上動かすときは余計に$C$かかる．一箇所に集めるときのコストの最小を求める．  
それぞれの場所($position + distance$)とそこから$+limit$，$-limit$動かした場所を動かす場所の候補にする．intだとオーバーフローする．


# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1LL<<60
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

vector<string> split(const string &str, char delim) {
	vector<string> res;
	size_t current = 0, found;
	while((found = str.find_first_of(delim, current)) != string::npos) {
		res.push_back(string(str, current, found - current));
		current = found + 1;
	}
	res.push_back(string(str, current, str.size() - current));
	return res;
}

class SynchronizingGuideposts {
	public:
	long long minCost(vector <string> guideposts, int C) {
		int n = guideposts.size();
		vector<ll> pos(n), dis(n), lim(n);

		rep(i, n) {
			ll x;
			vector<string> ret = split(guideposts[i], ' ');
			{
				stringstream ss(ret[0]);
				ss >> x;
				pos[i] = x;
			}
			{
				stringstream ss(ret[1]);
				ss >> x;
				dis[i] = x;
			}
			{
				stringstream ss(ret[2]);
				ss >> x;
				lim[i] = x;
			}
		}

		set<ll> st;
		st.insert(0);

		rep(i, n) {
			if(pos[i] + dis[i] - lim[i] >= 0)
				st.insert(pos[i] + dis[i] - lim[i]);
			if(pos[i] + dis[i] >= 0)
				st.insert(pos[i] + dis[i]);
			if(pos[i] + dis[i] + lim[i] >= 0)
				st.insert(pos[i] + dis[i] + lim[i]);
		}

		ll ans = INF;
		each(it, st) {
			ll sum = 0;
			rep(i, n) {
				ll res = abs(pos[i] + dis[i] - *it);
				sum += res;
				if(res > lim[i]) {
					sum += (res - lim[i]) * C;
				}
			}

			ans = min(ans, sum);
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM309 D1H-D2M ScoreRecomposition]]></title>
    <link href="http://ry0u.github.io/blog/2016/09/03/srm309-d1h-d2m-scorerecomposition/"/>
    <updated>2016-09-03T00:55:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/09/03/srm309-d1h-d2m-scorerecomposition</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6241&rd=9989">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

各問題の正解している問題の点数の合計が$score$であり，不正解の問題の点数と番号の差の絶対値の最大値を最小化する．  
$n \leq 10$なので，全部列挙して点数の合計と差の絶対値を全て計算する．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

class ScoreRecomposition {
	public:
	int minError(string questions, int score) {
		int n = questions.size();
		vector<int> id;
		rep(i, n) id.push_back(i + 1);

		int ans = INF;
		do {
			int sum = 0, res = 0;
			rep(i, n) {
				if(questions[i] == 'C') {
					sum += id[i];
				}
				res = max(res, abs(i + 1 - id[i]));
			}

			if(sum == score) {
				ans = min(ans, res);
			}

		} while(next_permutation(id.begin(), id.end()));

		if(ans == INF) return -1;
		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM308 CornersGame]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/31/srm308-cornersgame/"/>
    <updated>2016-08-31T02:51:14+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/31/srm308-cornersgame</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6475&rd=9988">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$6 \times 6$の盤面が与えられて，右下の$2 \times 2$にはコインが置いてある．最終的に左上$2 \times 2$に移動させたい．コインの移動は$2$種類ある．

* 隣接したマスに障害物がなければ移動できる
* 隣接したマスが石かコインでそれをジャンプした先に障害物がなければ移動できる

もし移動出来なければ$-1$，そうでなければ最小の移動回数を返す．

---

読み飛ばしていて死んでいた．ジャンプできるのは石だけだと思っていて，最初のサンプルが$16$になる理由が全くわからなかった．問題文を読みなおすと$top\ left$かつ正方形ならなんでも良いのかと思って，それを全探索したりしていた．  
コインもジャンプ可能なので，順番に飛ばし飛ばしで行くとコストが少なくいける．(移動回数, 盤面)を状態として，移動回数が少ない順に見ていった．  
Sample0
{% img /images/SRM/308.gif %}

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;
typedef pair<int, vector<string> > IS;

int dy[4] = {1, 0, -1, 0};
int dx[4] = {0, 1, 0, -1};

bool can(int y, int x) {
	if(0 <= y && y < 6 && 0 <= x && x < 6) return true;
	return false;
}


class CornersGame {
	public:
	int countMoves(vector <string> board) {
		int n = 6;
		vector<string> s = board;
		s[n-2][n-2] = 'X';
		s[n-2][n-1] = 'X';
		s[n-1][n-2] = 'X';
		s[n-1][n-1] = 'X';

		set<vector<string> > st;
		priority_queue<IS, vector<IS>, greater<IS> > que;
		que.push(mp(0, s));

		while(que.size()) {
			IS is = que.top(); que.pop();
			int cnt = is.first;
			s = is.second;

			if(s[0][0] == 'X' && s[0][1] == 'X' && s[1][0] == 'X' && s[1][1] == 'X') {
				return cnt;
			}

			rep(i, n) {
				rep(j, 6) {
					if(s[i][j] != 'X') continue;

					rep(k, 4) {
						int y = i + dy[k];
						int x = j + dx[k];

						if(can(y, x) && s[y][x] == '.') {
							vector<string> t = s;
							swap(t[i][j], t[y][x]);
							if(st.find(t) == st.end()) {
								st.insert(t);
								que.push(mp(cnt + 1, t));
							}
						}

						int ny = y + dy[k];
						int nx = x + dx[k];

						if(can(y, x) && (s[y][x] == 's' || s[y][x] == 'X') && can(ny, nx) && s[ny][nx] == '.') {
							vector<string> t = s;
							swap(t[i][j], t[ny][nx]);
							if(st.find(t) == st.end()) {
								st.insert(t);
								que.push(mp(cnt + 1, t));
							}
						}
					}
				}
			}
		}

		return -1;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM308 D2H TreasuresPacking]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/31/srm308-d2h-treasurespacking/"/>
    <updated>2016-08-31T02:36:51+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/31/srm308-d2h-treasurespacking</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6476&rd=9988">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$weight, cost,$分割できるかどうかが与えられる．$W$まで持つことが出来る時の$cost$の最大値を求める．  
まず分割できないものを先に$dp[i][j] := i$番目まで見た時, 重さ$j$の時の最大値として動的計画法．分割出来るものは全て重さ$1$ずつに分けて，価値が高い順に使うのが良い．$dp[i][j] + (W - j)$個の分割したものを出してその最大値を取った．  

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

vector<string> split(const string &str, char delim) {
	vector<string> res;
	size_t current = 0, found;
	while((found = str.find_first_of(delim, current)) != string::npos) {
		res.push_back(string(str, current, found - current));
		current = found + 1;
	}
	res.push_back(string(str, current, str.size() - current));
	return res;
}

double dp[55][10005];

class TreasuresPacking {
	public:
	double maximizeCost(vector <string> treasures, int W) {
		vector<int> w, c;
		vector<double> v;

		rep(i, treasures.size()) {
			int a, b;
			vector<string> ret = split(treasures[i], ' ');

			{
				stringstream ss(ret[0]);
				ss >> a;
			}
			{
				stringstream ss(ret[1]);
				ss >> b;
			}

			if(ret[2] == "Y") {
				REP(i, 1, a + 1) {
					v.push_back(1.0 / a * b);
				}
			} else {
				w.push_back(a);
				c.push_back(b);
			}
		}

		sort(v.begin(), v.end(), greater<double>());
		v.insert(v.begin(), 0);
		REP(i, 1, v.size()) {
			v[i] += v[i-1];
		}

		int n = w.size();
		memset(dp, 0, sizeof(dp));

		rep(i, n) {
			rep(j, W + 1) {
				if(j - w[i] < 0) {
					dp[i+1][j] = dp[i][j];
				} else {
					dp[i+1][j] = max(dp[i][j], dp[i][j-w[i]] + c[i]);
				}
			}
		}

		double ans = 0;
		rep(j, W + 1) {
			int m = W - j;
			if(m < v.size()) {
				ans = max(ans, dp[n][j] + v[m]);
			}
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
</feed>
