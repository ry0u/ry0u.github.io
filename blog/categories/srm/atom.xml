<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: srm | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/srm/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-10T01:42:35+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM339 D1M TestBettingStrategy]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/10/srm339-d1m-testbettingstrategy/"/>
    <updated>2017-02-10T01:32:03+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/10/srm339-d1m-testbettingstrategy</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7422&rd=10663">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

勝ったら$bet$は$1$，負けたら次の$bet$を$2$倍にする．勝負に勝つ確立は毎回$prob$である．はじめ$initSum$所持していて，$rounds$回行い，$goalSum$以上になる確立を求める．

$$
	dp[i][j][k] := iターン目に所持金jでk回負けた時の確立
$$

何回負けたかを持つと$bet$が$(1 << k)$で求まる．後は$bet$が所持金を超えないならば，勝つ，負ける，それぞれの場合に遷移させる．勝った場合は$k$は$0$になる．$goalSum$以上超えた場合は終わりなので，$j$は$goalSum$未満しか見ない．最後には，全てのラウンド内で$goalSum$以上になったものを全て足す．

```cpp
#include <bits/stdc++.h>

#define rep(i,n) for(int i=0;i<(int)(n);i++)
#define REP(i,k,n) for(int i=k;i<(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

double dp[55][1005][10];

class TestBettingStrategy {
	public:
	double winProbability(int initSum, int goalSum, int rounds, int prob) {
		memset(dp, 0, sizeof(dp));
		dp[0][initSum][0] = 1;

		double p = prob / 100.0;

		rep(i, rounds) {
			rep(j, goalSum) {
				rep(k, 10) {
					int bet = (1 << k);
					if(j >= bet) {
						dp[i+1][j + bet][0] += dp[i][j][k] * p;
						dp[i+1][j - bet][k+1] += dp[i][j][k] * (1 - p);
					}
				}
			}
		}

		double ans = 0;
		REP(i, 1, rounds + 1) {
			REP(j, goalSum, 1005) {
				rep(k, 10) {
					ans += dp[i][j][k];
				}
			}
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM339 D2H OnTime]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/10/srm339-d2h-ontime/"/>
    <updated>2017-02-10T00:11:24+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/10/srm339-d2h-ontime</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7423&rd=10663">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

駅$0$から駅$n-1$に行きたい．空白区切りで$a\ b\ departure\ time\ cost$が与えられる．駅$a$と駅$b$を結ぶバスは，時刻$departure$に出発し，時間$time$かかり，コストは$cost$である．時刻$T$以内に駅$n-1$に着けない場合は$-1$，着ける場合は最小コストを答える．

---

(駅番号, 時刻)を状態にしてdijkstra．

```cpp
#include <bits/stdc++.h>

#define rep(i,n) for(int i=0;i<(int)(n);i++)
#define REP(i,k,n) for(int i=k;i<(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair<int, int> P;
typedef pair<P, int> PI;
typedef pair<P, P> PP;

vector<string> split(const string &str, char delim) {
	vector<string> res;
	size_t current = 0, found;
	while((found = str.find_first_of(delim, current)) != string::npos) {
		res.push_back(string(str, current, found - current));
		current = found + 1;
	}
	res.push_back(string(str, current, str.size() - current));
	return res;
}

vector<PP> G[55];
int d[55][100005];

void dijkstra() {
	rep(i, 55) rep(j, 100005) d[i][j] = INF;
	d[0][0] = 0;

	priority_queue<PI, vector<PI>, greater<PI> > que;
	que.push(mp(mp(0, 0), 0));

	while(que.size()) {
		PI p = que.top(); que.pop();
		int c = p.fi.fi;
		int t = p.fi.se;
		int cur = p.se;

		if(d[cur][t] < cur) continue;

		rep(i, G[cur].size()) {
			int departure = G[cur][i].fi.fi;
			int time = G[cur][i].fi.se;
			int cost = G[cur][i].se.fi;
			int next = G[cur][i].se.se;

			if(departure != 0 && time != 0 && departure <= t) continue;
			if(d[next][departure + time] > c + cost) {
				d[next][departure + time] = c + cost;
				que.push(mp(mp(c + cost, departure + time), next));
			}
		}
	}
}

class OnTime {
	public:
	int minCost(int N, int T, vector <string> buses) {
		rep(i, 55) G[i].clear();

		int M = buses.size();
		rep(i, M) {
			stringstream ss;
			ss << buses[i];
			int a, b, departure, time, cost;
			ss >> a >> b >> departure >> time >> cost;

			G[a].push_back(mp(mp(departure, time), mp(cost, b)));
		}

		dijkstra();

		int ans = INF;
		rep(i, T + 1) {
			ans = min(ans, d[N-1][i]);
		}

		if(ans == INF) return -1;
		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM338 D1M RandomSwaps]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/09/srm338-d1m-randomswaps/"/>
    <updated>2017-02-09T23:31:27+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/09/srm338-d1m-randomswaps</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7289&rd=10662">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

長さ$arrayLength$の配列の要素を$swapCount$回swapする．初めに$a$番目にあったものが$b$番目にいる確立を求める．

$$
	dp[i][j] := i回swapした時にb番目にいる確立
$$

一回のswapの選択肢は$\displaystyle \frac{n*(n-1)}{2}$通りある．swap後に$b$番目にいる場合は，元々$b$番目にいてswapに$b$番目が選ばれない場合と，他の場所にいてその場所と$b$番目をswapする場合である．swap後に$b$番目にいない場合は，元々$b$番目にいて他の場所にswapされる場合と，他の場所にいてその場所と$b$番目がswapされない場合である．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

double dp[100005][2];

class RandomSwaps {

    public:

    double getProbability(int arrayLength, int swapCount, int a, int b) {
		int n = arrayLength;
		int cnt = swapCount;

		memset(dp, 0, sizeof(dp));
		
		dp[0][a == b] = 1;

		double N = (n * (n - 1)) / 2;
		rep(i, cnt) {
			dp[i+1][1] = dp[i][1] * (1 - (n - 1) / N) + dp[i][0] * (1.0 / N);
			dp[i+1][0] = dp[i][1] * ((n - 1) / N) + dp[i][0] * (1 - 1.0 / N);
		}

		return dp[cnt][1];
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM338 D1E-D2M ImprovingStatistics]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/09/srm338-d1e-d2m-improvingstatistics/"/>
    <updated>2017-02-09T23:13:01+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/09/srm338-d1e-d2m-improvingstatistics</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7386&rd=10662">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$played$, $won$が与えられる．勝率は$\displaystyle \frac{won}{played}$の百分率で表す(小数点以下は切り捨て)．これ以降プレイする場合は必ず勝つ場合に，あと何回プレイすれば勝率を$+1$することができるか．

---

あと何回プレイするかを$[0, 10 ^9 + 5)$で二分探索．勝率が$+1$を満たす最も小さいものを求める．$\displaystyle \frac{won}{played}$の百分率に端数が無い場合にfloorを用いると$-1$してしまうので，その場合は$+1$して戻す．

```cpp
#include <bits/stdc++.h>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

class ImprovingStatistics {

    public:

    int howManyGames(int played, int won) {
		double a = played;
		double b = won;
		double t = floor(b / a * 100);

		if((t + 1) / 100 == b / a) {
			t++;
		}

		ll l = 0, r = 1e9 + 5;


		while(r - l > 1) {
			ll mid = (l + r) / 2;
			ll f = floor( ((b + mid) / (a + mid)) * 100 );
			if(f < t + 1) {
				l = mid;
			} else {
				r = mid;
			}
		}

		if(r == 1e9 + 5) return -1;
		return r;
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM337 D1M BuildingAdvertise]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/06/srm337-d1m-buildingadvertise/"/>
    <updated>2017-02-06T00:00:20+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/06/srm337-d1m-buildingadvertise</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7473&rd=10661">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

$N \leq 100000$の要素を持つ配列$R$を作る．$R$中の最大長方形を求める．最大長方形として使われる一番小さい要素を$1$つを全探索する．使う要素$i$を一つ決めると，それが一番小さいという仮定があるので，$[left, i]$と$[i, right]$のminが$R[i]$である必要があり，この条件を満たす端を求める二分探索をすることで答えが求まる．区間$[i, n)$で$min = R[i]$を満たす最も右端$right$と，$(-1, i]$で$min = R[i]$を満たす最も左端$left$が求まったとすると，$i$を一番小さい要素として使用した最大長方形は$R[i] * (right - left)$となる．

```cpp
#include <bits/stdc++.h>

#define rep(i,n) for(int i=0;i<(int)(n);i++)
#define REP(i,k,n) for(int i=k;i<(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

struct RMQ {
	int n;
	vector<int> dat;
	RMQ(int n_) {
		n = 1;
		while(n < n_) n *= 2;

		dat.resize(n*4);
		rep(i,n*4) dat[i] = INF;
	}
	void update(int k,int a) {
		int i = k+n-1;
		dat[i] = a;

		while(i > 0) {
			i = (i-1) / 2;
			dat[i] = min(dat[i*2+1],dat[i*2+2]);
		}
	}
	//query(a,b,0,0,n) [a,b)
	int _query(int a,int b,int k,int l,int r)
	{
		if(r <= a || b <= l) return INF;

		if(a <= l && r <= b) return dat[k];
		else { 
			int vl = _query(a,b,k*2+1,l,(l+r)/2);
			int vr = _query(a,b,k*2+2,(l+r)/2,r);
			return min(vl,vr);
		}
	}

	//[a,b)
	int query(int a,int b) {
		return _query(a,b,0,0,n);
	}
};

class BuildingAdvertise {
	public:
	long long getMaxArea(vector <int> h, int n) {
		vector<ll> R(n);
		int j = 0, m = h.size(), s= 0;

		rep(i, n) {
			R[i] = h[j];
			s = (j+1) % m;
			h[j] = ((h[j] ^ h[s]) + 13) % 835454957;
			j = s;
		}

		RMQ rmq(n);
		rep(i, n) {
			rmq.update(i, R[i]);
		}

		ll ans = 0;
		rep(i, n) {
			// [i, n)
			int l = i, r = n;
			while(r - l > 1) {
				int mid = (r + l) / 2;
				if(rmq.query(i, mid+1) < R[i]) {
					r = mid;
				} else {
					l = mid;
				}
			}

			// (-1, i]
			int right = r;
			l = -1, r = i;
			while(r - l > 1) {
				int mid = (r + l) / 2;
				if(rmq.query(mid, i+1) < R[i]) {
					l = mid;
				} else {
					r = mid;
				}
			}
			int left = r;

			ans = max(ans, R[i] * (right - left));
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
</feed>
