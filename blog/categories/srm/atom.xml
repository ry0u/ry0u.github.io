<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: srm | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/srm/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2015-10-25T04:35:37+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM663 ABBA]]></title>
    <link href="http://ry0u.github.io/blog/2015/07/24/srm663-abba/"/>
    <updated>2015-07-24T18:55:13+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/07/24/srm663-abba</id>
    <content type="html"><![CDATA[<p>ある文字列Iに，2つの操作が出来る．<br/>
- 文字列の最後に"A"を足す<br/>
- 文字列を反転して，最後に"B"を足す</p>

<p>文字列Iが文字列Tになるかを判定せよ</p>

<h1>考察</h1>

<p>愚直にIに操作していくと，2<sup>T.size()-I.size()</sup>で無理．しかしTから減らしていくには，一意しかない．末尾が"A"ならば，一つ前の状態をpreTとすると，T = preT+&ldquo;A"となる．まと同様に，末尾が"B"ならば，T = reverse(preT) + "B"である．これを繰り返し，Iと同じsizeになった時に，同じかどうかで判定できる．</p>

<h1>Code</h1>

<pre><code class="cpp">#line 5 "ABBA.cpp"
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)

using namespace std;
typedef long long ll;

class ABBA {
    public:
    string canObtain(string I, string T) {

        while(T != I &amp;&amp; T.size() &gt; I.size()) {
            if(T[T.size()-1] == 'A') {
                T = T.substr(0,T.size()-1);
            }else {
                T = T.substr(0,T.size()-1);
                reverse(T.begin(),T.end());
            }
        }

        if(T == I) return "Possible";
        return "Impossible";
    }
};
</code></pre>

<p>コードを短く，シンプルにかける．本番中は誤読をしていて死んでいた．このある状態を目的の状態にする問題で，逆からやると上手くいく系はすぐ解けるようになりたい．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM502 TheLotteryBothDivs]]></title>
    <link href="http://ry0u.github.io/blog/2015/07/17/srm502-thelotterybothdivs/"/>
    <updated>2015-07-17T19:44:40+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/07/17/srm502-thelotterybothdivs</id>
    <content type="html"><![CDATA[<p>000000000~999999999の10<sup>9</sup>の中で宝くじが当たる確率を求める．また下の桁が一致していれば当たりとなる．</p>

<h1>考察</h1>

<p>まず同じ数が与えられる可能性もあるので，setに投げて重複を消してから，下の桁が一致している数を消す．桁数が小さいほうが含まれるものが多いので，桁数が大きい方を消す．
後は0.1<sup>桁数</sup>のsumが答えとなる．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)

using namespace std;
typedef long long ll;

class TheLotteryBothDivs {
    public:
    double find(vector &lt;string&gt; goodSuffixes) {
        set&lt;string&gt; st;
        rep(i,goodSuffixes.size()) {
            st.insert(goodSuffixes[i]);
        }

        vector&lt;string&gt; v;
        set&lt;string&gt;::iterator ite;
        for(ite = st.begin();ite != st.end(); ite++) {
            v.push_back(*ite);
        }

        vector&lt;string&gt; res;
        rep(i,v.size()) {
            bool flag = false;
            rep(j,v.size()) {
                if(v[i].size() &gt; v[j].size()) {
                    bool ch = true;
                    rep(k,v[j].size()) {
                        if(v[i][v[i].size()-1-k] == v[j][v[j].size()-1-k]) continue;
                        ch = false;
                    }

                    if(ch) flag = true;
                }
            }
            if(!flag) res.push_back(v[i]);
        }

        double ans = 0;
        rep(i,res.size()) {
            double t = 1.0;

            rep(j,res[i].size()) {
                t *= 0.1;
            }

            ans += t;
        }
        return ans;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM501 FoxPlayingGame]]></title>
    <link href="http://ry0u.github.io/blog/2015/07/16/srm501-foxplayinggame/"/>
    <updated>2015-07-16T02:56:16+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/07/16/srm501-foxplayinggame</id>
    <content type="html"><![CDATA[<p>scoreAをnA回足す，scoreBをnB回掛ける．この操作による最大値を求める．また</p>

<p><script type="math/tex; mode=display">
scoreA = paramA / 1000.0 \
scoreB = paramB / 1000.0
</script></p>

<p>として与えられる．</p>

<h1>考察</h1>

<p>掛ける場合は最初の0の状態に掛けることができるので，回数を調整できるが，足す場合はそのようなことができない．よって，まずscoreAをnA回足す．また，この値が+か-かによって場合分けをする</p>

<hr />

<ul>
<li>+の場合かつscoreBが1以上の場合は，全て掛ける．</li>
<li>+の場合かつscoreBが-1以下の場合は，(scoreB)<sup>2</sup>は正なので偶数回掛けるのが最大</li>
<li>+の場合かつscoreBがそれ以外の場合は，減少するため，最初の0に掛けて消す</li>
</ul>


<hr />

<ul>
<li>-の場合かつscoreBが1以上の場合は，負の値が増加してしまうので掛けない</li>
<li>-の場合かつscoreBが-1以下の場合は，奇数回掛けることによって値を正にすることができる</li>
<li>-の場合かつscoreBが0より大きく1以下の場合は，負の値を小さくすることができるので全部掛ける</li>
<li>-の場合かつscoreBが-1以上0より小さい場合は，一度だけ掛けて値を正することが最大</li>
</ul>


<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)

using namespace std;
typedef long long ll;

class FoxPlayingGame {
    public:
    double theMax(int nA, int nB, int paramA, int paramB) {
        double A = paramA / 1000.0;
        double B = paramB / 1000.0;

        double res = nA * A;
        if(res &gt; 0) {
            if(B &lt;= -1) {
                nB -= nB%2;
                rep(i,nB) {
                    res *= B;
                }
            }else if(B &gt;= 1) {
                rep(i,nB) {
                    res *= B;
                }
            }
        }else {
            if(0 &lt;= B &amp;&amp; B &lt; 1.0) {
                rep(i,nB) {
                    res *= B;
                }
            }
            else if(-1.0 &lt; B &amp;&amp; B &lt; 0) {
                if(nB != 0) res *= B;
            }
            else if(B &lt;= -1) {
                if(nB%2 == 0) nB--;
                rep(i,nB) {
                    res *= B;
                }
            }
        }

        return res;

    }
};
</code></pre>

<p>SystemTestに落ちまくり．特にscoreAが負，scoreBが負の時に，一度だけscoreBを掛ければよかったが，ここでnBが0の時の処理を加えればいいことに全く気づけなかった．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM500 GeometricProgressions]]></title>
    <link href="http://ry0u.github.io/blog/2015/07/14/srm500-geometricprogressions/"/>
    <updated>2015-07-14T14:45:12+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/07/14/srm500-geometricprogressions</id>
    <content type="html"><![CDATA[<p>2つの等比数列が与えられる．この中で異なる数の個数を求める</p>

<h1>考察</h1>

<p>愚直に計算するとオーバーフローする．ここで素因数分解を考える．いつも素因数分解というと
<script type="math/tex; mode=display">
S = p<em>{1} p</em>{2} &hellip; p<em>{r}
</script>
としていたが，(このままではやったらTLEになるので)
<script type="math/tex; mode=display">
S = p</em>{1}^{e<em>{1}} p</em>{2}^{e<em>{2}} &hellip; p</em>{r}^{e_{r}}
</script>
とした．</p>

<p>素因数分解は必ず一意に定まるので数が等しければ素因数分解も等しい．後はこれをmapに突っ込んでsizeを取った．<br/>
SystemTest落ちまくり．以下の事を全く頭に入れていなかった．<br/>
- 初項が0なら必ず0<br/>
- 公比が1の場合は，必ず初項<br/>
- 初項が0でなく公比が0の場合は，n == 1ならば0<sup>0</sup> = 1より初項だけ，n != 1ならば初項と0になる．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)

using namespace std;
typedef long long ll;

vector&lt;int&gt; func(int n) {
    vector&lt;int&gt; ret;
    if(n == 0 || n == 1) {
        ret.push_back(n);
        return ret;
    }

    int a = 2;
    while(n &gt;= a*a) {
        if(n%a == 0) {
            n /= a;
            ret.push_back(a);
        }
        else {
            a++;
        }
    }

    if(n &gt; 1) ret.push_back(n);

    return ret;
}

class GeometricProgressions {
    public:
    int count(int b1, int q1, int n1, int b2, int q2, int n2) {
        map&lt;vector&lt;pair&lt;int,int&gt; &gt;,int&gt; m;

        vector&lt;int&gt; B1 = func(b1);
        vector&lt;int&gt; Q1 = func(q1);
        vector&lt;int&gt; B2 = func(b2);
        vector&lt;int&gt; Q2 = func(q2);

        map&lt;int,int&gt; cnt;
        rep(i,B1.size()) {
            cnt[B1[i]]++;
        }

        vector&lt;pair&lt;int,int&gt; &gt; v;
        map&lt;int,int&gt;::iterator ite;
        for(ite = cnt.begin();ite != cnt.end();ite++) {
            v.push_back(make_pair(ite-&gt;first,ite-&gt;second));
        }

        m[v]++;

        if(q1 == 0) {
            if(b1 != 0 &amp;&amp; n1 != 1) {
                vector&lt;pair&lt;int,int&gt; &gt; res;
                res.push_back(make_pair(0,1));
                m[res]++;
            }
        }
        else if(b1 != 0 &amp;&amp; q1 != 1) {
            rep(i,n1-1) {
                rep(j,Q1.size()) cnt[Q1[j]]++;

                vector&lt;pair&lt;int,int&gt; &gt; res;
                map&lt;int,int&gt;::iterator ite;
                for(ite = cnt.begin();ite != cnt.end();ite++) {
                    res.push_back(make_pair(ite-&gt;first,ite-&gt;second));
                }
                m[res]++;
            }
        }

        map&lt;int,int&gt; cnt2;
        rep(i,B2.size()) {
            cnt2[B2[i]]++;
        }

        vector&lt;pair&lt;int,int&gt; &gt; v2;
        for(ite = cnt2.begin();ite != cnt2.end();ite++) {
            v2.push_back(make_pair(ite-&gt;first,ite-&gt;second));
        }

        m[v2]++;

        if(q2 == 0) {
            if(b2 != 0 &amp;&amp; n2 != 1) {
                vector&lt;pair&lt;int,int&gt; &gt; res;
                res.push_back(make_pair(0,1));
                m[res]++;
            }
        }
        else if(b2 != 0 &amp;&amp; q2 != 1) {
            rep(i,n2-1) {
                rep(j,Q2.size()) cnt2[Q2[j]]++;

                vector&lt;pair&lt;int,int&gt; &gt; res;
                map&lt;int,int&gt;::iterator ite;
                for(ite = cnt2.begin();ite != cnt2.end();ite++) {
                    res.push_back(make_pair(ite-&gt;first,ite-&gt;second));
                }

                m[res]++;
            }
        }

        return m.size();
    }
};
</code></pre>

<p>場合分けの書き方がやばい．もっとシンプルに書けるようになりたい．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM662 Flee]]></title>
    <link href="http://ry0u.github.io/blog/2015/07/11/srm662-flee/"/>
    <updated>2015-07-11T22:34:20+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/07/11/srm662-flee</id>
    <content type="html"><![CDATA[<p>(0,0)から(10<sup>100</sup>,0)に行きたい．最大3つまで警備員の場所が与えられる．目的地に行くことが出来る最大の距離を求める．</p>

<p>Sample0<br/>
<img src="/images/SRM662/sample1.png"><br/>
右にそのまま行く</p>

<p>Sample1<br/>
<img src="/images/SRM662/sample2.png"><br/>
これ以上大きくすると原点を覆ってしまう.また同じ点が与えられることもある</p>

<p>Sample2<br/>
<img src="/images/SRM662/sample3.png"><br/>
右の道は行けないけど左上を通ればよい</p>

<p>Sample3<br/>
<img src="/images/SRM662/sample4.png"><br/>
これもSample0と同様右でよい</p>

<h1>考察</h1>

<p>場合分けして考えた.<br/>
- n = 1の時は，原点との距離が最大の距離である<br/>
- n = 2の時は，原点との距離が小さい方が最大の距離である<br/>
- n = 3の時は，その3点で構成される三角形に内包されているかいないかに分ける</p>

<h3>内包されていない場合</h3>

<p>具体的に内包されていないとは次のような場合である
<img src="/images/SRM662/image1.png"><br/>
このような場合は原点を覆わないようにすればよいので，原点との距離が最小となる距離を選べばよい
<img src="/images/SRM662/image2.png"></p>

<h3>内包されている場合</h3>

<p>Sample0を考える．この場合の原点との距離が最小なのは5.09&hellip;である．しかしこの距離を採用すると，これでは目的地に行くことが出来ない．
<img src="/images/SRM662/image3.png"><br/>
ここで答えの5は(1,5)と(1,-5)との距離の半分である．つまり原点を覆わずに，円が重ならない場所が1つでもあればよい．
<img src="/images/SRM662/image4.png"></p>

<h1>Code</h1>

<p>内包されている場合は各頂点と原点との距離の最小値と，各頂点間の距離の半分の中から条件を満たす最大値を返す．また距離を考える場合,ルートを取らずに自乗和を比較した(sampleで死んだ)．</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define EPS 1e-9
#define INF 1&lt;&lt;30

using namespace std;
typedef long long ll;

struct Point {
    double x, y;

    Point(double x=0, double y=0) : x(x), y(y) {}

    Point operator+(const Point &amp;o) const { return Point(x+o.x, y+o.y); }

    Point operator-(const Point &amp;o) const { return Point(x-o.x, y-o.y); }

    Point operator*(const double m) const { return Point(x*m, y*m); }

    Point operator/(const double d) const { return Point(x/d, y/d); }

    bool operator&lt;(const Point &amp;o) const { return x != o.x ? x &lt; o.x : y &lt; o.y; }

    bool operator==(const Point &amp;o) const { return fabs(x-o.x) &lt; EPS &amp;&amp; fabs(y-o.y) &lt; EPS; }

    double cross(const Point &amp;o) const { return x * o.y - y * o.x; }

    double dot(const Point &amp;o) const { return x * o.x + y * o.y; }

    double atan() const { return atan2(y, x); }

    double norm() const { return sqrt(dot(*this)); }

    double distance(const Point &amp;o) const { return (o - (*this)).norm(); }

    double area(const Point &amp;a,const Point &amp;b) {
        Point p = a - (*this), p2 = b - (*this); 
        return p.cross(p2);
    }

    double area_abs(const Point &amp;a,const Point &amp;b) const {
        Point p = a - (*this), p2 = b - (*this);
        return fabs(p.cross(p2)) / 2.0;
    }   

    // //線分abが自身に含まれているのかどうか判断する
    // int between(const Point &amp;a,const Point &amp;b) {
    //     if(area(a,b) != 0) return 0;
    //
    //     if(a.x != b.x)  return ((a.x &lt;= x) &amp;&amp; (x &lt;= b.x) || (a.x &gt;= x) &amp;&amp; (x &gt;= b.x));
    //     else return ((a.y &lt;= y) &amp;&amp; (y &lt;= b.y) || (a.y &gt;= y) &amp;&amp; (y &gt;= b.y));
    // }      

    double distance_seg(const Point&amp; a,const Point&amp; b) {
        if((b-a).dot(*this-a) &lt; EPS) {
            return (*this-a).norm();
        }
        if((a-b).dot(*this-b) &lt; EPS) {
            return (*this-b).norm();
        }
        return abs((b-a).cross(*this-a)) / (b-a).norm();
    }

    bool hitPolygon(const Point&amp; a,const Point&amp; b,const Point&amp; c) {
        double t = (b-a).cross(*this-b);
        double t2 = (c-b).cross(*this-c);
        double t3 = (a-c).cross(*this-a);   

        if((t &gt; 0 &amp;&amp; t2 &gt; 0 &amp;&amp; t3 &gt; 0) || ( t &lt; 0 &amp;&amp; t2 &lt; 0 &amp;&amp; t3 &lt; 0)) {
            return true;
        }

        return false;
    }
};

class Flee {
    public:
    double maximalSafetyLevel(vector &lt;int&gt; x, vector &lt;int&gt; y) {
        int n = x.size();

        vector&lt;Point&gt; v;
        map&lt;pair&lt;int,int&gt;,bool &gt; m;
        rep(i,n) {
            pair&lt;int,int&gt; p = make_pair(x[i],y[i]);
            if(m[p]) continue;

            v.push_back(Point(x[i],y[i]));
            m[p] = true;
        }

        double ans = 0;

        if(v.size() == 1) {
            ans = v[0].norm();
        }
        else if(v.size() == 2) {
            ans = min(v[0].norm(),v[1].norm());
        }else {
            vector&lt;int&gt; d;
            int res = INF;
            rep(i,v.size()) {
                res = min(res,(int)(v[i]*2).dot(v[i]*2));
            }

            d.push_back(res);

            Point p(0,0);
            if(p.hitPolygon(v[0],v[1],v[2])) {
                rep(i,v.size()) {
                    rep(j,v.size()) {
                        if(i == j) continue;

                        Point p(v[i]-v[j]);
                        if(p.dot(p) &lt; res) {
                            d.push_back(p.dot(p));
                        }
                    }
                }

                sort(d.begin(),d.end(),greater&lt;double&gt;());
                d.erase(unique(d.begin(),d.end()),d.end());

                rep(k,d.size()) {
                    int len = d[k];
                    bool flag = false;
                    Point p1(v[0].x-v[1].x, v[0].y-v[1].y);
                    Point p2(v[0].x-v[2].x, v[0].y-v[2].y);
                    Point p3(v[1].x-v[2].x, v[1].y-v[2].y);

                    int r = (int)p1.x*p1.x + p1.y*p1.y;
                    int r2 = (int)p2.x*p2.x + p2.y*p2.y;
                    int r3 = (int)p3.x*p3.x + p3.y*p3.y;

                    if(r &gt;= len) {
                        flag = true;
                    }
                    if(r2 &gt;= len) {
                        flag = true;
                    }
                    if(r3 &gt;= len) {
                        flag = true;
                    }

                    if(flag) {
                        ans = sqrt(d[k])/2.0;
                        break;
                    }
                }
            }else {
                sort(d.begin(),d.end());
                ans = sqrt(d[0])/2.0;
            }
        }

        return ans;
    }
};
</code></pre>

<p>内包判定は外積を見れば良い．何かbetweenはコンパイル通らなくてコメントアウトが原因がよく分からない．とりあえずSystemTestは通ったけど，Pointを使わなくても，更に言えば場合分けをしなくても上手く書けそう． <br/>
今回は3点しかないが，これがn点になっても凸包を作って同じことをすれば良さそうに思える．</p>
]]></content>
  </entry>
  
</feed>
