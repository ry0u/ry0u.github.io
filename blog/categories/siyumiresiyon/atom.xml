<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: シュミレーション | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/siyumiresiyon/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-09-03T02:19:57+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Codeforces354-div2B Pyramid of Glasses]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/26/codeforces354-div2b-pyramid-of-glasses/"/>
    <updated>2016-05-26T09:11:14+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/26/codeforces354-div2b-pyramid-of-glasses</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/676/problem/B">Problem - B - Codeforces</a></h4><p>Mary has just graduated from one well-known University and is now attending celebration party. Students like to dream of a beautiful life, so they used champagne glasses to construct a small pyramid. The height of the pyramid is n.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

グラスがピラミッドのように並んでいる．上から{% m %} n {% em %}段目には{% m %} n {% em %}個のグラスがある．そのグラスがいっぱいになった時は{% m %} 1 {% em %}段下のグラスに均等に注がれる．{% m %} t {% em %}秒後にいっぱいになっているグラスはいくつあるか？  
  

実際にグラフを作って，グラス{% m %} 0 {% em %}から {% m %} 1 {% em %}秒ずつ流していく．グラフは， {% m %} i {% em %}段目の頂点は(自分の番号 {% m %} + i {% em %}), (自分の番号{% m %} + i + 1 {% em %})と繋がるようにした．  

{% img /images/Codeforces/354/b.png %}

流す量を {% m %} 1.0 {% em %}から初めて，いっぱいになっている場合は，その半分を繋がっている頂点に流す．流れる量は必ず {% m %} \frac{1}{2 ^x} {% em %}という形になり， {% m %} n {% em %}は最大で {% m %} 10 {% em %}段なので誤差無く保持出来る(はず)．


# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

vector<int> g[105];
double v[105];

void dfs(int cur, double x) {
	if(v[cur] == 1.0) {
		rep(i, g[cur].size()) {
			dfs(g[cur][i], x / 2.0);
		}
	} else {
		v[cur] += x;
		return;
	}
}

int main() {
	int n, t;
	cin >> n >> t;

	int m = (n * (n+1) ) / 2;

	memset(v, 0, sizeof(v));
	int id = 0, len = 1;
	rep(i, n-1) {
		rep(j, i+1) {
			g[id].push_back(id + len);
			g[id].push_back(id + len+1);
			id++;
		}
		len++;
	}

	rep(i, t) {
		dfs(0, 1.0);
	}

	int cnt = 0;
	rep(i, m) {
		if(v[i] >= 1.0) cnt++;
	}

	cout << cnt << endl;

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1144 Curling 2.0]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj1144-curling-2-dot-0/"/>
    <updated>2016-03-22T22:22:58+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj1144-curling-2-dot-0</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1144">Curling 2.0</a></h4><p>On Planet MM-21, after their Olympic games this year, curling is getting popular. But the rules are somewhat different from ours. The game is played on an ice game board on which a square mesh is marked. They use only a single stone.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

実際に石を滑らせてシュミレーションする．滑らした途中にゴールがあっても大丈夫にようになってなくてWAをたくさん出した．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30

using namespace std;
typedef long long ll;

int w,h,x,y;
int sx,sy,gx,gy;
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1};
int ans = 0;
bool f[25][25];

bool can(int y,int x) {
    if(0 <= y && y < h && 0 <= x && x < w) return true;
    return false;
}

void dfs(int y, int x, int cnt) {
	if(cnt >= 10) return;

	rep(i, 4) {
		int ny = y;
		int nx = x;
		bool flag = false;

		while(can(ny + dy[i], nx + dx[i]) && f[ny + dy[i]][nx + dx[i]]) {
			ny += dy[i];
			nx += dx[i];

			if(ny == gy && nx == gx) {
				flag = true;
				break;
			}
		}

		if(flag) {
			ans = min(ans, cnt + 1);
			return;
		}

		if(ny == y && nx == x) continue;
		if(!can(ny + dy[i], nx + dx[i])) continue;


		f[ny + dy[i]][nx + dx[i]] = true;
		dfs(ny, nx, cnt + 1);
		f[ny + dy[i]][nx + dx[i]] = false;
	}
}

int main() {

    while(cin >> w >> h) {
        if(w == 0 && h == 0) break;

		memset(f, 0, sizeof(f));
		ans = INF;

        rep(i, h) {
            rep(j, w) {
                int x;
                cin >> x;

				if(x == 0)  f[i][j] = true;
                if(x == 2) {
                    sy = i;
                    sx = j;
					f[i][j] = true;
                }
                if(x == 3) {
                    gy = i;
                    gx = j;
					f[i][j] = true;
                }
            }
        }

		dfs(sy, sx, 0);

		if(ans == INF) cout << -1 << endl;
		else cout << ans << endl;
    }
    return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0612 Sandcastle]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj0612-sandcastle/"/>
    <updated>2016-03-18T15:40:40+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj0612-sandcastle</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0612">Sandcastle | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

最初に崩壊するマスをqueueに突っ込む．そのマスが崩壊したことによって崩壊するマスは隣接しているマスのみなので，queueから取ってきた時に隣接するマスのカウンタを{% m %} +1 {% em %}して崩壊するならまたqueueに突っ込む．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int h, w;
int dy[8] = { 1, 1, 1, 0, 0,-1,-1,-1};
int dx[8] = { 1, 0,-1, 1,-1, 1, 0,-1};

bool can(int y, int x) {
	if(0 <= y && y < h && 0 <= x && x < w) return true;
	return false;
}


int cnt[1005][1005];
bool inQ[1005][1005], used[1005][1005];

int main() {
	cin >> h >> w;

	vector<string> s(h);
	rep(i, h) cin >> s[i];

	memset(cnt, 0, sizeof(cnt));
	memset(used, 0, sizeof(used));
	memset(inQ, 0, sizeof(inQ));

	queue<P> que;
	rep(i, h) {
		rep(j, w) {
			if(s[i][j] != '.') {
				rep(k, 8) {
					int y = i + dy[k];
					int x = j + dx[k];
					if(can(y, x) && s[y][x] == '.') {
						cnt[i][j]++;
					}
				}
				if(s[i][j] - '0' <= cnt[i][j]) {
					que.push(mp(i, j));
					used[i][j] = true;
				}
			}
		}
	}


	int ans = 0;
	while(que.size()) {
		queue<P> tmp;
		while(que.size()) {
			P p = que.front();
			que.pop();

			rep(k, 8) {
				int y = p.first + dy[k];
				int x = p.second + dx[k];

				if(can(y, x)) {
					cnt[y][x]++;
					if(s[y][x] != '.' && (s[y][x] - '0') <= cnt[y][x] && !used[y][x]) {
						used[y][x] = true;
						tmp.push(mp(y, x));
					}
				}
			}
		}

		while(tmp.size()) {
			P p = tmp.front();
			tmp.pop();
			que.push(p);
		}

		ans++;
	}

	cout << ans << endl;

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM683 D2M MoveStonesEasy]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/03/srm683-d2m-movestoneseasy/"/>
    <updated>2016-03-03T23:54:40+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/03/srm683-d2m-movestoneseasy</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14182&rd=16653">TopCoder Statistics - Problem Statement</a></h4><p>There are n piles of stones arranged in a line. The piles are numbered 0 through n-1, in order. In other words, for each valid i, piles i and i+1 are adjacent. You are given two int[]s a and b, each with n elements.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

現在の石の山と目的の石の山が渡されるので，左から順番に目的の石の山にしていく．

# Code

```cpp
	public:
	int get(vector <int> a, vector <int> b) {
		int n = a.size();

		ll ans = 0;
		ll asum = 0, bsum = 0;

		rep(i, n) asum += a[i];
		rep(i, n) bsum += b[i];

		if(asum != bsum) return -1;

		rep(i, n) {
			if(a[i] == b[i]) continue;
			if(a[i] > b[i]) {
				a[i+1] += a[i] - b[i];
				ans += a[i] - b[i];
			} else {
				int len = 1, j = i+1;
				while(a[i] < b[i]) {
					int d = b[i] - a[i];
					if(a[j] >= d) {
						a[j] -= d;
						a[i] += d;
						ans += d * len;
					} else {
						a[i] += a[j];
						ans += a[j] * len;
						a[j] = 0;
						j++;
						len++;
					}
				}
			}
		}

		return ans;
	}
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manthan, Codefest 16D Fibonacci-ish]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16d-fibonacci-ish/"/>
    <updated>2016-02-29T15:59:40+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16d-fibonacci-ish</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-chrome="0" data-card-controls="0"><h4><a href="http://codeforces.com/contest/633/problem/D">Problem - D - Codeforces</a></h4><p>Yash has recently learnt about the Fibonacci sequence and is very excited about it. He calls a sequence Fibonacci-ish if You are given some sequence of integers . Your task is rearrange elements of this sequence in such a way that its longest possible prefix is Fibonacci-ish sequence.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

やることは， {% m %} f\_0とf\_1 {% em %}選び，シュミレーションする．本番中はpretest 3でTLEを出して，これじゃあ間に合わないと考えていたが，単純に{% m %} 0 {% em %}を考慮していないためだった．  
最初に {% m %} 0 {% em %}をはじいて，全て{% m %} 0 {% em %}のみのパターンか最初に{% m %} 0 {% em %}をつけるパターンのみでいいと思っていたが，途中で{% m %} 0 {% em %}を経由するパターンも普通にあってそこに気づかなかった．  
またsetに突っ込んでその数があるかを確認していたけど，同じ数が出てくるパターンがあるので最初にどの数が何個あるかをmapで持たなければいけなかった．  
stackに積んでおけば後に続く項の個数が分かるので
{% math %}
	memo[mp(a, b)] := (a, b)の時の後に続く項の個数
{% endmath %}
とかやるのかな思ったけど，(a, b)にいたるまでに使ってきた数が違えば後に続く項も違いダメだった．  

# Code
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <stack>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int n;
	cin >> n;

	vector<ll> v(n);
	map<ll, int> m;
	set<int> st;

	rep(i, n) {
		cin >> v[i];
		m[v[i]]++;
		st.insert(v[i]);
	}

	int ans = m[0];
	rep(i, n) {
		rep(j, n) {
			ll a = v[i], b = v[j], c;

			if(i == j) continue;
			if(a == 0 && b == 0) continue;

			m[a]--;
			m[b]--;

			stack<ll> S;
			S.push(a);
			S.push(b);

			while(st.find(a + b) != st.end() && m[a + b] > 0) {
					c = a + b;
					a = b;
					b = c;

					m[c]--;
					S.push(c);
			}

			ans = max(ans, (int)S.size());

			while(S.size()) {
				m[S.top()]++;
				S.pop();
			}
		}
	}

	cout << ans << endl;

	return 0;
}
```
]]></content>
  </entry>
  
</feed>
