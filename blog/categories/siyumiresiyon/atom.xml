<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: シュミレーション | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/siyumiresiyon/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-04-03T14:42:29+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ1144 Curling 2.0]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj1144-curling-2-dot-0/"/>
    <updated>2016-03-22T22:22:58+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj1144-curling-2-dot-0</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1144">Curling 2.0</a></h4><p>On Planet MM-21, after their Olympic games this year, curling is getting popular. But the rules are somewhat different from ours. The game is played on an ice game board on which a square mesh is marked. They use only a single stone.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>実際に石を滑らせてシュミレーションする．滑らした途中にゴールがあっても大丈夫にようになってなくてWAをたくさん出した．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30

using namespace std;
typedef long long ll;

int w,h,x,y;
int sx,sy,gx,gy;
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1};
int ans = 0;
bool f[25][25];

bool can(int y,int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}

void dfs(int y, int x, int cnt) {
    if(cnt &gt;= 10) return;

    rep(i, 4) {
        int ny = y;
        int nx = x;
        bool flag = false;

        while(can(ny + dy[i], nx + dx[i]) &amp;&amp; f[ny + dy[i]][nx + dx[i]]) {
            ny += dy[i];
            nx += dx[i];

            if(ny == gy &amp;&amp; nx == gx) {
                flag = true;
                break;
            }
        }

        if(flag) {
            ans = min(ans, cnt + 1);
            return;
        }

        if(ny == y &amp;&amp; nx == x) continue;
        if(!can(ny + dy[i], nx + dx[i])) continue;


        f[ny + dy[i]][nx + dx[i]] = true;
        dfs(ny, nx, cnt + 1);
        f[ny + dy[i]][nx + dx[i]] = false;
    }
}

int main() {

    while(cin &gt;&gt; w &gt;&gt; h) {
        if(w == 0 &amp;&amp; h == 0) break;

        memset(f, 0, sizeof(f));
        ans = INF;

        rep(i, h) {
            rep(j, w) {
                int x;
                cin &gt;&gt; x;

                if(x == 0)  f[i][j] = true;
                if(x == 2) {
                    sy = i;
                    sx = j;
                    f[i][j] = true;
                }
                if(x == 3) {
                    gy = i;
                    gx = j;
                    f[i][j] = true;
                }
            }
        }

        dfs(sy, sx, 0);

        if(ans == INF) cout &lt;&lt; -1 &lt;&lt; endl;
        else cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0612 Sandcastle]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj0612-sandcastle/"/>
    <updated>2016-03-18T15:40:40+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj0612-sandcastle</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0612">Sandcastle | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>最初に崩壊するマスをqueueに突っ込む．そのマスが崩壊したことによって崩壊するマスは隣接しているマスのみなので，queueから取ってきた時に隣接するマスのカウンタを<script type="math/tex"> +1 </script>して崩壊するならまたqueueに突っ込む．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int h, w;
int dy[8] = { 1, 1, 1, 0, 0,-1,-1,-1};
int dx[8] = { 1, 0,-1, 1,-1, 1, 0,-1};

bool can(int y, int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}


int cnt[1005][1005];
bool inQ[1005][1005], used[1005][1005];

int main() {
    cin &gt;&gt; h &gt;&gt; w;

    vector&lt;string&gt; s(h);
    rep(i, h) cin &gt;&gt; s[i];

    memset(cnt, 0, sizeof(cnt));
    memset(used, 0, sizeof(used));
    memset(inQ, 0, sizeof(inQ));

    queue&lt;P&gt; que;
    rep(i, h) {
        rep(j, w) {
            if(s[i][j] != '.') {
                rep(k, 8) {
                    int y = i + dy[k];
                    int x = j + dx[k];
                    if(can(y, x) &amp;&amp; s[y][x] == '.') {
                        cnt[i][j]++;
                    }
                }
                if(s[i][j] - '0' &lt;= cnt[i][j]) {
                    que.push(mp(i, j));
                    used[i][j] = true;
                }
            }
        }
    }


    int ans = 0;
    while(que.size()) {
        queue&lt;P&gt; tmp;
        while(que.size()) {
            P p = que.front();
            que.pop();

            rep(k, 8) {
                int y = p.first + dy[k];
                int x = p.second + dx[k];

                if(can(y, x)) {
                    cnt[y][x]++;
                    if(s[y][x] != '.' &amp;&amp; (s[y][x] - '0') &lt;= cnt[y][x] &amp;&amp; !used[y][x]) {
                        used[y][x] = true;
                        tmp.push(mp(y, x));
                    }
                }
            }
        }

        while(tmp.size()) {
            P p = tmp.front();
            tmp.pop();
            que.push(p);
        }

        ans++;
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM683 D2M MoveStonesEasy]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/03/srm683-d2m-movestoneseasy/"/>
    <updated>2016-03-03T23:54:40+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/03/srm683-d2m-movestoneseasy</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14182&rd=16653">TopCoder Statistics - Problem Statement</a></h4><p>There are n piles of stones arranged in a line. The piles are numbered 0 through n-1, in order. In other words, for each valid i, piles i and i+1 are adjacent. You are given two int[]s a and b, each with n elements.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>現在の石の山と目的の石の山が渡されるので，左から順番に目的の石の山にしていく．</p>

<h1>Code</h1>

<pre><code class="cpp">    public:
    int get(vector &lt;int&gt; a, vector &lt;int&gt; b) {
        int n = a.size();

        ll ans = 0;
        ll asum = 0, bsum = 0;

        rep(i, n) asum += a[i];
        rep(i, n) bsum += b[i];

        if(asum != bsum) return -1;

        rep(i, n) {
            if(a[i] == b[i]) continue;
            if(a[i] &gt; b[i]) {
                a[i+1] += a[i] - b[i];
                ans += a[i] - b[i];
            } else {
                int len = 1, j = i+1;
                while(a[i] &lt; b[i]) {
                    int d = b[i] - a[i];
                    if(a[j] &gt;= d) {
                        a[j] -= d;
                        a[i] += d;
                        ans += d * len;
                    } else {
                        a[i] += a[j];
                        ans += a[j] * len;
                        a[j] = 0;
                        j++;
                        len++;
                    }
                }
            }
        }

        return ans;
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manthan, Codefest 16D Fibonacci-ish]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16d-fibonacci-ish/"/>
    <updated>2016-02-29T15:59:40+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16d-fibonacci-ish</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-chrome="0" data-card-controls="0"><h4><a href="http://codeforces.com/contest/633/problem/D">Problem - D - Codeforces</a></h4><p>Yash has recently learnt about the Fibonacci sequence and is very excited about it. He calls a sequence Fibonacci-ish if You are given some sequence of integers . Your task is rearrange elements of this sequence in such a way that its longest possible prefix is Fibonacci-ish sequence.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>やることは， <script type="math/tex"> f_0とf_1 </script>選び，シュミレーションする．本番中はpretest 3でTLEを出して，これじゃあ間に合わないと考えていたが，単純に<script type="math/tex"> 0 </script>を考慮していないためだった．<br/>
最初に <script type="math/tex"> 0 </script>をはじいて，全て<script type="math/tex"> 0 </script>のみのパターンか最初に<script type="math/tex"> 0 </script>をつけるパターンのみでいいと思っていたが，途中で<script type="math/tex"> 0 </script>を経由するパターンも普通にあってそこに気づかなかった．<br/>
またsetに突っ込んでその数があるかを確認していたけど，同じ数が出てくるパターンがあるので最初にどの数が何個あるかをmapで持たなければいけなかった．<br/>
stackに積んでおけば後に続く項の個数が分かるので
<script type="math/tex; mode=display">
    memo[mp(a, b)] := (a, b)の時の後に続く項の個数
</script>
とかやるのかな思ったけど，(a, b)にいたるまでに使ってきた数が違えば後に続く項も違いダメだった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;stack&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;ll&gt; v(n);
    map&lt;ll, int&gt; m;
    set&lt;int&gt; st;

    rep(i, n) {
        cin &gt;&gt; v[i];
        m[v[i]]++;
        st.insert(v[i]);
    }

    int ans = m[0];
    rep(i, n) {
        rep(j, n) {
            ll a = v[i], b = v[j], c;

            if(i == j) continue;
            if(a == 0 &amp;&amp; b == 0) continue;

            m[a]--;
            m[b]--;

            stack&lt;ll&gt; S;
            S.push(a);
            S.push(b);

            while(st.find(a + b) != st.end() &amp;&amp; m[a + b] &gt; 0) {
                    c = a + b;
                    a = b;
                    b = c;

                    m[c]--;
                    S.push(c);
            }

            ans = max(ans, (int)S.size());

            while(S.size()) {
                m[S.top()]++;
                S.pop();
            }
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM682 D2M TopBiologist]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/srm682-d2m-topbiologist/"/>
    <updated>2016-02-29T00:36:01+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/srm682-d2m-topbiologist</id>
    <content type="html"><![CDATA[<p>大文字アルファベットの<script type="math/tex">A, C, G, T</script>で構成される文字列が与えられる．この文字列に含まれない最小の<script type="math/tex">A, C, G, T</script>で構成される文字列を返す．</p>

<!-- more -->


<hr />

<p>与えられる文字列の長さは最大で<script type="math/tex">2000</script>なので長さ<script type="math/tex">6</script>の文字列が最大となる（長さ<script type="math/tex">5</script>の文字列を単純に連結すれば<script type="math/tex">5120</script>になるが上手いこと組み合わせれば<script type="math/tex">2000</script>以下になる）．</p>

<p>愚直に探索し，その文字列が見つからなければ返す．<br/>
部分文字列を全て列挙しmapに突っ込んだらMLEして落とした．</p>

<h1>Code</h1>

<pre><code class="cpp">    public:
    string findShortestNewSequence(string s) {
        m.clear();

        rep(i, s.size()) {
            stringstream ss;
            REP(j, i, s.size()) {
                string t = s.substr(i, j-i+1);
                if(t.size() &gt;= 10) continue;
                m[t] = true;
            }
        }

        que.push("A");
        que.push("C");
        que.push("G");
        que.push("T");

        string ans = "";
        while(que.size()) {
            string t = que.front();
            que.pop();

            if(!m[t]) {
                ans = t;
                break;
            }

            que.push(t + "A");
            que.push(t + "C");
            que.push(t + "G");
            que.push(t + "T");
        }

        // last check
        return ans;
    }
</code></pre>
]]></content>
  </entry>
  
</feed>
