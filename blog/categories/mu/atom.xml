<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 木 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/mu/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-09-03T02:19:57+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Codeforces353-div2D Tree Construction]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/17/codeforces353-div2d-tree-construction/"/>
    <updated>2016-05-17T18:36:48+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/17/codeforces353-div2d-tree-construction</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/675/problem/D">Problem - D - Codeforces</a></h4><p>During the programming classes Vasya was assigned a difficult problem. However, he doesn't know how to code and was unable to find the solution in the Internet, so he asks you to help. You are given a sequence a, consisting of n distinct integers, that is used to construct the binary search tree.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

　{% m %} 2 {% em %}分木の挿入する順番が与えられる．挿入した時の親の番号を答える．  
愚直に木を構成すると線のような木の場合に {% m %} O(n ^2) {% em %}となるので間に合わない．区間をsetで管理すると次に挿入する場所が {% m %} logn {% em %}で持ってこれるので，全体で {% m %} O(n logn) {% em %}となる．map({% m %}l, r {% em %})に区間 {% m %} [l, r] {% em %}の親を持っておくようにした．  

sample2でどのように動くかをメモしておく．(書いておかないと絶対忘れる．．．)

# Sample 2
> {% m %} 5 {% em %}  
> {% m %} 4\ 2\ 3\ 1\ 6\ {% em %}

手順，挿入する数，挿入する区間 {% m %} \to {% em %} 挿入した結果と書いてみた．

{% math %}
\begin{eqnarray}
insert \ \ (4) \ \ [-\infty, \infty] \ \ &\to& \ \ [-\infty, 4], [4, \infty] \\
insert \ \ (2) \ \ [-\infty,\ \ 4] \ \ &\to& \ \ [-\infty, 2], [2, 4], [4, \infty]  \\
insert \ \ (3) \ \ [\,\ \ \ \ 2,\ \ 4] \ \ &\to& \ \ [-\infty, 2], [2, 3], [3, 4], [4, \infty] \\
insert \ \ (1) \ \ [-\infty,\ \ 2] \ \ &\to& \ \ [-\infty, 1], [1, 2], [2, 3], [3, 4], [4, \infty] \\
insert \ \ (6) \ \ [\,\ \ \ \ 4,\infty] \ \ &\to& \ \ [-\infty, 1], [1, 2], [2, 3], [3, 4], [4, 6], [6, \infty] \\
\end{eqnarray}
{% endmath %}

後は区間{% m %} [l, r] {% em %}のmapに入っている値を答えて， {% m %} [l, v[i]], [v[i], r] {% em %}に {% m %} v[i] {% em %}を入れておく．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

map<P, int> m;

int main() {
	int n;
	cin >> n;

	vector<int> v(n);
	rep(i, n) cin >> v[i];

	vector<int> ans;

	set<int> st;
	st.insert(INF);
	st.insert(-INF);
	st.insert(v[0]);

	m[mp(-INF, v[0])] = v[0];
	m[mp(v[0], INF)] = v[0];

	REP(i, 1, n) {
		set<int>::iterator ite = st.upper_bound(v[i]);
		int r = *ite;
		ite--;
		int l = *ite;

		ans.push_back(m[mp(l, r)]);

		m[mp(l, v[i])] = v[i];
		m[mp(v[i], r)] = v[i];
		st.insert(v[i]);
	}

	rep(i, ans.size()) {
		cout << ans[i];

		if(i == ans.size()-1) cout << endl;
		else cout << " ";
	}


	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAG Contest 2016 Domestic C みさわさんの根付き木]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/27/jag-contest-2016-domestic-c-misawasanfalsegen-fu-kimu/"/>
    <updated>2016-04-27T23:21:58+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/27/jag-contest-2016-domestic-c-misawasanfalsegen-fu-kimu</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://jag2016-domestic.contest.atcoder.jp/tasks/jag2016secretspring_c">C: みさわさんの根付き木 - JAG Contest 2016 Domestic | AtCoder</a></h4><p>(null)</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

最初に，完全2分木にして配列を用いて表せば実装簡単だと思い，書き始めたが深さが大きい時に対応出来ないことに気づき，配列ではなくmapにした．一応書き終わり，サンプルを試している内にそもそもこの方法ではノード番号がlong longで収まり切らないことに気づいた．  
次に純粋に文字列を木に直して，rootからmergeしていく方法にしてACが取れた．正しい方針が立てれずに時間を無駄にしてしまったので反省したい．


# Code

```cpp
#include <iostream>
#include <sstream>
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
#include <map>

#define REP(i, k, n) for(int i = k; i < n; i++) 
#define rep(i, n) for(int i = 0; i < n; i++) 

using namespace std;

struct Tree {
	int v;
	Tree* left;
	Tree* right;

	Tree(int v) : v(v) {}
};

void f(string s, Tree* node) {
	string t = "";
	REP(i, 1, s.size()-1) {
		t += s[i];
	}

	if(t == "") return;
	s = t;

	int root = 0, sum = 0;
	string left = "";

	int i = 0;
	for(i = 0; i < s.size(); i++) {
		left += s[i];

		if(s[i] == '(') sum++;
		else if(s[i] == ')') sum--;

		if(sum == 0){
			stringstream ss;
			i += 2;
			REP(j, i, s.size()) {
				if(s[j] == ']') {
					i++;
					break;
				} else {
					ss << s[j];
					i++;
				}
			}
			ss >> root;
			node->v = root;
			break;
		}
	}

	string right = "";
	for(; i < s.size(); i++) {
		right += s[i];
	}

	node->left = new Tree(-1);
	f(left, node->left);

	node->right = new Tree(-1);
	f(right, node->right);
}

void merge(Tree* res, Tree* node, Tree* node2) {
	res->v = node->v + node2->v;
	// cout << "-------- merge:" << res->v << " " << node->v << " " << node2->v << endl;

	res->left = new Tree(-1);
	if(node->left != NULL && node->left->v != -1 && node2->left != NULL && node2->left->v != -1) {
		merge(res->left, node->left, node2->left);
	}

	res->right = new Tree(-1);
	if(node->right != NULL && node->right->v != -1 && node2->right != NULL && node2->right->v != -1) {
		merge(res->right, node->right, node2->right);
	}
}

string dfs(Tree* res) {
	if(res->v == -1) {
		return "()";
	}

	stringstream ss;
	ss << res->v;
	return "(" + dfs(res->left) + "[" + ss.str() + "]" + dfs(res->right) + ")";
}

int main() {
	string s, t;
	cin >> s >> t;

	s = "(" + s + ")";
	t = "(" + t + ")";

	Tree *root = new Tree(-1);
	f(s, root);
	
	Tree *root2 = new Tree(-1);
	f(t, root2);
	
	Tree *res = new Tree(-1);
	merge(res, root, root2);
	
	string ret = dfs(res);

	// 最後の()を取る.
	REP(i, 1, ret.size()-1) {
		cout << ret[i];
	}
	cout << endl;


	return 0;
}

```


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC014D 閉路]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/03/abc014d-bi-lu/"/>
    <updated>2016-04-03T18:09:24+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/03/abc014d-bi-lu</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://abc014.contest.atcoder.jp/tasks/abc014_4">D: 閉路 - AtCoder Beginner Contest 014 | AtCoder</a></h4><p>(null)</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

木に {% m %} 1 {% em %}本付け加えて出来る閉路は，つなげる {% m %} 2 {% em %}点とその {% m %} 2 {% em %}点の最小共通祖先で出来る三角形になるはずである．よって， {% m %} LCA(a, b) {% em %}を求めた後に，その三角形の長さを出力した．長さは {% m %} LCA {% em %}を求める際に深さが出ているので，そこから出せる．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

vector<int> G[100005];
int root;

int parent[20][100005];
int depth[100005];

void dfs(int v, int p, int d) {
	parent[0][v] = p;
	depth[v] = d;
	rep(i, G[v].size()) {
		if(G[v][i] != p) dfs(G[v][i], v, d+1);
	}
}

void init(int V) {
	dfs(root, -1, 0);
	for(int k = 0; k + 1 < 20; k++) {
		rep(v, V) {
			if(parent[k][v] < 0) parent[k + 1][v] = -1;
			else parent[k + 1][v]= parent[k][parent[k][v]];
		}
	}
}

int lca(int u, int v) {
	if(depth[u] > depth[v]) swap(u, v);
	rep(k, 20) {
		if((depth[v] - depth[u]) >> k & 1) {
			v = parent[k][v];
		}
	}
	if(u == v) return u;
	for(int k = 20 - 1; k >= 0; k--) {
		if(parent[k][u] != parent[k][v]) {
			u = parent[k][u];
			v = parent[k][v];
		}
	}
	return parent[0][u];
}

int main() {
	int n;
	cin >> n;

	rep(i, n-1) {
		int x, y;
		cin >> x >> y;

		x--; y--;
		G[x].push_back(y);
		G[y].push_back(x);
	}

	root = 0;
	init(n);

	int Q;
	cin >> Q;

	rep(q, Q) {
		int a, b;
		cin >> a >> b;

		a--; b--;

		int par = lca(a, b);

		cout << (depth[a] - depth[par]) + (depth[b] - depth[par]) + 1 << endl;
	}

	return 0;
}
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1251 Pathological Paths]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/26/aoj1251-pathological-paths/"/>
    <updated>2016-03-26T22:12:52+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/26/aoj1251-pathological-paths</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1251">Pathological Paths</a></h4><p>Professor Pathfinder is a distinguished authority on the structure of hyperlinks in the World Wide Web. For establishing his hypotheses, he has been developing software agents, which automatically traverse hyperlinks and analyze the structure of the Web. Today, he has gotten an intriguing idea to improve his software agents.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

木構造でディレクトリ構造を表す．探すパスが両方葉の場合，ノードの番号が一致するかを見る．葉ではなくディレクトリの場合は，自分の子に文字列が"index.html"であり葉であるノードがあるかを見る．ない場合は"not found"で，ある場合はそのノード番号を比較する．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int cnt = 0;

struct Tree {
	string s;
	int id;
	Tree* par;
	vector<Tree*> v;

	Tree(Tree* par, string s, int id) : par(par), s(s), id(id) {}

	void add(int i, vector<string> res) {
		if(i == res.size()) return;

		bool flag = true;
		rep(j, v.size()) {
			if(v[j]->s == res[i]) flag = false;
		}

		if(flag) {
			cnt++;
			Tree *node = new Tree(this, res[i], cnt);
			v.push_back(node);
		}

		rep(j, v.size()) {
			if(v[j]->s == res[i]) {
				v[j]->add(i+1, res);
			}
		}
	}

	Tree* find(int i, vector<string> res) {
		// cout << " -- in find :" << s << endl;
		if(i == res.size()) {
			return this;
		}

		if(res[i] == ".") {
			if(v.size() == 0) return NULL;
			return find(i+1, res);
		} else if(res[i] == "..") {
			if(v.size() == 0) return NULL;
			if(par == NULL) return NULL;
			return par->find(i+1, res);
		} else if(res[i] == "") {
			if(v.size() == 0) return NULL;
			return find(i+1, res);
		} else {
			rep(j, v.size()) {
				if(v[j]->s == res[i]) {
					return v[j]->find(i+1, res);
				}
			}
			return NULL;
		}
	}

};

vector<string> split(const string &str, char delim) {
	vector<string> res;
	size_t current = 0, found;
	while((found = str.find_first_of(delim, current)) != string::npos) {
		res.push_back(string(str, current, found - current));
		current = found + 1;
	}
	res.push_back(string(str, current, str.size() - current));
	return res;
}

int main() {
	int n, m;
	while(cin >> n >> m) {
		if(n == 0 && m == 0) break;

		cnt = 0;
		Tree *root = new Tree(NULL, "root", cnt);

		rep(i, n) {
			string s;
			cin >> s;

			vector<string> ret = split(s, '/');

			root->add(0, vector<string>(ret.begin()+1, ret.end()));
		}

		rep(q, m) {
			string s, t;
			cin >> s >> t;

			vector<string> r = split(s, '/');
			vector<string> r2 = split(t, '/');

			Tree *node = root->find(0, r);
			Tree *node2 = root->find(0, r2);

			// if(node == NULL) cout << " node 1 : null" << endl;
			// if(node2 == NULL) cout << " node 2 : null" << endl;
		
			if(node == NULL || node2 == NULL) {
				cout << "not found" << endl;
			} else {

				Tree *res = NULL;
				if(node->v.size() == 0) {
					res = node;
				} else {
					rep(i, node->v.size()) {
						if(node->v[i]->v.size() == 0 && node->v[i]->s == "index.html") {
							res = node->v[i];
						}
					}
				}

				Tree *res2 = NULL;
				if(node2->v.size() == 0) {
					res2 = node2;
				} else {
					rep(i, node2->v.size()) {
						if(node2->v[i]->v.size() == 0 && node2->v[i]->s == "index.html") {
							res2 = node2->v[i];
						}
					}
				}

				// if(res == NULL) cout << "NULL";
				// else cout << res->s << ", " << res->id;
				//
				// cout << " ";
				//
				// if(res2 == NULL) cout << "NULL";
				// else cout << res2->s << ", " << res2->id;
				//
				// cout << endl;

				if(res == NULL || res2 == NULL) {
					cout << "not found" << endl;
				} else if(res->id == res2->id && res->s == res2->s) {
					cout << "yes" << endl;
				} else {
					cout << "no" << endl;
				}
			}
		}
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM683 D2H SubtreesCounting]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/04/srm683-d2h-subtreescounting/"/>
    <updated>2016-03-04T16:38:35+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/04/srm683-d2h-subtreescounting</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14179&rd=16653">TopCoder Statistics - Problem Statement</a></h4><p>You are given an undirected tree T. (The input format is specified below.) The vertices of the tree are numbered 0 through n-1. A subtree of T is any subgraph of T that is connected. The size of a subtree is the number of vertices it contains.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

### Sample1

Sample1で構成される木は
{% img /images/SRM/683d2h-0.png %}
である．この木の全ての部分木の頂点数は

頂点数 {% m %} 1 \to {% em %}
{% img /images/SRM/683d2h-1.png %}
{% img /images/SRM/683d2h-2.png %}
{% img /images/SRM/683d2h-3.png %}
  
頂点数 {% m %} 2 \to {% em %}
{% img /images/SRM/683d2h-4.png %}
{% img /images/SRM/683d2h-5.png %}
  
頂点数 {% m %} 3 \to {% em %}
{% img /images/SRM/683d2h-6.png %}
  
よって{% m %} 1 + 1 + 1 + 2 + 2 + 3 = 10 {% em %}である．  

---

頂点{% m %} i {% em %}を根とする木に頂点{% m %} j {% em %}を根とする木を付け加える場合を考える．  
{% img /images/SRM/683d2h-7.png %}
を
{% img /images/SRM/683d2h-8.png %}
としたい．  
この時，
{% math %}
\begin{eqnarray}
	dp[i] &:=& iを根とする全ての部分木の頂点数の和 \\
	num[i] &:=& iを根とする部分木の個数
\end{eqnarray}
{% endmath %}
とすると，頂点数{% m %}dp[i]はdp[j] * num[i] + dp[i] * num[j] {% em %}だけ増加する．

* {% m %} dp[j] * num[i] {% em %}  
	{% img /images/SRM/683d2h-9.png %}
	{% img /images/SRM/683d2h-10.png %}
	{% img /images/SRM/683d2h-11.png %}
	{% img /images/SRM/683d2h-12.png %}
* {% m %} dp[i] * num[j] {% em %}  
	{% img /images/SRM/683d2h-12.png %}
	{% img /images/SRM/683d2h-13.png %}
	{% img /images/SRM/683d2h-14.png %}
	{% img /images/SRM/683d2h-15.png %}
	{% img /images/SRM/683d2h-16.png %}
	{% img /images/SRM/683d2h-17.png %}
	{% img /images/SRM/683d2h-18.png %}
	{% img /images/SRM/683d2h-19.png %}
	{% img /images/SRM/683d2h-20.png %}


同様に部分木の個数{% m %} num[i]はnum[i] * num[j] {% em %}だけ増加する．適当に根を決め，潜って元の頂点に戻る時に足していく．自分の全ての子を潜り終わったらそれ以上変更があることはないので数える．

# Code

```cpp
struct edge {
	int from,to;
	int cost;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int f,int t,int c) : from(f),to(t),cost(c) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

vector<edge> G[100005];
ll dp[100005], num[100005], cnt[100005];
bool used[100005];

void dfs(int cur) {
	used[cur] = true;
	dp[cur] = 1;
	num[cur] = 1;
	
	rep(i, G[cur].size()) {
		int to = G[cur][i].to;
	
		if(!used[to]) {
			dfs(to);

			dp[cur] += (dp[cur] * num[to]) + (dp[to] * num[cur]);
			num[cur] += num[cur] * num[to];
	
			dp[cur] %= MOD;
			num[cur] %= MOD;
		}
	}
	
	cnt[cur] = dp[cur];
}

class SubtreesCounting {
	public:
	int sumOfSizes(int n, int a0, int b, int c, int m) {

		rep(i, 100005) G[i].clear();

		vector<ll> v(n);
		v[0] = a0;

		REP(i, 1, n-1) {
			v[i] = (b * v[i-1]) % m + c;
			v[i] %= m;
		}

		REP(i, 1, n) {
			int j = v[i-1] % i;
			G[i].push_back(edge(j, 1));
			G[j].push_back(edge(i, 1));
		}

		memset(dp, 0, sizeof(dp));
		memset(num, 0, sizeof(num));
		memset(cnt, 0, sizeof(cnt));
		memset(used, 0, sizeof(used));

		dfs(0);

		ll ans = 0;
		rep(i, n) {
			ans += cnt[i];
			ans %= MOD;
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
</feed>
