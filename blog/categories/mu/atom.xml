<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 木 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/mu/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-05-13T16:11:21+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JAG Contest 2016 Domestic C みさわさんの根付き木]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/27/jag-contest-2016-domestic-c-misawasanfalsegen-fu-kimu/"/>
    <updated>2016-04-27T23:21:58+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/27/jag-contest-2016-domestic-c-misawasanfalsegen-fu-kimu</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://jag2016-domestic.contest.atcoder.jp/tasks/jag2016secretspring_c">C: みさわさんの根付き木 - JAG Contest 2016 Domestic | AtCoder</a></h4><p>(null)</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>最初に，完全2分木にして配列を用いて表せば実装簡単だと思い，書き始めたが深さが大きい時に対応出来ないことに気づき，配列ではなくmapにした．一応書き終わり，サンプルを試している内にそもそもこの方法ではノード番号がlong longで収まり切らないことに気づいた．<br/>
次に純粋に文字列を木に直して，rootからmergeしていく方法にしてACが取れた．正しい方針が立てれずに時間を無駄にしてしまったので反省したい．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;

#define REP(i, k, n) for(int i = k; i &lt; n; i++) 
#define rep(i, n) for(int i = 0; i &lt; n; i++) 

using namespace std;

struct Tree {
    int v;
    Tree* left;
    Tree* right;

    Tree(int v) : v(v) {}
};

void f(string s, Tree* node) {
    string t = "";
    REP(i, 1, s.size()-1) {
        t += s[i];
    }

    if(t == "") return;
    s = t;

    int root = 0, sum = 0;
    string left = "";

    int i = 0;
    for(i = 0; i &lt; s.size(); i++) {
        left += s[i];

        if(s[i] == '(') sum++;
        else if(s[i] == ')') sum--;

        if(sum == 0){
            stringstream ss;
            i += 2;
            REP(j, i, s.size()) {
                if(s[j] == ']') {
                    i++;
                    break;
                } else {
                    ss &lt;&lt; s[j];
                    i++;
                }
            }
            ss &gt;&gt; root;
            node-&gt;v = root;
            break;
        }
    }

    string right = "";
    for(; i &lt; s.size(); i++) {
        right += s[i];
    }

    node-&gt;left = new Tree(-1);
    f(left, node-&gt;left);

    node-&gt;right = new Tree(-1);
    f(right, node-&gt;right);
}

void merge(Tree* res, Tree* node, Tree* node2) {
    res-&gt;v = node-&gt;v + node2-&gt;v;
    // cout &lt;&lt; "-------- merge:" &lt;&lt; res-&gt;v &lt;&lt; " " &lt;&lt; node-&gt;v &lt;&lt; " " &lt;&lt; node2-&gt;v &lt;&lt; endl;

    res-&gt;left = new Tree(-1);
    if(node-&gt;left != NULL &amp;&amp; node-&gt;left-&gt;v != -1 &amp;&amp; node2-&gt;left != NULL &amp;&amp; node2-&gt;left-&gt;v != -1) {
        merge(res-&gt;left, node-&gt;left, node2-&gt;left);
    }

    res-&gt;right = new Tree(-1);
    if(node-&gt;right != NULL &amp;&amp; node-&gt;right-&gt;v != -1 &amp;&amp; node2-&gt;right != NULL &amp;&amp; node2-&gt;right-&gt;v != -1) {
        merge(res-&gt;right, node-&gt;right, node2-&gt;right);
    }
}

string dfs(Tree* res) {
    if(res-&gt;v == -1) {
        return "()";
    }

    stringstream ss;
    ss &lt;&lt; res-&gt;v;
    return "(" + dfs(res-&gt;left) + "[" + ss.str() + "]" + dfs(res-&gt;right) + ")";
}

int main() {
    string s, t;
    cin &gt;&gt; s &gt;&gt; t;

    s = "(" + s + ")";
    t = "(" + t + ")";

    Tree *root = new Tree(-1);
    f(s, root);

    Tree *root2 = new Tree(-1);
    f(t, root2);

    Tree *res = new Tree(-1);
    merge(res, root, root2);

    string ret = dfs(res);

    // 最後の()を取る.
    REP(i, 1, ret.size()-1) {
        cout &lt;&lt; ret[i];
    }
    cout &lt;&lt; endl;


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC014D 閉路]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/03/abc014d-bi-lu/"/>
    <updated>2016-04-03T18:09:24+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/03/abc014d-bi-lu</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://abc014.contest.atcoder.jp/tasks/abc014_4">D: 閉路 - AtCoder Beginner Contest 014 | AtCoder</a></h4><p>(null)</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>木に <script type="math/tex"> 1 </script>本付け加えて出来る閉路は，つなげる <script type="math/tex"> 2 </script>点とその <script type="math/tex"> 2 </script>点の最小共通祖先で出来る三角形になるはずである．よって， <script type="math/tex"> LCA(a, b) </script>を求めた後に，その三角形の長さを出力した．長さは <script type="math/tex"> LCA </script>を求める際に深さが出ているので，そこから出せる．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

vector&lt;int&gt; G[100005];
int root;

int parent[20][100005];
int depth[100005];

void dfs(int v, int p, int d) {
    parent[0][v] = p;
    depth[v] = d;
    rep(i, G[v].size()) {
        if(G[v][i] != p) dfs(G[v][i], v, d+1);
    }
}

void init(int V) {
    dfs(root, -1, 0);
    for(int k = 0; k + 1 &lt; 20; k++) {
        rep(v, V) {
            if(parent[k][v] &lt; 0) parent[k + 1][v] = -1;
            else parent[k + 1][v]= parent[k][parent[k][v]];
        }
    }
}

int lca(int u, int v) {
    if(depth[u] &gt; depth[v]) swap(u, v);
    rep(k, 20) {
        if((depth[v] - depth[u]) &gt;&gt; k &amp; 1) {
            v = parent[k][v];
        }
    }
    if(u == v) return u;
    for(int k = 20 - 1; k &gt;= 0; k--) {
        if(parent[k][u] != parent[k][v]) {
            u = parent[k][u];
            v = parent[k][v];
        }
    }
    return parent[0][u];
}

int main() {
    int n;
    cin &gt;&gt; n;

    rep(i, n-1) {
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;

        x--; y--;
        G[x].push_back(y);
        G[y].push_back(x);
    }

    root = 0;
    init(n);

    int Q;
    cin &gt;&gt; Q;

    rep(q, Q) {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;

        a--; b--;

        int par = lca(a, b);

        cout &lt;&lt; (depth[a] - depth[par]) + (depth[b] - depth[par]) + 1 &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1251 Pathological Paths]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/26/aoj1251-pathological-paths/"/>
    <updated>2016-03-26T22:12:52+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/26/aoj1251-pathological-paths</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1251">Pathological Paths</a></h4><p>Professor Pathfinder is a distinguished authority on the structure of hyperlinks in the World Wide Web. For establishing his hypotheses, he has been developing software agents, which automatically traverse hyperlinks and analyze the structure of the Web. Today, he has gotten an intriguing idea to improve his software agents.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>木構造でディレクトリ構造を表す．探すパスが両方葉の場合，ノードの番号が一致するかを見る．葉ではなくディレクトリの場合は，自分の子に文字列が"index.html"であり葉であるノードがあるかを見る．ない場合は"not found"で，ある場合はそのノード番号を比較する．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int cnt = 0;

struct Tree {
    string s;
    int id;
    Tree* par;
    vector&lt;Tree*&gt; v;

    Tree(Tree* par, string s, int id) : par(par), s(s), id(id) {}

    void add(int i, vector&lt;string&gt; res) {
        if(i == res.size()) return;

        bool flag = true;
        rep(j, v.size()) {
            if(v[j]-&gt;s == res[i]) flag = false;
        }

        if(flag) {
            cnt++;
            Tree *node = new Tree(this, res[i], cnt);
            v.push_back(node);
        }

        rep(j, v.size()) {
            if(v[j]-&gt;s == res[i]) {
                v[j]-&gt;add(i+1, res);
            }
        }
    }

    Tree* find(int i, vector&lt;string&gt; res) {
        // cout &lt;&lt; " -- in find :" &lt;&lt; s &lt;&lt; endl;
        if(i == res.size()) {
            return this;
        }

        if(res[i] == ".") {
            if(v.size() == 0) return NULL;
            return find(i+1, res);
        } else if(res[i] == "..") {
            if(v.size() == 0) return NULL;
            if(par == NULL) return NULL;
            return par-&gt;find(i+1, res);
        } else if(res[i] == "") {
            if(v.size() == 0) return NULL;
            return find(i+1, res);
        } else {
            rep(j, v.size()) {
                if(v[j]-&gt;s == res[i]) {
                    return v[j]-&gt;find(i+1, res);
                }
            }
            return NULL;
        }
    }

};

vector&lt;string&gt; split(const string &amp;str, char delim) {
    vector&lt;string&gt; res;
    size_t current = 0, found;
    while((found = str.find_first_of(delim, current)) != string::npos) {
        res.push_back(string(str, current, found - current));
        current = found + 1;
    }
    res.push_back(string(str, current, str.size() - current));
    return res;
}

int main() {
    int n, m;
    while(cin &gt;&gt; n &gt;&gt; m) {
        if(n == 0 &amp;&amp; m == 0) break;

        cnt = 0;
        Tree *root = new Tree(NULL, "root", cnt);

        rep(i, n) {
            string s;
            cin &gt;&gt; s;

            vector&lt;string&gt; ret = split(s, '/');

            root-&gt;add(0, vector&lt;string&gt;(ret.begin()+1, ret.end()));
        }

        rep(q, m) {
            string s, t;
            cin &gt;&gt; s &gt;&gt; t;

            vector&lt;string&gt; r = split(s, '/');
            vector&lt;string&gt; r2 = split(t, '/');

            Tree *node = root-&gt;find(0, r);
            Tree *node2 = root-&gt;find(0, r2);

            // if(node == NULL) cout &lt;&lt; " node 1 : null" &lt;&lt; endl;
            // if(node2 == NULL) cout &lt;&lt; " node 2 : null" &lt;&lt; endl;

            if(node == NULL || node2 == NULL) {
                cout &lt;&lt; "not found" &lt;&lt; endl;
            } else {

                Tree *res = NULL;
                if(node-&gt;v.size() == 0) {
                    res = node;
                } else {
                    rep(i, node-&gt;v.size()) {
                        if(node-&gt;v[i]-&gt;v.size() == 0 &amp;&amp; node-&gt;v[i]-&gt;s == "index.html") {
                            res = node-&gt;v[i];
                        }
                    }
                }

                Tree *res2 = NULL;
                if(node2-&gt;v.size() == 0) {
                    res2 = node2;
                } else {
                    rep(i, node2-&gt;v.size()) {
                        if(node2-&gt;v[i]-&gt;v.size() == 0 &amp;&amp; node2-&gt;v[i]-&gt;s == "index.html") {
                            res2 = node2-&gt;v[i];
                        }
                    }
                }

                // if(res == NULL) cout &lt;&lt; "NULL";
                // else cout &lt;&lt; res-&gt;s &lt;&lt; ", " &lt;&lt; res-&gt;id;
                //
                // cout &lt;&lt; " ";
                //
                // if(res2 == NULL) cout &lt;&lt; "NULL";
                // else cout &lt;&lt; res2-&gt;s &lt;&lt; ", " &lt;&lt; res2-&gt;id;
                //
                // cout &lt;&lt; endl;

                if(res == NULL || res2 == NULL) {
                    cout &lt;&lt; "not found" &lt;&lt; endl;
                } else if(res-&gt;id == res2-&gt;id &amp;&amp; res-&gt;s == res2-&gt;s) {
                    cout &lt;&lt; "yes" &lt;&lt; endl;
                } else {
                    cout &lt;&lt; "no" &lt;&lt; endl;
                }
            }
        }
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM683 D2H SubtreesCounting]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/04/srm683-d2h-subtreescounting/"/>
    <updated>2016-03-04T16:38:35+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/04/srm683-d2h-subtreescounting</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14179&rd=16653">TopCoder Statistics - Problem Statement</a></h4><p>You are given an undirected tree T. (The input format is specified below.) The vertices of the tree are numbered 0 through n-1. A subtree of T is any subgraph of T that is connected. The size of a subtree is the number of vertices it contains.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<h3>Sample1</h3>

<p>Sample1で構成される木は
<img src="/images/SRM/683d2h-0.png">
である．この木の全ての部分木の頂点数は</p>

<p>頂点数 <script type="math/tex"> 1 \to </script>
<img src="/images/SRM/683d2h-1.png">
<img src="/images/SRM/683d2h-2.png">
<img src="/images/SRM/683d2h-3.png"></p>

<p>頂点数 <script type="math/tex"> 2 \to </script>
<img src="/images/SRM/683d2h-4.png">
<img src="/images/SRM/683d2h-5.png"></p>

<p>頂点数 <script type="math/tex"> 3 \to </script>
<img src="/images/SRM/683d2h-6.png"></p>

<p>よって<script type="math/tex"> 1 + 1 + 1 + 2 + 2 + 3 = 10 </script>である．</p>

<hr />

<p>頂点<script type="math/tex"> i </script>を根とする木に頂点<script type="math/tex"> j </script>を根とする木を付け加える場合を考える．<br/>
<img src="/images/SRM/683d2h-7.png">
を
<img src="/images/SRM/683d2h-8.png">
としたい．<br/>
この時，
<script type="math/tex; mode=display">
\begin{eqnarray}
    dp[i] &amp;:=&amp; iを根とする全ての部分木の頂点数の和 \
    num[i] &amp;:=&amp; iを根とする部分木の個数
\end{eqnarray}
</script>
とすると，頂点数<script type="math/tex">dp[i]はdp[j] * num[i] + dp[i] * num[j] </script>だけ増加する．</p>

<ul>
<li><script type="math/tex"> dp[j] * num[i] </script><br/>
  <img src="/images/SRM/683d2h-9.png">
  <img src="/images/SRM/683d2h-10.png">
  <img src="/images/SRM/683d2h-11.png">
  <img src="/images/SRM/683d2h-12.png"></li>
<li><script type="math/tex"> dp[i] * num[j] </script><br/>
  <img src="/images/SRM/683d2h-12.png">
  <img src="/images/SRM/683d2h-13.png">
  <img src="/images/SRM/683d2h-14.png">
  <img src="/images/SRM/683d2h-15.png">
  <img src="/images/SRM/683d2h-16.png">
  <img src="/images/SRM/683d2h-17.png">
  <img src="/images/SRM/683d2h-18.png">
  <img src="/images/SRM/683d2h-19.png">
  <img src="/images/SRM/683d2h-20.png"></li>
</ul>


<p>同様に部分木の個数<script type="math/tex"> num[i]はnum[i] * num[j] </script>だけ増加する．適当に根を決め，潜って元の頂点に戻る時に足していく．自分の全ての子を潜り終わったらそれ以上変更があることはないので数える．</p>

<h1>Code</h1>

<pre><code class="cpp">struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[100005];
ll dp[100005], num[100005], cnt[100005];
bool used[100005];

void dfs(int cur) {
    used[cur] = true;
    dp[cur] = 1;
    num[cur] = 1;

    rep(i, G[cur].size()) {
        int to = G[cur][i].to;

        if(!used[to]) {
            dfs(to);

            dp[cur] += (dp[cur] * num[to]) + (dp[to] * num[cur]);
            num[cur] += num[cur] * num[to];

            dp[cur] %= MOD;
            num[cur] %= MOD;
        }
    }

    cnt[cur] = dp[cur];
}

class SubtreesCounting {
    public:
    int sumOfSizes(int n, int a0, int b, int c, int m) {

        rep(i, 100005) G[i].clear();

        vector&lt;ll&gt; v(n);
        v[0] = a0;

        REP(i, 1, n-1) {
            v[i] = (b * v[i-1]) % m + c;
            v[i] %= m;
        }

        REP(i, 1, n) {
            int j = v[i-1] % i;
            G[i].push_back(edge(j, 1));
            G[j].push_back(edge(i, 1));
        }

        memset(dp, 0, sizeof(dp));
        memset(num, 0, sizeof(num));
        memset(cnt, 0, sizeof(cnt));
        memset(used, 0, sizeof(used));

        dfs(0);

        ll ans = 0;
        rep(i, n) {
            ans += cnt[i];
            ans %= MOD;
        }

        return ans;
    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
