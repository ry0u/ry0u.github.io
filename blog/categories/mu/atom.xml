<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 木 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/mu/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-12-01T23:52:11+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM328 D1M BlockEnemy]]></title>
    <link href="http://ry0u.github.io/blog/2016/11/19/srm328-d1m-blockenemy/"/>
    <updated>2016-11-19T00:36:04+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/11/19/srm328-d1m-blockenemy</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6852&rd=10008">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

グラフが与えられる．$occupiedTowns[i]$同士が繋がっていないようにするために，辺を切る最小コストを求める．

---

まずは最小全域木を作る．すると木になったので$root$を$0$に決めて，dfsする．

$$
	dfs(cur, pre) := cur以下の部分木をoccupiedTowns同士が繋がらないようにした時の最小コスト\\\
	dp[i] := i以下の部分木を分離するための最小コスト
$$

葉まで行った時は，$occupiedTowns$の時は$dp[i]$をその辺のコストにして，そうでない場合は切る必要がないので$0$にして$0$を返す．ここから場合分け．今見ている頂点が$occupiedTowns$ではないときを考える．

{% img /images/SRM/328_1.png %}

今訪れている頂点が$1$で，赤の枠で囲まれている場所が$occupiedTowns$，辺のコストはそれぞれ$l$である．この時，このまま頂点$2$に伸びる辺と頂点$4$に伸びる頂点をつないでしまうと，$2$から$4$へ行けてしまうので何とかしなければならない．頂点$2$へ行く方法を切ってしまうと考えた場合，そこへ伸びる辺を切る方法と，頂点$2$以下の部分木を分離してしまう方法がある．下の図でいうと$l1$と$dp[2]$である．これらの$min$が頂点$2$へ行く方法を切る時の最小コストである．

{% img /images/SRM/328_2.png %}

同様に頂点$4$についても$min(l3, dp[4])$である．小さい順につながってしまうとダメな場所$-1$個の場所に行けないようにする．最後の残っている所を親に引き継ぐ(親を赤の枠にする)．今見ている頂点が$occupiedTowns$の時は，子の赤い枠の場所は全て切らねばならないので，その辺を切るか$dp$を切るかの小さい方の合計を持ち上げる．$dfs(0, -1)$の戻り値がそのまま答えとなる．


```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

vector<string> split(const string &str, char delim) {
	vector<string> res;
	size_t current = 0, found;
	while((found = str.find_first_of(delim, current)) != string::npos) {
		res.push_back(string(str, current, found - current));
		current = found + 1;
	}
	res.push_back(string(str, current, str.size() - current));
	return res;
}

int f(string s) {
	int ret;
	stringstream ss(s);
	ss >> ret;
	return ret;
}

struct UnionFind {
	vector<int> par, rank;
	int N;

	UnionFind(int n) {
		N = n;
		par.resize(n);
		rank.resize(n);

		rep(i, n) {
			par[i] = i;
			rank[i] = 0;
		}
	}

	int find(int x) {
		if(par[x] == x) return x;
		else return par[x] = find(par[x]);
	}

	void unite(int x, int y) {
		x = find(x);
		y = find(y);

		if(x == y) return;

		if(rank[x] < rank[y]) {
			par[x] = y;
		} else {
			par[y] = x;
			if(rank[x] == rank[y]) rank[x]++;
		}
	}

	bool same(int x, int y) {
		return find(x) == find(y);
	}

	int size() {
		int cnt = 0;
		rep(i, N) if(find(i) == i) cnt++;
		return cnt;
	}
};

struct edge {
	int from,to;
	int cost;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int f,int t,int c) : from(f),to(t),cost(c) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

vector<edge> G[55];
int dist[55][55];

int kruskal(int n, vector<edge> v) {
	sort(v.begin(),v.end());

	UnionFind uf(n);
	rep(i, 55) G[i].clear();
	rep(i, 55) rep(j, 55) dist[i][j] = INF;

	int ret = 0;
	rep(i, v.size()) {
		edge e = v[i];
		if(!uf.same(e.from,e.to)) {
			uf.unite(e.from,e.to);
			ret += e.cost;

			G[e.from].push_back(edge(e.to, e.cost));
			G[e.to].push_back(edge(e.from, e.cost));

			dist[e.from][e.to] = e.cost;
			dist[e.to][e.from] = e.cost;

			// cout << e.from << " -- " << e.to << " [label = \"" << e.cost << "\"];" << endl;
		}
	}

	return ret;
}

bool O[55];
int dp[55]; // 部分木iを消す時の最善
int n;

int dfs2(int cur, int pre) {
	int cnt = 0;
	rep(i, G[cur].size()) {
		edge e = G[cur][i];
		if(e.to == pre) continue;
		cnt++;
	}

	if(cnt == 0) {
		if(O[cur]) {
			dp[cur] = dist[cur][pre];
			return 0;
		} else {
			dp[cur] = 0;
			return 0;
		}
	}

	vector<int> v;
	int ret = 0;
	rep(i, G[cur].size()) {
		edge e = G[cur][i];
		if(e.to == pre) continue;

		int x = dfs2(e.to, cur);
		ret += x;
		int res = min(dp[e.to], dist[e.to][cur]);

		if(res == 0) continue;
		v.push_back(res);
	}

	if(O[cur]) {
		int sum = 0;
		rep(i, v.size()) {
			sum += v[i];
		}
		return sum + ret;
	} else {
		if(v.size() == 0) {
			dp[cur] = 0;
			return ret;
		}
		else if(v.size() == 1) {
			dp[cur] = v[0];
			return ret;
		} else {
			sort(v.begin(), v.end());

			int sum = 0;
			rep(i, v.size()-1) {
				sum += v[i];
			}

			dp[cur] = v[v.size()-1];
			return sum + ret;
		}
	}
}

class BlockEnemy {
	public:
	int minEffort(int N, vector <string> roads, vector <int> occupiedTowns) {
		n = N;
		memset(O, 0, sizeof(O));
		rep(i, occupiedTowns.size()) {
			O[occupiedTowns[i]] = true;
		}

		rep(i, 55) dp[i] = INF;

		vector<edge> E;
		rep(i, roads.size()) {
			vector<string> ret = split(roads[i], ' ');

			int a = f(ret[0]);
			int b = f(ret[1]);
			int e = f(ret[2]);

			E.push_back(edge(a, b, e));
		}

		kruskal(N, E);

		return dfs2(0, -1);
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM319 D1M ConstructBST]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/27/srm319-d1m-constructbst/"/>
    <updated>2016-10-27T02:38:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/27/srm319-d1m-constructbst</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6714&rd=9999">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

完全二分木の制約はD2Hの同じ．今度は$1-indexed$で始まっている完全二分木の存在するノード番号が与えられるので，制約を満たすアルファベットの割り当て方の通りを求める．  
全てのノードに置いて部分木の大きさを求めておく．あるノードに対して左の子をleftとしてその部分木の大きさを$cntL$，右の子をrightとしてその部分木の大きさを$cntR$とする．既にleft, rightの部分木のアルファベットの割り当て方の通りが求まっていて$cnt1, cnt2$とすると見ているノードが取れる値の集合の分け方に対して，leftとrightのどの組み合わせでも制約を満たすので$cnt1 * cnt2$通りある．ノードが取れる値の集合の分け方というのはノードの部分木のsize$(L+R)$から左の子の選ぶ組み合わせにで求めることができるので最終的にノードの割り当て方の通りは$cnt1 * cnt2 * {}\_{cntL + cntR}C\_{cntL}$となる．これを再帰的にやる．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

struct Node {
	int cntL, cntR;
	Node *left, *right;

	Node() {
		cntL = cntR = 0;
		left = right = NULL;
	}
};

set<int> S;
void build(int x, Node *root) {
	root->left = new Node();
	root->right = new Node();

	if(S.find(2 * x) != S.end()) {
		build(2 * x, root->left);
		root->cntL = (root->left->cntL + root->left->cntR + 1);
	}

	if(S.find(2 * x + 1) != S.end()) {
		build(2 * x + 1, root->right);
		root->cntR = (root->right->cntL + root->right->cntR + 1);
	}
}

ll C[2005][2005];
void combination(int size) {
	for (int i = 0; i < size; i++) C[i][0] = 1LL;
	for (int i = 1; i < size; i++) {
		for (int j = 1; j <= i; j++) {
			C[i][j] = (C[i-1][j-1] + C[i-1][j]);
		}
	}
}

ll dfs(Node *node) {
	if(node == NULL) return 1;
	ll n = node->cntL, m = node->cntR;

	ll cnt1 = dfs(node->left);
	ll cnt2 = dfs(node->right);

	return cnt1 * cnt2 * C[n + m][n];
}

class ConstructBST {

    public:

    long long numInputs(vector <int> tree) {
		Node *root = new Node();
		S.clear();

		rep(i, tree.size()) {
			S.insert(tree[i]);
		}
		build(1, root);

		combination(2000);
		return dfs(root);
    }
};
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM319 D2H IncompleteBST]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/27/srm319-d2h-incompletebst/"/>
    <updated>2016-10-27T02:07:55+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/27/srm319-d2h-incompletebst</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6713&rd=9999">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

完全二分木が与えられる．完全二分木のためノードは子にleftとrightを持つが，その持つ値に制限がある．

* leftの部分木の全ての値はleftの値より小さいか等しくなければならない
* rightの部分木の全ての値はrightの値より大きくなければならない

完全二分木の中に1つだけ要素が決まっていないノード?がある．そのノードの値として制約を満たすアルファベットを全て並べる．

---

?のノードの値を全て探索して制約を満たしているかどうか見てあげる．dfsでは，今見ているノードが持って良い値の範囲を$[minval$, $maxval]$として持っておく．leftに行く場合には，その部分木が今見ているノードの値より小さいか等しくなければいけないので$[minval$, $val]$として進む．rightに行く場合には，その部分木が今見ているノードの値より大きくなければいけないので$[val + 1$, $minval]$として進む．矛盾なく進むことが出来たらtrueを返すようにした．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

int cnt[1<<21];
bool flag[1<<21];

int vmax = -1;
bool dfs(int id, int val, int minval, int maxval) {
	if(val < minval || val > maxval) {
		return false;
	}

	int l = (id * 2);
	int r = (id * 2 + 1);

	bool f1 = false, f2 = false;

	if(cnt[l] != -1) {
		f1 = dfs(l, cnt[l], minval, val);
	} else {
		f1 = true;
	}

	if(cnt[r] != -1) {
		f2 = dfs(r, cnt[r], val + 1, maxval);
	} else {
		f2 = true;
	}

	return f1 && f2;
}


class IncompleteBST {
	public:
	string missingValues(vector <string> tree) {
		int n = tree.size();
		memset(cnt, -1, sizeof(cnt));
		memset(flag, 0, sizeof(flag));

		int x = -1;
		rep(i, n) {
			string s = tree[i].substr(2);
			stringstream ss(s);
			int id; ss >> id;

			vmax = max(vmax, id);

			if(tree[i][0] == '?') {
				flag[id] = true;
				x = id;
			} else {
				int val = (tree[i][0] - 'A');
				cnt[id] = val;
			}

		}

		string ans = "";
		rep(i, 26) {
			cnt[x] = i;
			if(dfs(1, cnt[1], 0, 25)) {
				ans += char('A'+i);
			}
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM316 D2H SpreadingNews]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/26/srm316-d2h-spreadingnews/"/>
    <updated>2016-10-26T12:31:06+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/26/srm316-d2h-spreadingnews</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6538&rd=9996">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

ノードは自分の子に対してnewsを伝えることが出来る．1人の人は1人にしか伝えることが出来ず，同時に複数人に伝える事はできない．最終的に全ての人に伝わえるまで何ステップかかるか

{% img /images/SRM/316_1.png %}

上の画像の赤いノードについて考える．下の子については既にそのノード以下に全て伝えるには何ステップかかるか，という値が分かっていて，左から$2, 3, 4$であったとする．この時赤いノードはどのノードに情報を伝えるかの順番を選ぶことができる．子ノードに伝えてから子ノードは情報の伝搬を始めるので，最小を求めるには値の大きい順に伝えていけば良い．子ノードの値を降順ソートし，その値$+$index$+1$(順番に伝える)の$max$が赤いノード以下に全て伝えるステップ数となる．これを再帰的に全てのノードについて行った．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;
typedef pair<P, int> PI;

vector<int> g[55];

int dfs(int i) {
	if(g[i].size() == 0) return 0;

	vector<int> v;
	rep(j, g[i].size()) {
		v.push_back(dfs(g[i][j]));
	}

	sort(v.begin(), v.end(), greater<int>());

	int ret = 0;
	rep(i, v.size()) {
		ret = max(ret, v[i] + i + 1);
	}
	return ret;
}

class SpreadingNews {

    public:

    int minTime(vector <int> supervisors) {
		int n = supervisors.size();

		rep(i, 55) g[i].clear();

		int root = -1;
		rep(i, n) {
			if(supervisors[i] == -1) {
				root = i;
			} else {
				g[supervisors[i]].push_back(i);
			}
		}

		return dfs(root);
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces353-div2D Tree Construction]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/17/codeforces353-div2d-tree-construction/"/>
    <updated>2016-05-17T18:36:48+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/17/codeforces353-div2d-tree-construction</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/675/problem/D">Problem - D - Codeforces</a></h4><p>During the programming classes Vasya was assigned a difficult problem. However, he doesn't know how to code and was unable to find the solution in the Internet, so he asks you to help. You are given a sequence a, consisting of n distinct integers, that is used to construct the binary search tree.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

　{% m %} 2 {% em %}分木の挿入する順番が与えられる．挿入した時の親の番号を答える．  
愚直に木を構成すると線のような木の場合に {% m %} O(n ^2) {% em %}となるので間に合わない．区間をsetで管理すると次に挿入する場所が {% m %} logn {% em %}で持ってこれるので，全体で {% m %} O(n logn) {% em %}となる．map({% m %}l, r {% em %})に区間 {% m %} [l, r] {% em %}の親を持っておくようにした．  

sample2でどのように動くかをメモしておく．(書いておかないと絶対忘れる．．．)

# Sample 2
> {% m %} 5 {% em %}  
> {% m %} 4\ 2\ 3\ 1\ 6\ {% em %}

手順，挿入する数，挿入する区間 {% m %} \to {% em %} 挿入した結果と書いてみた．

{% math %}
\begin{eqnarray}
insert \ \ (4) \ \ [-\infty, \infty] \ \ &\to& \ \ [-\infty, 4], [4, \infty] \\
insert \ \ (2) \ \ [-\infty,\ \ 4] \ \ &\to& \ \ [-\infty, 2], [2, 4], [4, \infty]  \\
insert \ \ (3) \ \ [\,\ \ \ \ 2,\ \ 4] \ \ &\to& \ \ [-\infty, 2], [2, 3], [3, 4], [4, \infty] \\
insert \ \ (1) \ \ [-\infty,\ \ 2] \ \ &\to& \ \ [-\infty, 1], [1, 2], [2, 3], [3, 4], [4, \infty] \\
insert \ \ (6) \ \ [\,\ \ \ \ 4,\infty] \ \ &\to& \ \ [-\infty, 1], [1, 2], [2, 3], [3, 4], [4, 6], [6, \infty] \\
\end{eqnarray}
{% endmath %}

後は区間{% m %} [l, r] {% em %}のmapに入っている値を答えて， {% m %} [l, v[i]], [v[i], r] {% em %}に {% m %} v[i] {% em %}を入れておく．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

map<P, int> m;

int main() {
	int n;
	cin >> n;

	vector<int> v(n);
	rep(i, n) cin >> v[i];

	vector<int> ans;

	set<int> st;
	st.insert(INF);
	st.insert(-INF);
	st.insert(v[0]);

	m[mp(-INF, v[0])] = v[0];
	m[mp(v[0], INF)] = v[0];

	REP(i, 1, n) {
		set<int>::iterator ite = st.upper_bound(v[i]);
		int r = *ite;
		ite--;
		int l = *ite;

		ans.push_back(m[mp(l, r)]);

		m[mp(l, v[i])] = v[i];
		m[mp(v[i], r)] = v[i];
		st.insert(v[i]);
	}

	rep(i, ans.size()) {
		cout << ans[i];

		if(i == ans.size()-1) cout << endl;
		else cout << " ";
	}


	return 0;
}
```

]]></content>
  </entry>
  
</feed>
