<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: しゃくとり法 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/siyakutorifa/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-05T20:01:22+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM692 D1E HardProof]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/10/srm692-d1e-hardproof/"/>
    <updated>2016-06-10T22:53:39+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/10/srm692-d1e-hardproof</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14334&rd=16747">TopCoder Statistics - Problem Statement</a></h4><p>You are preparing for an exam in Calculus 4. In the chapter "Abstract Fourier Series", you encountered an excercise in which you are given a collection of N statements and your task is to prove that all N statements are equivalent. For the purpose of this problem, we will number the statements 0 through N-1.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$0 => 1$を頂点$0$ $\to$ 頂点$1$の有向グラフと考えると，$N$個の頂点を含む閉路の中でその辺の最大コスト$-$最小コストを答えれば良いとなる．  
  
コストが近いものを同士を使った方が良いので，使うコストの端を持ってしゃくとり法をした．（考え方は[ここ]({% post_url 2016-05-21-aoj1280-slim-span %})に似てると思った）  
$N$個の頂点を含む閉路の検出は強連結成分分解した後の連結成分数が$1$であるかどうかで判定．  
全て辺を張ってで行けるか行けないを持ったらTLE．辺を追加したり削除したりした場合でもTLE．毎回毎回グラフを作り直したらACした．(最初の$2$つは$N ^2$よりもかかっている(?)よく分かっていない)

# Code

```cpp
struct edge {
	int from,to;
	int cost;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int f,int t,int c) : from(f),to(t),cost(c) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

struct SCC {
	int n;
	vector<vector<int> > g, rg, ng, scc; // rg: 逆グラフ, ng: 分解後のグラフ
	vector<int> res; // scc: 強連結成分に属する頂点, res:強連結成分の番号
	bool used[100005];

	SCC(int _n) {
		n = _n;
		g.resize(n); rg.resize(n) ; scc.resize(n); res.resize(n);
	}

	SCC(const vector<vector<int> > &g) : n(g.size()), g(g), rg(n), scc(n), res(n) {
		rep(i, n) {
			rep(j, g[i].size()) rg[g[i][j]].push_back(i);
		}
	}

	// i-jに辺を追加する
	void add(int i, int j) {
		g[i].push_back(j);
		rg[j].push_back(i);
	}

	vector<int> vs;
	void dfs(int v) {
		used[v] = true;
		rep(i, g[v].size()) {
			if(!used[ g[v][i] ]) dfs(g[v][i]);
		}
		vs.push_back(v);
	}

	void rdfs(int v, int k) {
		used[v] = true;
		res[v] = k; 
		scc[k].push_back(v);
		rep(i, rg[v].size()) {
			if(!used[ rg[v][i] ]) rdfs(rg[v][i], k);
		}
	}

	void ng_make(int k) {
		ng.resize(k);
		rep(i, n) {
			set<int> S;
			rep(j, g[i].size()) {
				int to = g[i][j];
				if(res[i] == res[to]) continue;
				if(S.find(res[to]) != S.end()) continue;
				ng[res[i]].push_back(res[to]);
				S.insert(res[to]);
			}
		}
	}

	int build() {
		memset(used, 0, sizeof(used));
		rep(i, n) {
			if (!used[i]) dfs(i);
		}

		memset(used, 0, sizeof(used));
		int k = 0;
		for (int i = vs.size()-1; i >= 0; i--) {
			if (!used[vs[i]]) rdfs(vs[i], k++);
		}

		// ng_make(k);
		return k;
	}
};

class HardProof {
	public:
	int minimumCost(vector<int> D) {
		int n = sqrt(D.size());

		int k = -1;
		map<int, vector<P> > m;

		rep(i, n) {
			rep(j, n) {
				k++;
				if(i == j) continue;
				m[D[k]].push_back(mp(i, j));
			}
		}

		int ans = INF;
		map<int, vector<P> >::iterator l = m.begin(), r = m.begin(), ite;

		for(r = m.begin(); r != m.end(); r++) {
			k = 1;
			while(k == 1) {
				SCC scc(n);
				ite = l;
				while(ite != m.end() && ite->first <= r->first) {
					vector<P> v = ite->second;
					rep(i, v.size()) {
						int a = v[i].first, b = v[i].second;
						scc.add(a, b);
					}

					if(ite == r) break;
					ite++;
				}

				k = scc.build();
				if(k == 1) {
					ans = min(ans, r->first - l->first);
					l++;
					continue;
				}
				break;
			}
		}

		if(ans == INF) return 0;
		return ans;
	}
};
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces354-div2C Vasya and String]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/26/codeforces354-div2c-vasya-and-string/"/>
    <updated>2016-05-26T09:38:50+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/26/codeforces354-div2c-vasya-and-string</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/676/problem/C">Problem - C - Codeforces</a></h4><p>High school student Vasya got a string of length n as a birthday present. This string consists of letters 'a' and '' only. Vasya denotes beauty of the string as the maximum length of a substring (consecutive subsequence) consisting of equal letters. Vasya can change no more than k characters of the original string.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

長さ{% m %} n {% em %}の文字{% m %} a, b {% em %}で構成された文字列が与えられる．{% m %} k {% em %}回変更可能な時に，同じ文字で構成される部分文字列の最大長を答える．  
  
文字 {% m %} a {% em %}だけで構成される部分文字列を考える．区間{% m %} [l, r]{% em %}の中に文字{% m %} b {% em %}が {% m %} k {% em %}個以下ならば，その区間では全て {% m %} a {% em %}にすることができる．これをずらしながらやっていく．文字{% m %} b {% em %}で構成される部分文字列も同様にやり，最大値を取った． {% m %} O(n) {% em %}．


# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int n, k;
	cin >> n >> k;

	string s;
	cin >> s;

	int ans = 0;

	int l = 0, r = 0, cnt = 0;
	rep(i, n) {
		r = i;
		if(s[i] == 'b') cnt++;

		if(cnt <= k) {
			ans = max(ans, r - l + 1);
		}

		while(cnt > k) {
			if(s[l] == 'b') cnt--;
			l++;
		}
	}

	l = 0, r = 0, cnt = 0;
	rep(i, n) {
		r = i;
		if(s[i] == 'a') cnt++;

		if(cnt <= k) {
			ans = max(ans, r - l + 1);
		}

		while(cnt > k) {
			if(s[l] == 'a') cnt--;
			l++;
		}
	}

	cout << ans << endl;


	return 0;
}
```

本番では落ちた．区間 {% m %} [l, r] {% em %}の中の{% m %} b {% em %}が{% m %} k {% em %}を超えた時，というのは今見ている文字が{% m %} b {% em %}でその文字を {% m %} a {% em %}に変えて， {% m %} l {% em %}をずらす，ということなので {% m %} r {% em %}は必ず今見ている場所 {% m %} i {% em %}となる．ということがよく整理できていなかった．反省．
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0600 Baumkuchen]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/10/aoj0600-baumkuchen/"/>
    <updated>2016-03-10T23:01:54+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/10/aoj0600-baumkuchen</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0600">Baumkuchen | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

円環を切って2つ繋げて表現する．{% m %} sum\[i\]をi {% em %}未満の切り込み間の大きさの和として持っておく．区間{% m %} (s, t\] {% em %}を{% m %}3{% em %}ピースに分けた時の最小値，もう1つの切れ込みを入れる場所を {% m %} id {% em %}と置くと，

* {% m %} (s, t\] {% em %}
* {% m %} (t, id\] {% em %}
* {% m %} (id, s+n\]{% em %}

の{% m %} 3 {% em %}ピースに分けることになる．区間{% m %} (s, t\] {% em %}を最小にしたいので，その区間の大きさ{% m %} d {% em %}を初めて超える場所をlower_boundで取ってくる．後は取ってきた場所から{% m %} s+n {% em %}までの和が{% m %} d {% em %}よりも大きければ良い．もしをこれを満たすようなら，右端を伸ばしてみて，ダメだったら左端を縮める．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int n;
	cin >> n;

	vector<ll> v(n);
	rep(i, n) cin >> v[i];

	vector<ll> sum(2*n + 1);
	rep(i, n) {
		sum[i+1] += sum[i] + v[i];
	}

	rep(i, n) {
		sum[n+i+1] += sum[n + i] + v[i];
	}

	ll ans = 0;
	int s = 0, t = 0,cnt = 0;
	bool flag = true, first = true;

	while(true) {
		if(flag) t++;
		else s++;

		if(s + n >= sum.size()) break;

		ll d = sum[t] - sum[s];
		int id = lower_bound(sum.begin(), sum.end(), sum[t]  + (sum[t] - sum[s])) - sum.begin();

		if(s + n > id && d < sum[s+n] - sum[id]) {
			ans = max(ans, d);
			flag = true;
		} else {
			flag = false;
		}
	}

	cout << ans << endl;

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0572 Card Game is Fun]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/16/aoj0572-card-game-is-fun/"/>
    <updated>2016-02-16T23:08:35+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/16/aoj0572-card-game-is-fun</id>
    <content type="html"><![CDATA[問題文  
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0572

<!-- more -->

ブルーノは上から何枚か，下から何枚かを削る．つまり連続したカードが残る．もしブルーノのカードの山が決まった時に，アンナがそのカードの山を作れるかは，先頭から見ていきアンナの山にあるかどうかを見れば良い．  
ブルーノの残すと考えてる暫定カードの先頭と末尾の{% m %}id{% em %}を持っておき，  
そのカードの山をアンナが作れるのであれば，末尾を{% m %}+1もしそうでなければ先頭を+1する． {% em %}  
この{% m %}maxを取れば良いのでO(n ^2){% em %}．
# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int n, m;
	cin >> n >> m;

	vector<int> a(n), b(m);
	rep(i, n) cin >> a[i];
	rep(i, m) cin >> b[i];

	set< vector<int> > st;

	int ans = 0,s = 0, t = 1;
	while(s != b.size()) {
		vector<int> v(t - s);
		REP(j, s, t) {
			v[j-s] = b[j];
		}

		bool flag = false;
		int id = 0;
		rep(j, n) {
			if(a[j] == v[id]) {
				id++;
				if(id == v.size()) {
					flag = true;
					break;
				}
			}
		}

		if(flag) {
			t++;
			ans = max(ans, (int)v.size());
		} else {
			s++;
			if(s == t) t++;
		}

	}

	cout << ans << endl;

	return 0;
}
```

]]></content>
  </entry>
  
</feed>
