<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 条件付き確率 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/tiao-jian-fu-kique-lu/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-10T01:42:35+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM304 D1M Conditional]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/24/srm304-d1m-conditional/"/>
    <updated>2016-08-24T00:34:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/24/srm304-d1m-conditional</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6412&rd=9825">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$maxSide$まであるサイコロを$nDice$個振った時，少なくとも$1$つは$v$が出て，$theSum$を超える確率を求める．

---

少なくとも$1$つ$v$が出るという条件が無ければ
```cpp
dp[0][0] = 1.0;
rep(i, nDice) {
	rep(j, 55 * 55) {
		REP(k, 1, maxSide) {
			dp[i+1][j + k] += dp[i][j] * (1.0 / maxSide);
		}
	}
}
```
として，$theSum$以上の和を取れば良いが，この条件がある場合は$v$が出た場合と出ない場合で分ける必要がある．そのためdpを

$$
\begin{eqnarray}
	dp[i][j][0] \&:=\& i個目のサイコロを振って和がjで，一回もvが出ない時の確率 \\\
	dp[i][j][1] \&:=\& i個目のサイコロを振って和がjで，少なくとも一回はvが出た時の確率
\end{eqnarray}
$$

として分けて考える．今まで$v$がでなくて，今回初めて$v$が出た時に$[1]$に遷移する．後は少なくとも$1$つ$v$が出る確率を出して割れば良い．この確率は$(1 - vが一回も出ない確率)$として出した．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

double dp[55][55 * 55][2];

class Conditional {

    public:

    double probability(int nDice, int maxSide, int v, int theSum) {
		memset(dp, 0, sizeof(dp));
		dp[0][0][0] = 1.0;

		rep(i, nDice) {
			rep(j, 55 * 55) {
				REP(k, 1, maxSide + 1) {
					if(j + k >= 55 * 55) continue;
					dp[i+1][j + k][1] += dp[i][j][1] * (1.0 / maxSide);

					if(k == v) {
						dp[i+1][j + k][1] += dp[i][j][0] * (1.0 / maxSide);
					} else {
						dp[i+1][j + k][0] += dp[i][j][0] * (1.0 / maxSide);
					}
				}
			}
		}

		double ans = 0.0;
		REP(i, theSum, 55 * 55) {
			ans += dp[nDice][i][1];
		}

		double t = 1.0;
		rep(i, nDice) {
			t *= double(maxSide - 1) / maxSide;
		}

		return ans / (1 - t);
    }

};
```
]]></content>
  </entry>
  
</feed>
