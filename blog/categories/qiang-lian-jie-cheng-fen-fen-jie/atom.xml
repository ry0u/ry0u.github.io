<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 強連結成分分解 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/qiang-lian-jie-cheng-fen-fen-jie/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-09-03T02:19:57+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JAG Contest 2016 DomesticB D 夏合宿の朝は早い]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/17/jag-contest-2016-domesticb-d-xia-he-su-falsezhao-hazao-i/"/>
    <updated>2016-06-17T17:13:18+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/17/jag-contest-2016-domesticb-d-xia-he-su-falsezhao-hazao-i</id>
    <content type="html"><![CDATA[<!-- more -->

強連結成分分解した後，各連結成分の始点が全て起きている確立の積を求める．始点が起きている確立は，$1 - $その強連結成分のノード番号に属するノードが全員起きていない確立で求まる．始点かどうかは，強連結成分分解後のグラフのノードの自分に向いている辺の個数が$0$であればよいのでカウントしていった．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <set>

#define REP(i, k, n) for(int i = k; i < n; i++)
#define rep(i, n) for(int i = 0; i < n; i++)

using namespace std;

struct SCC {
	int n;
	vector<vector<int> > g, rg, ng, scc;
	vector<int> res;
	bool used[105];

	SCC(int _n) {
		n = _n;
		g.resize(n); rg.resize(n); scc.resize(n); res.resize(n);
	}

	void add(int i, int j) {
		g[i].push_back(j);
		rg[j].push_back(i);
	}

	vector<int> vs;
	void dfs(int v) {
		used[v] = true;
		rep(i, g[v].size()) {
			if(!used[ g[v][i] ]) dfs(g[v][i]);
		}
		vs.push_back(v);
	}

	void rdfs(int v, int k) {
		used[v] = true;
		res[v] = k;
		scc[k].push_back(v);

		rep(i, rg[v].size()) {
			if(!used[ rg[v][i] ]) rdfs(rg[v][i], k);
		}
	}

	void ng_make(int k) {
		ng.resize(k);

		rep(i, n) {
			set<int> S;
			rep(j, g[i].size()) {
				int to = g[i][j];
				if(res[i] == res[to]) continue;
				if(S.find(res[to]) != S.end()) continue;
				ng[res[i]].push_back(res[to]);
				S.insert(res[to]);
			}
		}
	}

	int build() {
		memset(used, 0, sizeof(used));
		rep(i, n) {
			if(!used[i]) dfs(i);
		}

		memset(used, 0, sizeof(used));
		int k = 0;
		for(int i = vs.size()-1; i >= 0; i--) {
			if(!used[vs[i]]) rdfs(vs[i], k++);
		}

		ng_make(k);
		return k;
	}
};

int main() {
	int n;
	while(cin >> n && n) {
		vector<double> v(n);
		SCC scc(n);

		rep(i, n) {
			int x;
			cin >> v[i] >> x;

			rep(j, x) {
				int a;
				cin >> a;
				
				a--;
				scc.add(i, a);
			}
		}

		int k = scc.build();
		vector<vector<int> > g = scc.ng;

		int cnt[105];
		memset(cnt, 0, sizeof(cnt));

		rep(i, k) {
			rep(j, g[i].size()) {
				cnt[g[i][j]]++;
			}
		}

		double ans = 1.0;
		rep(i, k) {
			if(cnt[i] != 0) continue;
			double t = 1.0;
			rep(j, scc.scc[i].size()) {
				int u = scc.scc[i][j];
				t *= v[u];
			}

			ans *= (1.0 - t);
		}

		cout << fixed;
		cout.precision(20);
		cout << ans << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM692 D1E HardProof]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/10/srm692-d1e-hardproof/"/>
    <updated>2016-06-10T22:53:39+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/10/srm692-d1e-hardproof</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14334&rd=16747">TopCoder Statistics - Problem Statement</a></h4><p>You are preparing for an exam in Calculus 4. In the chapter "Abstract Fourier Series", you encountered an excercise in which you are given a collection of N statements and your task is to prove that all N statements are equivalent. For the purpose of this problem, we will number the statements 0 through N-1.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$0 => 1$を頂点$0$ $\to$ 頂点$1$の有向グラフと考えると，$N$個の頂点を含む閉路の中でその辺の最大コスト$-$最小コストを答えれば良いとなる．  
  
コストが近いものを同士を使った方が良いので，使うコストの端を持ってしゃくとり法をした．（考え方は[ここ]({% post_url 2016-05-21-aoj1280-slim-span %})に似てると思った）  
$N$個の頂点を含む閉路の検出は強連結成分分解した後の連結成分数が$1$であるかどうかで判定．  
全て辺を張ってで行けるか行けないを持ったらTLE．辺を追加したり削除したりした場合でもTLE．毎回毎回グラフを作り直したらACした．(最初の$2$つは$N ^2$よりもかかっている(?)よく分かっていない)

# Code

```cpp
struct edge {
	int from,to;
	int cost;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int f,int t,int c) : from(f),to(t),cost(c) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

struct SCC {
	int n;
	vector<vector<int> > g, rg, ng, scc; // rg: 逆グラフ, ng: 分解後のグラフ
	vector<int> res; // scc: 強連結成分に属する頂点, res:強連結成分の番号
	bool used[100005];

	SCC(int _n) {
		n = _n;
		g.resize(n); rg.resize(n) ; scc.resize(n); res.resize(n);
	}

	SCC(const vector<vector<int> > &g) : n(g.size()), g(g), rg(n), scc(n), res(n) {
		rep(i, n) {
			rep(j, g[i].size()) rg[g[i][j]].push_back(i);
		}
	}

	// i-jに辺を追加する
	void add(int i, int j) {
		g[i].push_back(j);
		rg[j].push_back(i);
	}

	vector<int> vs;
	void dfs(int v) {
		used[v] = true;
		rep(i, g[v].size()) {
			if(!used[ g[v][i] ]) dfs(g[v][i]);
		}
		vs.push_back(v);
	}

	void rdfs(int v, int k) {
		used[v] = true;
		res[v] = k; 
		scc[k].push_back(v);
		rep(i, rg[v].size()) {
			if(!used[ rg[v][i] ]) rdfs(rg[v][i], k);
		}
	}

	void ng_make(int k) {
		ng.resize(k);
		rep(i, n) {
			set<int> S;
			rep(j, g[i].size()) {
				int to = g[i][j];
				if(res[i] == res[to]) continue;
				if(S.find(res[to]) != S.end()) continue;
				ng[res[i]].push_back(res[to]);
				S.insert(res[to]);
			}
		}
	}

	int build() {
		memset(used, 0, sizeof(used));
		rep(i, n) {
			if (!used[i]) dfs(i);
		}

		memset(used, 0, sizeof(used));
		int k = 0;
		for (int i = vs.size()-1; i >= 0; i--) {
			if (!used[vs[i]]) rdfs(vs[i], k++);
		}

		// ng_make(k);
		return k;
	}
};

class HardProof {
	public:
	int minimumCost(vector<int> D) {
		int n = sqrt(D.size());

		int k = -1;
		map<int, vector<P> > m;

		rep(i, n) {
			rep(j, n) {
				k++;
				if(i == j) continue;
				m[D[k]].push_back(mp(i, j));
			}
		}

		int ans = INF;
		map<int, vector<P> >::iterator l = m.begin(), r = m.begin(), ite;

		for(r = m.begin(); r != m.end(); r++) {
			k = 1;
			while(k == 1) {
				SCC scc(n);
				ite = l;
				while(ite != m.end() && ite->first <= r->first) {
					vector<P> v = ite->second;
					rep(i, v.size()) {
						int a = v[i].first, b = v[i].second;
						scc.add(a, b);
					}

					if(ite == r) break;
					ite++;
				}

				k = scc.build();
				if(k == 1) {
					ans = min(ans, r->first - l->first);
					l++;
					continue;
				}
				break;
			}
		}

		if(ans == INF) return 0;
		return ans;
	}
};
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM684D2H Autohamil]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/16/srm684d2h-autohamil/"/>
    <updated>2016-03-16T00:01:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/16/srm684d2h-autohamil</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14183&rd=16688">TopCoder Statistics - Problem Statement</a></h4><p>In this problem, all strings are binary strings. That is, each character of a string is either '0' or '1'. A deterministic finite automaton is a machine that processes strings. The automaton has a finite set of possible states. The states are numbered 0 through n-1, where n is the number of states.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

有向グラフが与えられるので，ハミルトン路があるかどうかを判定せよ．

---

閉路があるので，強連結成分分解する．分解後のグラフで{% m %} 0 {% em %}を始点に探索を始め，分かれ道があれば出来ないと思ったが，全然違うしサンプルも合わない．こういう場合は出来る．  

{% img /images/SRM/684d2h.png %}
  

強連結成分分解をしDAGになったので，トポロジカルソートしてトポロジカル順序で{% m %} i \to i+1 {% em %}の辺があるかを調べる．また，トポロジカル順序の開始が{% m %} 0 {% em %}で無い場合も出来ないことを忘れない(分からなかった)．


# Code
```cpp
struct SCC {
	int n;
	vector<vector<int> > g, rg, ng, scc; // rg: 逆グラフ, ng: 分解後のグラフ
	vector<int> res; // scc: 強連結成分に属する頂点, res:強連結成分の番号
	bool used[100005];

	SCC(int _n) {
		n = _n;
		g.resize(n); rg.resize(n) ; scc.resize(n); res.resize(n);
	}

	SCC(const vector<vector<int> > &g) : n(g.size()), g(g), rg(n), scc(n), res(n) {
		rep(i, n) {
			rep(j, g[i].size()) rg[g[i][j]].push_back(i);
		}
	}

	// i-jに辺を追加する
	void add(int i, int j) {
		g[i].push_back(j);
		rg[j].push_back(i);
	}

	vector<int> vs;
	void dfs(int v) {
		used[v] = true;
		rep(i, g[v].size()) {
			if(!used[ g[v][i] ]) dfs(g[v][i]);
		}
		vs.push_back(v);
	}

	void rdfs(int v, int k) {
		used[v] = true;
		res[v] = k; 
		scc[k].push_back(v);
		rep(i, rg[v].size()) {
			if(!used[ rg[v][i] ]) rdfs(rg[v][i], k);
		}
	}

	void ng_make(int k) {
		ng.resize(k);
		rep(i, n) {
			set<int> S;
			rep(j, g[i].size()) {
				int to = g[i][j];
				if(res[i] == res[to]) continue;
				if(S.find(res[to]) != S.end()) continue;
				ng[res[i]].push_back(res[to]);
				S.insert(res[to]);
			}
		}
	}

	int run() {
		memset(used, 0, sizeof(used));
		rep(i, n) {
			if (!used[i]) dfs(i);
		}

		memset(used, 0, sizeof(used));
		int k = 0;
		for (int i = vs.size()-1; i >= 0; i--) {
			if (!used[vs[i]]) rdfs(vs[i], k++);
		}

		ng_make(k);
		return k;
	}
};

bool used[55];
vector< vector<int> > ng;
vector<int> out;

void dfs(int cur) {
	used[cur] = true;
	rep(i, ng[cur].size()) {
		int v = ng[cur][i];
		if(!used[v]) dfs(v);
	}
	out.push_back(cur);
}

class Autohamil {
	public:
	string check(vector <int> z0, vector <int> z1) {
		int n = z0.size();
		SCC scc(n);

		rep(i, n) {
			if(i != z0[i]) scc.add(i, z0[i]);
			if(i != z1[i]) scc.add(i, z1[i]);
		}

		int m = scc.run();
		ng.resize(m);
		rep(i, m) {
			ng[i].resize(scc.ng[i].size());
			rep(j, scc.ng[i].size()) {
				ng[i][j] = scc.ng[i][j];
			}
		}

		int cnt[55];
		memset(cnt, 0, sizeof(cnt));
		rep(i, m) {
			rep(j, ng[i].size()) {
				cnt[ng[i][j]]++;
			}
		}

		REP(i, 1, m) {
			if(cnt[i] == 0) return "Does not exist";
		}

		int s = scc.res[0];
		memset(used, 0, sizeof(used));
		out.clear();
		dfs(s);
		reverse(out.begin(), out.end());

		if(out[0] != 0) return "Does not exist";

		rep(i, out.size()-1) {
			bool ch = false;
			rep(j, ng[out[i]].size()) {
				if(ng[out[i]][j] == out[i+1]) {
					ch = true;
				}
			}

			if(ch) continue;
			return "Does not exist";
		}
		return "Exists";
	}
};
```

]]></content>
  </entry>
  
</feed>
