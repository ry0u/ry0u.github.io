<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: prime | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/prime/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-10T01:42:35+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM307 D2H PreprimeNumbers]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/28/srm-d2h-preprimenumbers/"/>
    <updated>2016-08-28T23:51:48+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/28/srm-d2h-preprimenumbers</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6083&rd=9987">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

約数を$4$つ持つ数を$preprime$という．$1-indexed$で始めたと時，$n$番目の$preprime$はいくつか．

---

どの数も$1$と自身を約数に持つということで，$4$つの約数を持つということは$1$と自身以外に$2$つ持つということである．これは$2$つの素数の積(約数は$1, p, q, pq$)か，$1$つの素数の$3$乗の形(約数は$1, p, p ^2, p ^3$)になる．  
$n \\leq 10 ^6$ということで最大値はそこまで大きくないだろうと予想し，$10 ^7$を最大としてやった．エラトステネスの篩の要領で$2$から始めていき，その倍数のところをインクリメントしていく．予め$3$乗の数は$used$にメモしておく．オーバーフローに注意(落ちた)．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int dp[10000000];
bool used[10000000];

class PreprimeNumbers {

    public:

    int nthNumber(int n) {
		ll i = 2;
		memset(dp, 0, sizeof(dp));
		memset(used, 0, sizeof(used));

		while(n) {
			if(dp[i] == 0 && i * i < 10000000 && i * i * i < 10000000) used[i * i * i] = true;
			if(dp[i] == 2 || used[i]) n--;

			for(ll j = i; j < 10000000; j += i) {
				dp[j]++;
			}
			i++;
		}

		return i - 1;
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM303 D2H PrimePalindromic]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/22/srm303-d2h-primepalindromic/"/>
    <updated>2016-08-22T21:35:53+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/22/srm303-d2h-primepalindromic</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6063&rd=9824">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$prime-palindromic$とは，素因数の並び替えで回文が作れることを言う．$A \sim B$に何個$prime-palindromic$があるか．

---

事前に10000までの数の素因数を出してみると少ないことが分かるので，愚直に全パターン並び替えを行って，連結して回文判定をした．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

vector<ll> prime_factor(ll n) {
	vector<ll> res;
	if(n == 1) return res;

	for(ll i = 2; i*i <= n; i++) {
		while(n%i == 0) {
			res.push_back(i);
			n /= i;
		}
	}

	if(n != 1) res.push_back(n);
	return res;
}

string f(ll x) {
	string ret = "";
	while(x) {
		ret = char('0' + x % 10) + ret;
		x /= 10;
	}
	return ret;
}

class PrimePalindromic {
	public:
	int count(int A, int B) {
		int ans = 0;
		REP(i, A, B + 1) {
			vector<ll> ret = prime_factor(i);
			sort(ret.begin(), ret.end());

			do {
				string s = "";
				rep(j, ret.size()) s += f(ret[j]);

				bool flag = true;
				rep(j, s.size() / 2) {
					if(s[j] == s[s.size()-1-j]) continue;
					flag = false;
				}

				if(flag) {
					ans++;
					break;
				}
			} while (next_permutation(ret.begin(), ret.end()));
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
</feed>
