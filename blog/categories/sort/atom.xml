<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sort | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/sort/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-10T01:42:35+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM323 D1E-D2M RoadsAndFools]]></title>
    <link href="http://ry0u.github.io/blog/2016/11/18/srm323-d1e-d2m-roadsandfools/"/>
    <updated>2016-11-18T20:50:07+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/11/18/srm323-d1e-d2m-roadsandfools</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6674&rd=10003">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

問題文が全然読めなかった．数列$frontSlides$が与えられて，$frontSlides[i]$または$length - frontSlides[i]$として使える．場所を入れ替えたりせずに，このどちらを選ぶかによって辞書順にしたい．複数可能性があれば$MUPTIPLE\ SOLUTIONS$，唯一解があればそれを空白区切りで区切って，解がない場合は$NO\ SOLUTION$を返す．

---

まずはpairのfirstをそのまま，secondを$length$から引いたものとする．次に全ての要素に対して小さい方をfirstとする．次に辞書順になるように調整していく．$i$番目と$i+1$番目を比較する．first同士で$i+1$の方が大きければ何も変更なしに次を見る．そうでない場合は，$i+1$番目のsecondが$i$番目のfirstよりも大きければ，まだ辞書順を保てる．これもダメだった場合は$NO\ SOLUTION$．  
辞書順に並び変えられたら，どれか一つの要素を反転しても辞書順のままである場合$MUPTIPLE\ SOLUTIONS$，そうではなければそれを文字列に直した．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

class RoadsAndFools {
	public:
	string determineOrientation(int length, vector <int> frontSides) {
		int n = frontSides.size();
		vector<P> v(n);
		rep(i, n) {
			v[i].first = frontSides[i];
			v[i].second = length - frontSides[i];
		}
		rep(i, n) {
			if(v[i].first > v[i].second) swap(v[i].first, v[i].second);
		}

		bool flag = true;
		rep(i, n-1) {
			if(v[i].first < v[i+1].first) continue;
			else if(v[i].first >= v[i+1].first && v[i].first < v[i+1].second) {
				swap(v[i+1].first, v[i+1].second);
			}
			else flag = false;
		}

		if(!flag) return "NO SOLUTION";

		int cnt = 0;
		rep(i, n) {
			if(v[i].first == v[i].second) continue;
			swap(v[i].first, v[i].second);

			bool flag = true;
			rep(j, n-1) {
				if(v[j].first < v[j+1].first) continue;
				flag = false;
			}
			cnt += flag;
			
			swap(v[i].first, v[i].second);
		}

		if(cnt != 0) return "MULTIPLE SOLUTIONS";

		stringstream ss;
		rep(i, n) {
			if(i) ss << " ";
			ss << v[i].first;
		}

		return ss.str();
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM306 D2E SortMachine D1E-D2M BifidSortMachine]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/25/srm306-d2e-sortmachine-d1e-d2m-bifidsortmachine/"/>
    <updated>2016-08-25T13:42:30+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/25/srm306-d2e-sortmachine-d1e-d2m-bifidsortmachine</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6413&rd=9986">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

ある要素を抜き出し末尾に付け加える，という操作のみで数列をソートする時最小何回で出来るか．  
抜き出す順番を変えることでsort出来る($[1, 3, 4, 2]$でも$[1, 4, 3, 2]$でも先に$3$を出してから$4$を出すのは変わらない)ので，sort済みの数列から何番目まであったか(連続しない部分列)を出して，それ以外を出す順番を移動する数の一番小さい方から優先してやっていけば良い．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

class SortMachine {

    public:

    int countMoves(vector <int> a) {
		int n = a.size();
		vector<int> v = a;
		sort(v.begin(), v.end());

		int j = 0;
		rep(i, n) {
			if(a[i] == v[j]) {
				j++;
			}
		}

		return n - j;
    }
};
```

<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6415&rd=9986">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

今度は末尾だけでなく先頭にも付け加えることが出来る．これはさっきの考え方と同じで，先頭の方は逆に先頭に持ってくるものの中で大きいものからやっていけば良いので，sort済みの数列の何番目から初めて何番目まであったかを全探索して，その最小値を取る．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

class BifidSortMachine {

    public:
    int countMoves(vector <int> a) {
		int n = a.size();
		vector<int> v = a;
		v.push_back(INF);
		sort(v.begin(), v.end());

		int ans = INF;
		rep(i, n) {
			int j = i, cnt = 0;
			rep(k, n) {
				if(a[k] == v[j]) {
					cnt++;
					j++;
				}
			}
			ans = min(ans, n - cnt);
		}

		return ans;
    }
};
```
]]></content>
  </entry>
  
</feed>
