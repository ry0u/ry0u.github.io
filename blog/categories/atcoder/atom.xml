<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: atcoder | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/atcoder/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-29T23:14:22+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ABC008C コイン]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/29/abc008c-koin/"/>
    <updated>2016-03-29T22:16:02+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/29/abc008c-koin</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://abc008.contest.atcoder.jp/tasks/abc008_3">C: コイン - AtCoder Beginner Contest 008 | AtCoder</a></h4><p>(null)</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>コインが{% m %} N {% em %}枚与えられる．{% m %} \frac{表になる枚数}{N!} {% em %}を求める．ある数{% m %} i {% em %}枚目が表になるか，裏になるかは{% m %} N {% em %}枚の内，{% m %} C_{i} {% em %}の約数であるものの個数によって変わる．{% m %} i {% em %}枚目が表になる枚数は，表になる確率{% m %} a_{i} {% em %}が分かれば{% m %} N! \cdot a_{i} {% em %}で求まる．よって
{% math %}
\begin{eqnarray}
    \frac{表になる枚数}{N!} &amp;=&amp; \frac{N! \cdot a<em>{1} + N! \cdot a</em>{2} + &hellip; + N! \cdot a<em>{N}}{N!} \
                            &amp;=&amp; \sum</em>{i=1} ^{N} a_{i}
\end{eqnarray}
{% endmath %}
となり， {% m %} a_i {% em %}が求まれば良くなった．{% m %} C_i {% em %}の約数の個数を {% m %} s {% em %}と置き，コインの中で約数と自身のみ( {% m %} s+1個 {% em %})で考える．<br/>
例えば約数をo, 自身をx，約数の個数を{% m %} 3 {% em %}とすると x o o o, o x o o, o o x o, o o o xの {% m %} 4 {% em %}パターンで表になるのは x o o oとo o x oの {% m %} 2 {% em %}パターンである．</p>

<ul>
<li>{% m %} sが奇数の時，表になる確率は\frac{\frac{1}{2}(s + 1)}{(s + 1)} = \frac{1}{2} {% em %}</li>
<li>{% m %} sが偶数の時，表になる確率は\frac{\frac{1}{2}(s + 2)}{(s + 1)} {% em %}</li>
</ul>


<p>後はこれをそれぞれ計算した．</p>

<hr />

<p>色々書いてることが怪しい．後で見直す．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; v(n);
    rep(i, n) cin &gt;&gt; v[i];

    sort(v.begin(), v.end());

    int cnt[105];
    memset(cnt, 0, sizeof(cnt));

    rep(i, n) {
        rep(j, n) {
            if(i == j) continue;
            if(v[i] % v[j] == 0) {
                cnt[i]++;
            }
        }
    }

    double ans = 0;
    rep(i, n) {
        double d = cnt[i];

        if(cnt[i] % 2 == 1) {
            double a = 1 / 2.0;
            ans += a;
        } else {
            double a = ((d + 2) / 2.0) / (d + 1);
            ans += a;
        }

    }

    cout &lt;&lt; fixed;
    cout.precision(20);
    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC043-B 難易度]]></title>
    <link href="http://ry0u.github.io/blog/2015/10/25/arc043-b-nan-yi-du/"/>
    <updated>2015-10-25T01:41:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/10/25/arc043-b-nan-yi-du</id>
    <content type="html"><![CDATA[<p>難易度の2倍以上の問題に対して選ぶことが出来る．<br/>
まずは，難易度でソート．<br/>
今見ている問題数をiとすると，i+1問目でその問題を選ぶことが出来る場所に足していく．</p>

<p>{% img /images/Atcoder/001/g.png %}<br/>
縦を問題，横を問題数と見て，遷移出来る場所を見つけたい．これを愚直に探すと，探索に{% m %} n {% em %}かかってしまう．しかし，難易度でソートされているので，lower_boundで{% m %} log(n) {% em %}で見つけることが出来る．最初に見つけた場所に足していって，累積和を取った．全体で{% m %} O(nlog(n)) {% em %}で間に合う．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair
#define MOD 1000000007

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    ll vmax = 0;
    vector&lt;ll&gt; v(n);
    rep(i,n) {
        cin &gt;&gt; v[i];
        vmax = max(vmax, v[i]);
    }

    sort(v.begin(), v.end());

    ll cnt[100005][4];
    memset(cnt, 0, sizeof(cnt)) ;

    rep(i,n) {
        cnt[i][0]++;
    }

    rep(i,3) {
        rep(j,n) {
            if(v[j]*2 &gt; vmax) continue;
            int id = lower_bound(v.begin(), v.end(), v[j]*2) - v.begin();

            cnt[id][i+1] += cnt[j][i];
            cnt[id][i+1] %= MOD;
        }

        REP(j,1,n) {
            cnt[j][i+1] += cnt[j-1][i+1];
            cnt[j][i+1] %= MOD;
        }
    }

    ll ans = 0;
    rep(i,n) {
        ans += cnt[i][3];
        ans %= MOD;
    }
    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>2倍するので，オーバーフローしてWA．llに直した時に，cntの初期化を消してしまったらしく，それに気づかずWAを連発してしまった．．．</p>
]]></content>
  </entry>
  
</feed>
