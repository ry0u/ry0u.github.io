<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 確率 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/que-lu/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-10T01:42:35+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM304 D1M Conditional]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/24/srm304-d1m-conditional/"/>
    <updated>2016-08-24T00:34:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/24/srm304-d1m-conditional</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6412&rd=9825">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$maxSide$まであるサイコロを$nDice$個振った時，少なくとも$1$つは$v$が出て，$theSum$を超える確率を求める．

---

少なくとも$1$つ$v$が出るという条件が無ければ
```cpp
dp[0][0] = 1.0;
rep(i, nDice) {
	rep(j, 55 * 55) {
		REP(k, 1, maxSide) {
			dp[i+1][j + k] += dp[i][j] * (1.0 / maxSide);
		}
	}
}
```
として，$theSum$以上の和を取れば良いが，この条件がある場合は$v$が出た場合と出ない場合で分ける必要がある．そのためdpを

$$
\begin{eqnarray}
	dp[i][j][0] \&:=\& i個目のサイコロを振って和がjで，一回もvが出ない時の確率 \\\
	dp[i][j][1] \&:=\& i個目のサイコロを振って和がjで，少なくとも一回はvが出た時の確率
\end{eqnarray}
$$

として分けて考える．今まで$v$がでなくて，今回初めて$v$が出た時に$[1]$に遷移する．後は少なくとも$1$つ$v$が出る確率を出して割れば良い．この確率は$(1 - vが一回も出ない確率)$として出した．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

double dp[55][55 * 55][2];

class Conditional {

    public:

    double probability(int nDice, int maxSide, int v, int theSum) {
		memset(dp, 0, sizeof(dp));
		dp[0][0][0] = 1.0;

		rep(i, nDice) {
			rep(j, 55 * 55) {
				REP(k, 1, maxSide + 1) {
					if(j + k >= 55 * 55) continue;
					dp[i+1][j + k][1] += dp[i][j][1] * (1.0 / maxSide);

					if(k == v) {
						dp[i+1][j + k][1] += dp[i][j][0] * (1.0 / maxSide);
					} else {
						dp[i+1][j + k][0] += dp[i][j][0] * (1.0 / maxSide);
					}
				}
			}
		}

		double ans = 0.0;
		REP(i, theSum, 55 * 55) {
			ans += dp[nDice][i][1];
		}

		double t = 1.0;
		rep(i, nDice) {
			t *= double(maxSide - 1) / maxSide;
		}

		return ans / (1 - t);
    }

};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1277 Minimal Backgammon]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj1277-minimal-backgammon/"/>
    <updated>2016-03-18T22:14:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj1277-minimal-backgammon</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1277">Minimal Backgammon</a></h4><p>Here is a very simple variation of the game backgammon, named "Minimal Backgammon". The game is played by only one player, using only one of the dice and only one checker (the token used by the player). The game board is a line of ( N + 1) squares labeled as 0 (the start) to N (the goal).</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

動的計画法．
{% math %}
	dp[i][j] := iターン目にマスjにいる確率
{% endmath %}

とする．{% m %} i {% em %}ターン目にマス{% m %} j {% em %}にいる時にサイコロを振るのは
{% math %}
	dp[i+1][j+k] = dp[i][j] \cdot (1.0 / 6.0);
{% endmath %}
と書ける．一回休みの時は{% m %} dp[i+2][j+k] {% em %}，戻るマスは {% m %} dp[i+1][0] {% em %}に遷移する．{% m %} n {% em %}マスを追い越した時に戻ってくる処理でバグバグした．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

double dp[105][105];

int main() {
	int n, t, l, b;
	while(cin >> n >> t >> l >> b) {
		if(n == 0 && t == 0 && l == 0 && b == 0) break;

		memset(dp, 0, sizeof(dp));

		bool lose[105], back[1005];
		memset(lose, 0, sizeof(lose));
		memset(back, 0, sizeof(back));

		rep(i, l) {
			int x;
			cin >> x;
			lose[x] = true;
		}

		rep(i, b) {
			int x;
			cin >> x;
			back[x] = true;
		}

		memset(dp, 0, sizeof(dp));

		dp[0][0] = 1.0;
		rep(i, t) {
			rep(j, n) {
				if(dp[i][j] == 0.0) continue;
				REP(k, 1, 7) {
					int p = j + k;
					if(p > n) p = n - (p - n);

					if(lose[p]) {
						dp[i+2][p] += dp[i][j] * (1.0 / 6.0);
					} else if(back[p]) {
						dp[i+1][0] += dp[i][j] * (1.0 / 6.0);
					} else {
						dp[i+1][p] += dp[i][j] * (1.0 / 6.0);
					}
				}
			}
		}

		double ans = 0;
		rep(i, t + 1) {
			ans += dp[i][n];
		}

		cout << fixed;
		cout.precision(20);
		cout << ans << endl;
	}

	return 0;
}
```
]]></content>
  </entry>
  
</feed>
