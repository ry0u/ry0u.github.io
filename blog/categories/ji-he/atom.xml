<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 幾何 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/ji-he/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-04-27T23:36:02+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ABC010C 浮気調査]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/03/abc010c-fu-qi-diao-cha/"/>
    <updated>2016-04-03T17:05:27+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/03/abc010c-fu-qi-diao-cha</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-branding="0" data-card-type="article-full"><h4><a href="http://abc010.contest.atcoder.jp/tasks/abc010_3">C: 浮気調査 - AtCoder Beginner Contest 010 | AtCoder</a></h4><p>(null)</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>一人ひとり，その場所に行って電話に出た場所まで <script type="math/tex"> T </script>以内にいけるを試す．移動した距離が <script type="math/tex"> T * V </script>より小さければ可能である．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair
#define EPS 1e-8
#define equals(a,b) fabs((a) - (b)) &lt; EPS

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct Point {
    double x, y;

    Point(double x=0, double y=0) : x(x), y(y) {}

    Point operator+(const Point &amp;o) const { return Point(x+o.x, y+o.y); }

    Point operator-(const Point &amp;o) const { return Point(x-o.x, y-o.y); }

    Point operator*(const double m) const { return Point(x*m, y*m); }

    Point operator/(const double d) const { return Point(x/d, y/d); }

    bool operator&lt;(const Point &amp;o) const { return x != o.x ? x &lt; o.x : y &lt; o.y; }

    bool operator==(const Point &amp;o) const { return fabs(x-o.x) &lt; EPS &amp;&amp; fabs(y-o.y) &lt; EPS; }
};

ostream&amp; operator &lt;&lt; (ostream&amp; os, const Point&amp; p) {
    os &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ")";
    return os;
}

double dot(Point a, Point b) { return a.x * b.x + a.y * b.y; }
double cross(Point a, Point b) { return a.x * b.y - a.y * b.x; }
double atan(Point p) { return atan2(p.y, p.x); }
double norm(Point p) { return p.x * p.x + p.y * p.y; }
double abs(Point p) { return sqrt(norm(p)); }
double distancePP(Point p, Point o) { return sqrt(norm(o - p)); }

int main() {
    Point s, t;
    int T, V;
    cin &gt;&gt; s.x &gt;&gt; s.y &gt;&gt; t.x &gt;&gt; t.y &gt;&gt; T &gt;&gt; V;

    bool flag = false;

    int n;
    cin &gt;&gt; n;

    rep(i, n) {
        Point p;
        cin &gt;&gt; p.x &gt;&gt; p.y;

        if(distancePP(s, p) + distancePP(p, t)  &lt;= T * V) {
            flag = true;
        }
    }

    if(flag) {
        cout &lt;&lt; "YES" &lt;&lt; endl;
    } else {
        cout &lt;&lt; "NO" &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1194 Vampire]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/24/aoj1194-vampire/"/>
    <updated>2016-03-24T00:28:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/24/aoj1194-vampire</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1194">Vampire</a></h4><p>Mr. C is a vampire. If he is exposed to the sunlight directly, he turns into ash. Nevertheless, last night, he attended to the meeting of Immortal and Corpse Programmers Circle, and he has to go home in the near dawn.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>ある点 <script type="math/tex"> (x, y) </script>を端として決めると距離が決まる．Sample Input3を考えると下図のケースが最大である．<br/>
<img src="/images/AOJ/1194.png"></p>

<p>緑の線の長さは <script type="math/tex"> {\rm sqrt} (r ^2 - x ^2) </script>になるので，求めたい赤の線の長さが <script type="math/tex"> r + y - {\rm sqrt}(r ^2 - x ^2) </script>となる．建物が重なっている場所は一番大きい所を見て， <script type="math/tex"> {\rm min}(H[i-1], H[i]) </script>が建物の角となり，その点を端として決めて一番短いものを答える．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int r, n;
    while(cin &gt;&gt; r &gt;&gt; n) {

        if(r == 0 &amp;&amp; n == 0) break;

        vector&lt;pair&lt;int, P&gt; &gt; v(n);
        rep(i, n) cin &gt;&gt; v[i].second.first &gt;&gt; v[i].second.second &gt;&gt; v[i].first;

        int H[60], GETA = 30;
        memset(H, 0, sizeof(H));

        rep(i, n) {
            int h = v[i].first, x1 = v[i].second.first, x2 = v[i].second.second;

            REP(j, x1, x2) {
                H[j + GETA] = max(H[j + GETA], h);
            }
        }

        double ans = INF;
        REP(i, -r+1, r) {
            double res = r + min(H[i + GETA], H[i - 1 + GETA]);
            ans = min(ans, res - sqrt(r*r - i*i));
        }

        cout &lt;&lt; fixed;
        cout.precision(4);
        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2641 Magic Bullet]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj2641-magic-bullet/"/>
    <updated>2016-03-22T21:29:19+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj2641-magic-bullet</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2641">Magic Bullet | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>点<script type="math/tex"> (sx, sy, sz) </script>，点 <script type="math/tex"> (dx, dy, dz) </script>を結ぶ線分が<script type="math/tex"> N </script>個の球と交差しているかを見る．それぞれの球の中心から直線への射影を出す．その点が線分に収まっていて，球の中心との距離がr以内なら交差しているとした．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair
#define EPS 1e-8
#define equals(a,b) fabs((a) - (b)) &lt; EPS

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct Point3D {
    double x, y, z;

    Point3D() : x(0), y(0), z(0) {}

    Point3D(double x, double y, double z) : x(x), y(y), z(z) {}

    Point3D operator+(const Point3D &amp;o) const { return Point3D(x+o.x, y+o.y, z+o.z); }

    Point3D operator-(const Point3D &amp;o) const { return Point3D(x-o.x, y-o.y, z-o.z); }

    Point3D operator*(const double m) const { return Point3D(x*m, y*m, z*m); }

    Point3D operator/(const double d) const { return Point3D(x/d, y/d, z/d); }

    bool operator==(const Point3D &amp;o) const { return fabs(x-o.x) &lt; EPS &amp;&amp; fabs(y-o.y) &lt; EPS; }
};

ostream&amp; operator &lt;&lt; (ostream&amp; os, const Point3D&amp; p) {
    os &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ", " &lt;&lt; p.z &lt;&lt; ")";
    return os;
}

double dot(Point3D a, Point3D b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
Point3D cross(Point3D a, Point3D b) { return Point3D(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x); }

double norm(Point3D p) { return dot(p, p); }
double abs(Point3D p) { return sqrt(norm(p)); }

struct Line {
    Point3D a, b;

    Line() : a(Point3D(0, 0, 0)), b(Point3D(0, 0, 0)) {}

    Line(Point3D a, Point3D b) : a(a), b(b) {}
};

ostream&amp; operator &lt;&lt; (ostream&amp; os, const Line&amp; l) {
    os &lt;&lt; "(" &lt;&lt; l.a.x &lt;&lt; ", " &lt;&lt; l.a.y &lt;&lt; ", " &lt;&lt; l.a.z &lt;&lt;  ")-(" &lt;&lt; l.b.x &lt;&lt; "," &lt;&lt; l.b.y &lt;&lt; ", " &lt;&lt; l.b.z &lt;&lt;  ")";
    return os;
}

Point3D project(Line l, Point3D p) {
    Point3D base = l.b - l.a;
    double t = dot(base, p-l.a) / dot(base, base);
    return l.a + base * t;
}

struct Ball {
    Point3D p;
    double r;

    Ball() : p(Point3D(0, 0, 0)), r(0.0) {}

    Ball(Point3D p, double r) : p(p), r(r) {}
};

ostream&amp; operator &lt;&lt; (ostream&amp; os, const Ball&amp; b) {
    os &lt;&lt; "(" &lt;&lt; b.p.z &lt;&lt; ", " &lt;&lt; b.p.y &lt;&lt; ", " &lt;&lt; b.p.z &lt;&lt; " :" &lt;&lt; b.r &lt;&lt; ")";
    return os;
}

int main() {
    int n, q;
    cin &gt;&gt; n &gt;&gt; q;

    vector&lt;Ball&gt; v(n);
    vector&lt;ll&gt; cost(n);
    rep(i, n) {
        cin &gt;&gt; v[i].p.x &gt;&gt; v[i].p.y &gt;&gt; v[i].p.z &gt;&gt; v[i].r &gt;&gt; cost[i];
    }

    rep(i, q) {
        ll ans = 0;
        Point3D s, t;
        cin &gt;&gt; s.x &gt;&gt; s.y &gt;&gt; s.z &gt;&gt; t.x &gt;&gt; t.y &gt;&gt; t.z;

        Line line(s, t);

        rep(j, n) {
            Point3D proj = project(line, v[j].p);

            if(abs(line.b - line.a) &gt;= abs(proj - line.a) &amp;&amp; abs(line.a - line.b) &gt;= abs(proj - line.b)) {
                if(abs(proj - v[j].p) &lt; v[j].r + EPS) {
                    ans += cost[j];
                }
            }
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yukicoder No.55 正方形を描くだけの簡単なお仕事です]]></title>
    <link href="http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-55-zheng-fang-xing-womiao-kudakefalsejian-dan-naoshi-shi-desu/"/>
    <updated>2015-09-03T14:28:18+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-55-zheng-fang-xing-womiao-kudakefalsejian-dan-naoshi-shi-desu</id>
    <content type="html"><![CDATA[<p><a href="http://yukicoder.me/problems/83">http://yukicoder.me/problems/83</a></p>

<p>Sample1
<img src="/images/yukicoder/055/1.png">
Sample2 この3点では正方形が出来ない
<img src="/images/yukicoder/055/2.png">
Sample3
<img src="/images/yukicoder/055/3.png">
Sample4
<img src="/images/yukicoder/055/4.png"></p>

<h1>考察</h1>

<p>3点が与えられ，正方形となるもう1点を答えるのだが，正方形がx軸，y軸に平行でなくてもいい．3点の中で最も2点間の距離が長いものを線分として，もう1点をその線分に対して対象な点を求めた．</p>

<p>サンプル3を考える．
<img src="/images/yukicoder/055/5.png">
一番長い線分を見つける．
<img src="/images/yukicoder/055/6.png">
この線分に対し，対象な点を取る．
<img src="/images/yukicoder/055/7.png">
正方形の完成．
<img src="/images/yukicoder/055/8.png"></p>

<p>このままではひし型も作れてしまうので，与えられた3点によって出来る三角形が二等辺三角形かつ，短い辺の<script type="math/tex"> \sqrt{2} </script>が，長い辺となる時のみ行う．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair
#define EPS 1e-8
#define equals(a,b) fabs((a) - (b)) &lt; EPS

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct Point {
    double x, y;

    Point(double x=0, double y=0) : x(x), y(y) {}

    Point operator+(const Point &amp;o) const { return Point(x+o.x, y+o.y); }

    Point operator-(const Point &amp;o) const { return Point(x-o.x, y-o.y); }

    Point operator*(const double m) const { return Point(x*m, y*m); }

    Point operator/(const double d) const { return Point(x/d, y/d); }

    bool operator&lt;(const Point &amp;o) const { return x != o.x ? x &lt; o.x : y &lt; o.y; }

    bool operator==(const Point &amp;o) const { return fabs(x-o.x) &lt; EPS &amp;&amp; fabs(y-o.y) &lt; EPS; }

    double cross(const Point &amp;o) const { return x * o.y - y * o.x; }

    double dot(const Point &amp;o) const { return x * o.x + y * o.y; }

    double atan() const { return atan2(y, x); }

    double norm() const { return sqrt(dot(*this)); }

    double distance(const Point &amp;o) const { return (o - (*this)).norm(); }

    double area(const Point &amp;a,const Point &amp;b) {
        Point p = a - (*this), p2 = b - (*this); 
        return p.cross(p2);
    }

    double area_abs(const Point &amp;a,const Point &amp;b) const {
        Point p = a - (*this), p2 = b - (*this);
        return fabs(p.cross(p2)) / 2.0;
    }   

    //線分abが自身に含まれているのかどうか判断する
    int between(const Point &amp;a,const Point &amp;b) {
        if(area(a,b) != 0) return 0;

        if(a.x != b.x)  return ((a.x &lt;= x) &amp;&amp; (x &lt;= b.x) || (a.x &gt;= x) &amp;&amp; (x &gt;= b.x));
        else return ((a.y &lt;= y) &amp;&amp; (y &lt;= b.y) || (a.y &gt;= y) &amp;&amp; (y &gt;= b.y));
    }      

    double distance_seg(const Point&amp; a,const Point&amp; b) {
        if((b-a).dot(*this-a) &lt; EPS) {
            return (*this-a).norm();
        }
        if((a-b).dot(*this-b) &lt; EPS) {
            return (*this-b).norm();
        }
        return abs((b-a).cross(*this-a)) / (b-a).norm();
    }

    bool hitPolygon(const Point&amp; a,const Point&amp; b,const Point&amp; c) {
        double t = (b-a).cross(*this-b);
        double t2 = (c-b).cross(*this-c);
        double t3 = (a-c).cross(*this-a);   

        if((t &gt; 0 &amp;&amp; t2 &gt; 0 &amp;&amp; t3 &gt; 0) || ( t &lt; 0 &amp;&amp; t2 &lt; 0 &amp;&amp; t3 &lt; 0)) {
            return true;
        }

        return false;
    }
};

struct Seg {
    Point a,b;

    Seg (Point a, Point b) : a(a),b(b) {}

    bool isOrthogonal(Seg &amp;s) { return equals((b - a).dot(s.b - s.a),0.0); }

    bool isParallel(Seg &amp;s) { return equals((b-a).cross(s.b - s.a),0.0); }

    bool isIntersect(Seg &amp;s) {
        if(s.a.between(a,b) || s.b.between(a,b) || a.between(s.a,s.b) || b.between(s.a,s.b)) {
            return true;
        }
        return ((a-b).cross(s.a-a) * (a-b).cross(s.b-a) &lt; EPS) &amp;&amp; ((s.b-s.a).cross(a-s.a)*(s.b-s.a).cross(b-s.a) &lt; EPS);
    }

    bool distance(Seg &amp;s) {
        if((*this).isIntersect(s)) return 0.0;

        return min(min(a.distance_seg(s.a,s.b),b.distance_seg(s.a,s.b)),min(s.a.distance_seg(a,b),s.b.distance_seg(a,b)));
    }

    Point getCrossPoint(Seg &amp;s) {
        Point p = s.b - s.a;
        double d = abs(p.cross(a-s.a));
        double d2 = abs(p.cross(b-s.a));

        double t = d / (d+d2);
        return a + (b-a)*t;
    }

    Point project(Point &amp;p) {
        Point base = b - a;
        double t = base.dot(p-a) / base.dot(base);
        return a + base * t;
    }

    Point reflect(Point &amp;p) {
        return p + (project(p) - p) * 2.0;
    }
};

int main() {
    vector&lt;Point&gt; v(3);
    set&lt;int&gt; id;
    rep(i,3) {
        cin &gt;&gt; v[i].x &gt;&gt; v[i].y;
        id.insert(i);
    }

    set&lt;double&gt; st;
    double len = 0, d = INF;
    rep(i,3) {
        int j = (i+1) % 3;
        double dist = v[i].distance(v[j]);
        len = max(len, dist);
        d = min(d, dist);
        st.insert(dist);
    }

    if(st.size() == 2 &amp;&amp; equals(2*d*d,len*len)) {
        int s = 0, t = 0;
        rep(i,3) {
            int j = (i+1) % 3;
            if(len == v[i].distance(v[j])) {
                id.erase(i);
                id.erase(j);
                s = i;
                t = j;
                break;
            }
        }

        Seg seg(v[s],v[t]);
        Point p = seg.reflect(v[*(id.begin())]);
        cout &lt;&lt; (int)p.x &lt;&lt; " " &lt;&lt; (int)p.y &lt;&lt; endl;

    } else {
        cout &lt;&lt; -1 &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hide-and-Seek Supporting System]]></title>
    <link href="http://ry0u.github.io/blog/2015/08/28/hide-and-seek-supporting-system/"/>
    <updated>2015-08-28T02:23:10+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/08/28/hide-and-seek-supporting-system</id>
    <content type="html"><![CDATA[<p><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0129">http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0129</a></p>

<p>サンプル1<br/>
<img src="/images/AOJ/0129.png"></p>

<p>円に接してる場合は，Safe判定となる．</p>

<h1>考察</h1>

<p>円の中心と，線分の関係を見る．Dangerの場合は線分の端点両方が円内包されていない，かつ円の中心と線分の距離が円の半径よりも小さい時である．前回，この問題を取り組んだ時はWAを連発したが，今回はACすることが出来た．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair
#define EPS 1e-8
#define equals(a,b) fabs((a) - (b)) &lt; EPS

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct Point {
    double x, y;

    Point(double x=0, double y=0) : x(x), y(y) {}

    Point operator+(const Point &amp;o) const { return Point(x+o.x, y+o.y); }

    Point operator-(const Point &amp;o) const { return Point(x-o.x, y-o.y); }

    Point operator*(const double m) const { return Point(x*m, y*m); }

    Point operator/(const double d) const { return Point(x/d, y/d); }

    bool operator&lt;(const Point &amp;o) const { return x != o.x ? x &lt; o.x : y &lt; o.y; }

    bool operator==(const Point &amp;o) const { return fabs(x-o.x) &lt; EPS &amp;&amp; fabs(y-o.y) &lt; EPS; }

    double cross(const Point &amp;o) const { return x * o.y - y * o.x; }

    double dot(const Point &amp;o) const { return x * o.x + y * o.y; }

    double atan() const { return atan2(y, x); }

    double norm() const { return sqrt(dot(*this)); }

    double distance(const Point &amp;o) const { return (o - (*this)).norm(); }

    double area(const Point &amp;a,const Point &amp;b) {
        Point p = a - (*this), p2 = b - (*this); 
        return p.cross(p2);
    }

    double area_abs(const Point &amp;a,const Point &amp;b) const {
        Point p = a - (*this), p2 = b - (*this);
        return fabs(p.cross(p2)) / 2.0;
    }   

    //線分abが自身に含まれているのかどうか判断する
    int between(const Point &amp;a,const Point &amp;b) {
        if(area(a,b) != 0) return 0;

        if(a.x != b.x)  return ((a.x &lt;= x) &amp;&amp; (x &lt;= b.x) || (a.x &gt;= x) &amp;&amp; (x &gt;= b.x));
        else return ((a.y &lt;= y) &amp;&amp; (y &lt;= b.y) || (a.y &gt;= y) &amp;&amp; (y &gt;= b.y));
    }      

    double distance_seg(const Point&amp; a,const Point&amp; b) {
        if((b-a).dot(*this-a) &lt; EPS) {
            return (*this-a).norm();
        }
        if((a-b).dot(*this-b) &lt; EPS) {
            return (*this-b).norm();
        }
        return abs((b-a).cross(*this-a)) / (b-a).norm();
    }

    bool hitPolygon(const Point&amp; a,const Point&amp; b,const Point&amp; c) {
        double t = (b-a).cross(*this-b);
        double t2 = (c-b).cross(*this-c);
        double t3 = (a-c).cross(*this-a);   

        if((t &gt; 0 &amp;&amp; t2 &gt; 0 &amp;&amp; t3 &gt; 0) || ( t &lt; 0 &amp;&amp; t2 &lt; 0 &amp;&amp; t3 &lt; 0)) {
            return true;
        }

        return false;
    }
};

struct Circle {
    Point p;
    double r;

    Circle() : p(Point(0,0)), r(0) {}

    Circle(Point o, double r) : p(o), r(r) {}

    Circle(double x,double y, double r) : p(Point(x,y)), r(r) {}

    bool isCircleIn(const Point&amp; o) {
        Point res = o-p;
        return res.dot(res) &lt; r*r + EPS;
    }

    // 1:外で接する，0:交差なし，-1:内で接する，2:交差，-2:内包
    int isIntersect(const Circle&amp; c) {
        double d = (c.p - p).dot(c.p - p);
        double len = (c.r + r) * (c.r + r);

        if(equals(d,len)) return 1;
        if(d &gt; len) return 0;

        double R = fabs(c.r - r) * fabs(c.r - r);
        if(equals(d,R)) return -1;
        if(d &gt; R) return 2;
        return -2;
    }

    vector&lt;Point&gt; getCrossPoint(const Circle&amp; c) {
        vector&lt;Point&gt; ret;
        int ch = isIntersect(c);

        if(ch == 0 || ch == -2) return ret;

        Point base = c.p - p;
        double len = base.dot(base);
        double t = (r*r - c.r*c.r + len) / (2.0 * len);

        if(ch == 2) {
            Point n(-base.y,base.x);
            n = n / (n.norm());
            double h = sqrt(r * r - t*t*len);

            ret.push_back(p + (base*t) + (n*h));
            ret.push_back(p + (base*t) - (n*h));
        } else {
            ret.push_back(p + (base*t));
        }

        return ret;
    }
};

int main() {
    int n,m;

    while(cin &gt;&gt; n &amp;&amp; n) {
        vector&lt;Circle&gt; v;
        rep(i,n) {
            double x,y,r;
            cin &gt;&gt; x &gt;&gt; y &gt;&gt; r;

            v.push_back(Circle(x,y,r));
        }

        int m;
        cin &gt;&gt; m;

        rep(q,m) {
            Point t,o;
            cin &gt;&gt; t.x &gt;&gt; t.y &gt;&gt; o.x &gt;&gt; o.y;

            bool flag = true;

            rep(i,n) {
                if(v[i].isCircleIn(t) &amp;&amp; v[i].isCircleIn(o)) {
                    continue;
                } else if(!v[i].isCircleIn(t) &amp;&amp; !v[i].isCircleIn(o)) {
                    double d = v[i].p.distance_seg(t,o);
                    if(d &lt; v[i].r + EPS) flag = false;
                } else {
                    flag = false;
                }
            }

            if(flag) cout &lt;&lt; "Danger" &lt;&lt; endl;
            else cout &lt;&lt; "Safe" &lt;&lt; endl;
        }
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
