<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 幾何 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/ji-he/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-09-03T02:19:57+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM304 D1E-D2H PolyMove]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/23/srm304-d1e-d2h-polymove/"/>
    <updated>2016-08-23T23:43:47+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/23/srm304-d1e-d2h-polymove</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6190&rd=9825">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

凸包が与えられる．隣り合わない点を選び，距離が$1$以下なら移動することができる．この条件の時に最大面積の増加分を答える

---
正六角形の場合を考えてみた．

{% img /images/SRM/304-01.png %}

右上の点について考える．

{% img /images/SRM/304-02.png %}

まずは移動しない場合の青の部分の面積を出してみる．

{% img /images/SRM/304-03.png %}

この面積を出すには赤の線を底辺$a$として，緑の線を高さ$h$とすると，$\frac{ah}{2}$である．

{% img /images/SRM/304-05.png %}

ここからこの点を移動することを考えるが，移動後の三角形もこの式で計算出来るため$h$を最大にすれば良い．最大の$h$とは，底辺に対して垂直に伸ばせば良いので，新しい三角形の高さは$h + 1$となる．つまり緑の点の場所に移動する．

{% img /images/SRM/304-06.png %}

次に面積の増加分を求める．増加した部分は緑の場所である．

{% img /images/SRM/304-07.png %}

これは移動後の三角形(赤)から移動前の三角形(青)を引けば出てくる．

{% img /images/SRM/304-08.png %}
{% img /images/SRM/304-09.png %}
{% img /images/SRM/304-10.png %}

$\frac{a(h + 1)}{2} - \frac{ah}{2} = \frac{a}{2}$となり，高さが分かる必要がないことが分かる．後は移動する点が隣り合わないという条件を満たすようにdpで計算していく．

$$
	dp[i][j] := 点\_{i}まで見て，点\_{i}を移動した場合はj=1, していない場合はj=0とした時の増加分の最大
$$

$0$と$n-1$番目が隣接しているため，$0$を使って$n-1$を見ないパターンと，$1$から始めて$n-1$まで見るパターンをやる．下の図は移動した場合の点が緑で，遷移が線となる．割り当てた状態をtextで書いてみた．

{% img /images/SRM/304-14.png %}

この場合は以下の$2$つが答えとなる．

{% img /images/SRM/304-12.png %}
{% img /images/SRM/304-13.png %}

# Code

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

double dp[55][2];

class PolyMove {
	public:
	double addedArea(vector <int> x, vector <int> y) {
		int n = x.size();
		memset(dp, 0, sizeof(dp));

		REP(i, 1, n) {
			int j = (i - 1 + n) % n;
			int k = (i + 1 + n) % n;

			dp[i][0] = max(dp[j][0], dp[j][1]);
			dp[i][1] = dp[j][0] + sqrt((x[j] - x[k]) * (x[j] - x[k]) + (y[j] - y[k]) * (y[j] - y[k]));
		}

		double ans = 0;
		rep(i, n) {
			rep(j, 2) {
				ans = max(ans, dp[i][j]);
			}
		}

		memset(dp, 0, sizeof(dp));
		rep(i, n - 1) {
			int j = (i - 1 + n) % n;
			int k = (i + 1 + n) % n;

			dp[i][0] = max(dp[j][0], dp[j][1]);
			dp[i][1] = dp[j][0] + sqrt((x[j] - x[k]) * (x[j] - x[k]) + (y[j] - y[k]) * (y[j] - y[k]));
		}

		rep(i, n) {
			rep(j, 2) {
				ans = max(ans, dp[i][j]);
			}
		}

		return ans / 2;
	}
};
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces352-div2C Recycling Bottles]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/12/codeforces352-div2-recycling-bottles/"/>
    <updated>2016-05-12T14:55:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/12/codeforces352-div2-recycling-bottles</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/672/problem/C">Problem - C - Codeforces</a></h4><p>It was recycling day in Kekoland. To celebrate it Adil and Bera went to Central Perk where they can take bottles from the ground and put them into a recycling bin. We can think Central Perk as coordinate plane. There are n bottles on the ground, the i-th bottle is located at position .</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

荷物は一個しか持てないので，毎回拾って戻して，拾って戻してを繰り返す．なので，まずそれぞれから {% m %} (tx, ty) {% em %}から行く道と帰る道を両方張る．それから {% m %} a {% em %}が最初に拾った方が良いものがあれば拾う． {% m %} b {% em %}が最初に拾った方が良いものがあれば拾う．とする  
また，{% m %} a {% em %}が動かず {% m %} b {% em %}が全部拾う場合や， {% m %} a {% em %}が動かず {% m %} b {% em %}が拾う場合がある．最初に拾う点を選んでむしろ距離が増えてしまった場合は，その場に立ち止まるようにする．  
また距離の初期値のINFがオーバーフローした．制約に気を付けたい．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1LL<<60
#define pb push_back
#define mp make_pair
#define EPS 1e-8

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

struct Point {
	double x, y;

	Point(double x=0, double y=0) : x(x), y(y) {}

	Point operator+(const Point &o) const { return Point(x+o.x, y+o.y); }

	Point operator-(const Point &o) const { return Point(x-o.x, y-o.y); }

	Point operator*(const double m) const { return Point(x*m, y*m); }

	Point operator/(const double d) const { return Point(x/d, y/d); }

	bool operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }

	bool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }
};

ostream& operator << (ostream& os, const Point& p) {
	os << "(" << p.x << ", " << p.y << ")";
	return os;
}

double dot(Point a, Point b) { return a.x * b.x + a.y * b.y; }
double cross(Point a, Point b) { return a.x * b.y - a.y * b.x; }
double atan(Point p) { return atan2(p.y, p.x); }
double norm(Point p) { return p.x * p.x + p.y * p.y; }
double abs(Point p) { return sqrt(norm(p)); }
double distancePP(Point p, Point o) { return sqrt(norm(o - p)); }

int main() {
	Point a, b, t;
	cin >> a.x >> a.y >> b.x >> b.y >> t.x >> t.y;

	int n;
	cin >> n;

	vector<Point> v(n);
	rep(i, n) cin >> v[i].x >> v[i].y;

	double sum = 0;
	rep(i, n) {
		sum += distancePP(t, v[i]) * 2;
	}

	double A = sum, B = sum;
	{
		double len = -INF;
		int id = -1;
		rep(i, n) {
			double p = distancePP(t, v[i]);
			double q = distancePP(a, v[i]);

			if(p - q > len) {
				len = p - q;
				id = i;
			}
		}

		double len2 = 0;
		int id2 = -1;
		rep(i, n) {
			if(i == id) continue;

			double p = distancePP(t, v[i]);
			double q = distancePP(b, v[i]);

			if(p - q > len2) {
				len2 = p - q;
				id2 = i;
			}
		}

		// cout <<  " A -> B" << endl;
		// cout << id << " " << id2 << endl;
		// cout << "sum:" << sum << endl;
		// cout << distancePP(t, v[id]) << " " << distancePP(a, v[id]) << " " << len << endl;
		// cout << distancePP(t, v[id2]) << " " << distancePP(b, v[id2]) << " " << len2 << endl;

		if(id != -1) A -= len;
		if(id2 != -1) A -= len2;
	}
	{
		double len = -INF;
		int id = -1;

		rep(i, n) {
			double p = distancePP(t, v[i]);
			double q = distancePP(b, v[i]);

			if(p - q > len) {
				len = p - q;
				id = i;
			}
		}

		double len2 = 0;
		int id2 = -1;
		rep(i, n) {
			if(i == id) continue;

			double p = distancePP(t, v[i]);
			double q = distancePP(a, v[i]);

			if(p - q > len2) {
				len2 = p - q;
				id2 = i;
			}
		}

		// cout <<  " B -> A" << endl;
		// cout << id << " " << id2 << endl;
		// cout << "sum:" << sum << endl;
		// cout << distancePP(t, v[id]) << " " << distancePP(b, v[id]) << " " << len << endl;
		// cout << distancePP(t, v[id2]) << " " << distancePP(a, v[id2]) << " " << len2 << endl;

		if(id != -1) B -= len;
		if(id2 != -1) B -= len2;
	}

	cout << fixed;
	cout.precision(20);
	cout << min(A, B) << endl;

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC010C 浮気調査]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/03/abc010c-fu-qi-diao-cha/"/>
    <updated>2016-04-03T17:05:27+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/03/abc010c-fu-qi-diao-cha</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-branding="0" data-card-type="article-full"><h4><a href="http://abc010.contest.atcoder.jp/tasks/abc010_3">C: 浮気調査 - AtCoder Beginner Contest 010 | AtCoder</a></h4><p>(null)</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

一人ひとり，その場所に行って電話に出た場所まで {% m %} T {% em %}以内にいけるを試す．移動した距離が {% m %} T * V {% em %}より小さければ可能である．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair
#define EPS 1e-8
#define equals(a,b) fabs((a) - (b)) < EPS

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

struct Point {
	double x, y;

	Point(double x=0, double y=0) : x(x), y(y) {}

	Point operator+(const Point &o) const { return Point(x+o.x, y+o.y); }

	Point operator-(const Point &o) const { return Point(x-o.x, y-o.y); }

	Point operator*(const double m) const { return Point(x*m, y*m); }

	Point operator/(const double d) const { return Point(x/d, y/d); }

	bool operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }

	bool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }
};

ostream& operator << (ostream& os, const Point& p) {
	os << "(" << p.x << ", " << p.y << ")";
	return os;
}

double dot(Point a, Point b) { return a.x * b.x + a.y * b.y; }
double cross(Point a, Point b) { return a.x * b.y - a.y * b.x; }
double atan(Point p) { return atan2(p.y, p.x); }
double norm(Point p) { return p.x * p.x + p.y * p.y; }
double abs(Point p) { return sqrt(norm(p)); }
double distancePP(Point p, Point o) { return sqrt(norm(o - p)); }

int main() {
	Point s, t;
	int T, V;
	cin >> s.x >> s.y >> t.x >> t.y >> T >> V;

	bool flag = false;

	int n;
	cin >> n;

	rep(i, n) {
		Point p;
		cin >> p.x >> p.y;

		if(distancePP(s, p) + distancePP(p, t)  <= T * V) {
			flag = true;
		}
	}

	if(flag) {
		cout << "YES" << endl;
	} else {
		cout << "NO" << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1194 Vampire]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/24/aoj1194-vampire/"/>
    <updated>2016-03-24T00:28:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/24/aoj1194-vampire</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1194">Vampire</a></h4><p>Mr. C is a vampire. If he is exposed to the sunlight directly, he turns into ash. Nevertheless, last night, he attended to the meeting of Immortal and Corpse Programmers Circle, and he has to go home in the near dawn.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

ある点 {% m %} (x, y) {% em %}を端として決めると距離が決まる．Sample Input3を考えると下図のケースが最大である．  
{% img /images/AOJ/1194.png %}

緑の線の長さは {% m %} {\rm sqrt} (r ^2 - x ^2) {% em %}になるので，求めたい赤の線の長さが {% m %} r + y - {\rm sqrt}(r ^2 - x ^2) {% em %}となる．建物が重なっている場所は一番大きい所を見て， {% m %} {\rm min}(H[i-1], H[i]) {% em %}が建物の角となり，その点を端として決めて一番短いものを答える．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int r, n;
	while(cin >> r >> n) {

		if(r == 0 && n == 0) break;

		vector<pair<int, P> > v(n);
		rep(i, n) cin >> v[i].second.first >> v[i].second.second >> v[i].first;

		int H[60], GETA = 30;
		memset(H, 0, sizeof(H));

		rep(i, n) {
			int h = v[i].first, x1 = v[i].second.first, x2 = v[i].second.second;

			REP(j, x1, x2) {
				H[j + GETA] = max(H[j + GETA], h);
			}
		}

		double ans = INF;
		REP(i, -r+1, r) {
			double res = r + min(H[i + GETA], H[i - 1 + GETA]);
			ans = min(ans, res - sqrt(r*r - i*i));
		}

		cout << fixed;
		cout.precision(4);
		cout << ans << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2641 Magic Bullet]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj2641-magic-bullet/"/>
    <updated>2016-03-22T21:29:19+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj2641-magic-bullet</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2641">Magic Bullet | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

点{% m %} (sx, sy, sz) {% em %}，点 {% m %} (dx, dy, dz) {% em %}を結ぶ線分が{% m %} N {% em %}個の球と交差しているかを見る．それぞれの球の中心から直線への射影を出す．その点が線分に収まっていて，球の中心との距離がr以内なら交差しているとした．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair
#define EPS 1e-8
#define equals(a,b) fabs((a) - (b)) < EPS

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

struct Point3D {
	double x, y, z;

	Point3D() : x(0), y(0), z(0) {}

	Point3D(double x, double y, double z) : x(x), y(y), z(z) {}

	Point3D operator+(const Point3D &o) const { return Point3D(x+o.x, y+o.y, z+o.z); }

	Point3D operator-(const Point3D &o) const { return Point3D(x-o.x, y-o.y, z-o.z); }

	Point3D operator*(const double m) const { return Point3D(x*m, y*m, z*m); }

	Point3D operator/(const double d) const { return Point3D(x/d, y/d, z/d); }

	bool operator==(const Point3D &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }
};

ostream& operator << (ostream& os, const Point3D& p) {
	os << "(" << p.x << ", " << p.y << ", " << p.z << ")";
	return os;
}

double dot(Point3D a, Point3D b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
Point3D cross(Point3D a, Point3D b) { return Point3D(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x); }

double norm(Point3D p) { return dot(p, p); }
double abs(Point3D p) { return sqrt(norm(p)); }

struct Line {
	Point3D a, b;

	Line() : a(Point3D(0, 0, 0)), b(Point3D(0, 0, 0)) {}

	Line(Point3D a, Point3D b) : a(a), b(b) {}
};

ostream& operator << (ostream& os, const Line& l) {
	os << "(" << l.a.x << ", " << l.a.y << ", " << l.a.z <<  ")-(" << l.b.x << "," << l.b.y << ", " << l.b.z <<  ")";
	return os;
}

Point3D project(Line l, Point3D p) {
	Point3D base = l.b - l.a;
	double t = dot(base, p-l.a) / dot(base, base);
	return l.a + base * t;
}

struct Ball {
	Point3D p;
	double r;

	Ball() : p(Point3D(0, 0, 0)), r(0.0) {}

	Ball(Point3D p, double r) : p(p), r(r) {}
};

ostream& operator << (ostream& os, const Ball& b) {
	os << "(" << b.p.z << ", " << b.p.y << ", " << b.p.z << " :" << b.r << ")";
	return os;
}

int main() {
	int n, q;
	cin >> n >> q;

	vector<Ball> v(n);
	vector<ll> cost(n);
	rep(i, n) {
		cin >> v[i].p.x >> v[i].p.y >> v[i].p.z >> v[i].r >> cost[i];
	}

	rep(i, q) {
		ll ans = 0;
		Point3D s, t;
		cin >> s.x >> s.y >> s.z >> t.x >> t.y >> t.z;

		Line line(s, t);

		rep(j, n) {
			Point3D proj = project(line, v[j].p);

			if(abs(line.b - line.a) >= abs(proj - line.a) && abs(line.a - line.b) >= abs(proj - line.b)) {
				if(abs(proj - v[j].p) < v[j].r + EPS) {
					ans += cost[j];
				}
			}
		}

		cout << ans << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
</feed>
