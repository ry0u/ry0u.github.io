<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: トポロジカル順序 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/toporozikarushun-xu/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-10T01:42:35+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM317 D2H OrdringCount]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/26/srm317-d2h-ordringcount/"/>
    <updated>2016-10-26T15:18:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/26/srm317-d2h-ordringcount</id>
    <content type="html"><![CDATA[<!-- more -->

グラフが与えられるのでトポロジカル順序の個数を答える．  
逆から考えていく．トポロジカル順序として一番最後となるのは，出次数が0のノードとなる．既に決めた頂点数集合$S$をbitとして持ち，

$$
	dp[S] := 頂点集合Sをトポロジカルソートする方法の数
$$

とする．逆から見て，この頂点集合$S$の次に選べるものは，頂点の隣接しているのものが頂点集合の中に既に含まれているか，隣接しているノードが無いかのどちらかである．最終的に$dp[(1<<n)-1]$が答えとなる．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

ll dp[1<<21];

class OrderingCount {
	public:
	long long countOrderings(vector <string> req) {
		int n = req.size();

		memset(dp, 0, sizeof(dp));
		dp[0] = 1;

		rep(i, 1<<n) {
			rep(j, n) {
				if(i & (1 << j)) continue;

				bool flag = true;
				rep(k, n) {
					if(i & (1 << k)) continue;
					if(req[j][k] == 'Y') flag = false;
				}

				if(flag) {
					dp[i | (1 << j)] += dp[i];
				}
			}
		}

		return dp[(1<<n)-1];
	}
};
```
]]></content>
  </entry>
  
</feed>
