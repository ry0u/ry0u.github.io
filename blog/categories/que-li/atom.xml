<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 確立 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/que-li/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-10T01:42:35+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM318 D2H SimplifiedDarts]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/27/srm318-d2h-simplifieddarts/"/>
    <updated>2016-10-27T01:04:06+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/27/srm318-d2h-simplifieddarts</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6685&rd=9998">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

ダーツの投げる場所が$2$つあり，短い距離で投げてあたった場合は$2$点，長い距離で投げてあたった場合は$3$点貰える．それぞれ当たる確立は$P1$%, $P2$%である．$N$回投げて，$W$点以上取った時の確立を求めたい．

$$
	dp[i][j] := i回投げてj点以上取った時の確立
$$

として動的計画法．短い距離の場合で$dp[i][j]$に遷移するのは，$i-1$回目に投げて$j-2$点だった時に投げてあたった場合と，$i-1$回目に既に$j$点取っていてはずした場合の和である．同様に長い距離の場合で$dp[i][j]$に遷移するのは$i-1$回目に投げて$j-3$点だった時に投げてあたった場合と，$i-1$回目に既に$j$点取っていてはずした場合の和である．この時，$W$点以上の確立も考慮しなければならない．例えば$W+2$点取る確立(以上ではない)は$-2$から遷移がスタートして$W$に来たと考える事ができるので，遷移元が配列外参照となる場合は単純に$1$として考えてあげれば大丈夫．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

double dp[1005][3005];

class SimplifiedDarts {
	public:
	double tryToWin(int W, int N, int P1, int P2) {
		double p1 = P1 / (100.0);
		double p2 = P2 / (100.0);

		memset(dp, 0, sizeof(dp));
		
		rep(i, N + 1) 
			dp[i][0] = 1.0;
		
		REP(i, 1, N + 1) {
			REP(j, 1, W + 1) {
				if(j - 2 >= 0) {
					dp[i][j] = max(dp[i][j], p1 * dp[i-1][j-2] + (1 - p1) * dp[i-1][j]);
				} else {
					dp[i][j] = max(dp[i][j], p1 + (1 - p1) * dp[i-1][j]);
				}
				if(j - 3 >= 0) {
					dp[i][j] = max(dp[i][j], p2 * dp[i-1][j-3] + (1 - p2) * dp[i-1][j]);
				} else {
					dp[i][j] = max(dp[i][j], p2 + (1 - p2) * dp[i-1][j]);
				}
			}
		}

		return dp[N][W] * 100;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAG Contest 2016 DomesticB D 夏合宿の朝は早い]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/17/jag-contest-2016-domesticb-d-xia-he-su-falsezhao-hazao-i/"/>
    <updated>2016-06-17T17:13:18+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/17/jag-contest-2016-domesticb-d-xia-he-su-falsezhao-hazao-i</id>
    <content type="html"><![CDATA[<!-- more -->

強連結成分分解した後，各連結成分の始点が全て起きている確立の積を求める．始点が起きている確立は，$1 - $その強連結成分のノード番号に属するノードが全員起きていない確立で求まる．始点かどうかは，強連結成分分解後のグラフのノードの自分に向いている辺の個数が$0$であればよいのでカウントしていった．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <set>

#define REP(i, k, n) for(int i = k; i < n; i++)
#define rep(i, n) for(int i = 0; i < n; i++)

using namespace std;

struct SCC {
	int n;
	vector<vector<int> > g, rg, ng, scc;
	vector<int> res;
	bool used[105];

	SCC(int _n) {
		n = _n;
		g.resize(n); rg.resize(n); scc.resize(n); res.resize(n);
	}

	void add(int i, int j) {
		g[i].push_back(j);
		rg[j].push_back(i);
	}

	vector<int> vs;
	void dfs(int v) {
		used[v] = true;
		rep(i, g[v].size()) {
			if(!used[ g[v][i] ]) dfs(g[v][i]);
		}
		vs.push_back(v);
	}

	void rdfs(int v, int k) {
		used[v] = true;
		res[v] = k;
		scc[k].push_back(v);

		rep(i, rg[v].size()) {
			if(!used[ rg[v][i] ]) rdfs(rg[v][i], k);
		}
	}

	void ng_make(int k) {
		ng.resize(k);

		rep(i, n) {
			set<int> S;
			rep(j, g[i].size()) {
				int to = g[i][j];
				if(res[i] == res[to]) continue;
				if(S.find(res[to]) != S.end()) continue;
				ng[res[i]].push_back(res[to]);
				S.insert(res[to]);
			}
		}
	}

	int build() {
		memset(used, 0, sizeof(used));
		rep(i, n) {
			if(!used[i]) dfs(i);
		}

		memset(used, 0, sizeof(used));
		int k = 0;
		for(int i = vs.size()-1; i >= 0; i--) {
			if(!used[vs[i]]) rdfs(vs[i], k++);
		}

		ng_make(k);
		return k;
	}
};

int main() {
	int n;
	while(cin >> n && n) {
		vector<double> v(n);
		SCC scc(n);

		rep(i, n) {
			int x;
			cin >> v[i] >> x;

			rep(j, x) {
				int a;
				cin >> a;
				
				a--;
				scc.add(i, a);
			}
		}

		int k = scc.build();
		vector<vector<int> > g = scc.ng;

		int cnt[105];
		memset(cnt, 0, sizeof(cnt));

		rep(i, k) {
			rep(j, g[i].size()) {
				cnt[g[i][j]]++;
			}
		}

		double ans = 1.0;
		rep(i, k) {
			if(cnt[i] != 0) continue;
			double t = 1.0;
			rep(j, scc.scc[i].size()) {
				int u = scc.scc[i][j];
				t *= v[u];
			}

			ans *= (1.0 - t);
		}

		cout << fixed;
		cout.precision(20);
		cout << ans << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
</feed>
