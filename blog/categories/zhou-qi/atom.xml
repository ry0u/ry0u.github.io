<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 周期 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/zhou-qi/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-06-06T23:58:15+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ2320 Infinity Maze]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/22/aoj2320-infinity-maze/"/>
    <updated>2016-05-22T23:54:24+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/22/aoj2320-infinity-maze</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2320">Infinity Maze</a></h4><p>Dr. Fukuoka has placed a simple robot in a two-dimensional maze. It moves within the maze and never goes out of the maze as there is no exit. The maze is made up of H × W grid cells as depicted below. The upper side of the maze faces north.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>向いてる方向に一歩進む．進めない場合は進めるまで<script type="math/tex"> 90 </script>度回転して進む．この行動を<script type="math/tex"> L </script>( <script type="math/tex"> 1 \leq L \leq 10 ^{18}) </script>)回行った時に最終的にはどこにどの向きでいるか．<br/>
行動回数<script type="math/tex"> L </script>が非常に大きいが盤面は <script type="math/tex"> 100 \times 100 </script>なので，行動回数が多い場合は，どこかを周回</p>

<p><img src="/images/AOJ/2320.png"><br/>
(赤い所をグルグル周る)感じになるので，周回する所を見つけて，後は行動回数をその周期で割り，最終的にいる場所を出す．メモするのが<script type="math/tex"> (y, x, 次に向かう方向) </script>で答えるのが<script type="math/tex"> (y, x, 現在向いてる方向) </script>で違うので混乱していた．周回する場所を見つけるために，次に向かう方向を持っていたので，その場所が見つかる前に行動が終わった場合は，その <script type="math/tex"> 1 </script>個前の方向を答えなければならずWAを生やした．<br/>
時間をめちゃくちゃかけてしまったので，もう少し早く解けるようになりたい&hellip;</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int h, w;
int sy, sx, dir;
int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};
char dd[4] = {'E', 'S', 'W', 'N'};

bool can(int y, int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}

int main() {
    ll l;
    while(cin &gt;&gt; h &gt;&gt; w &gt;&gt; l) {
        if(h == 0 &amp;&amp; w == 0 &amp;&amp; l == 0) break;

        vector&lt;string&gt; v(h);
        rep(i, h) cin &gt;&gt; v[i];

        rep(i, h) {
            rep(j, w) {
                if(v[i][j] == 'E') {
                    sy = i; sx = j;
                    dir = 0;
                    v[i][j] = '.';
                }
                else if(v[i][j] == 'S') {
                    sy = i; sx = j;
                    dir = 1;
                    v[i][j] = '.';
                }
                else if(v[i][j] == 'W') {
                    sy = i; sx = j;
                    dir = 2;
                    v[i][j] = '.';
                }
                else if(v[i][j] == 'N') {
                    sy = i; sx = j;
                    dir = 3;
                    v[i][j] = '.';
                }
            }
        }

        ll d[105][105][4];
        memset(d, -1, sizeof(d));

        vector&lt;int&gt; X, Y, D;
        int y = sy, x = sx, cnt = 0;

        rep(i, 4) {
            int ny = y + dy[(dir + i) % 4];
            int nx = x + dx[(dir + i) % 4];

            if(can(ny, nx) &amp;&amp; v[ny][nx] == '.') {
                dir = (dir + i) % 4;
                break;
            }
        }

        int pdir = dir;
        d[y][x][dir] = cnt;
        cnt++;

        while(l) {
            y = y + dy[dir];
            x = x + dx[dir];
            pdir = dir;
            l--;

            rep(i, 4) {
                int ny = y + dy[(dir + i) % 4];
                int nx = x + dx[(dir + i) % 4];

                if(can(ny, nx) &amp;&amp; v[ny][nx] == '.') {
                    dir = (dir + i) % 4;
                    break;
                }
            }

            if(d[y][x][dir] == -1) {
                d[y][x][dir] = cnt;
                cnt++;
            } else {
                break;
            }
        }

        if(l == 0) {
            cout &lt;&lt; y + 1 &lt;&lt; " " &lt;&lt; x + 1 &lt;&lt; " " &lt;&lt; dd[pdir] &lt;&lt; endl;
            continue;
        }

        ll len = cnt - d[y][x][dir];
        l = l % len;
        dir = pdir;

        rep(i, l) {
            rep(j, 4) {
                int ny = y + dy[(dir + j) % 4];
                int nx = x + dx[(dir + j) % 4];

                if(can(ny, nx) &amp;&amp; v[ny][nx] == '.') {
                    y = ny; x = nx;
                    dir = (dir + j) % 4;
                    break;
                }
            }
        }

        cout &lt;&lt; y + 1 &lt;&lt; " " &lt;&lt; x + 1 &lt;&lt; " " &lt;&lt; dd[dir] &lt;&lt; endl;
    }


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
