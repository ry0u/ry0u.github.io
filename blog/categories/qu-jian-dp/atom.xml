<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 区間dp | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/qu-jian-dp/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-10T01:42:35+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM335 D2H MinimumVariancePartition]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/05/srm335-d2h-minimumvariancepartition/"/>
    <updated>2017-02-05T19:28:10+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/05/srm335-d2h-minimumvariancepartition</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7363&rd=10659">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

数列が与えられる．この数列を$k$個の数列に分け，それぞれの数列の分散の和を最小化したい．まず初めに$[i, j)$の分散を全て計算しておく．

$$
	dp[i][j] := i番目までをj個に分けた時の分散の和の最小値
$$

として動的計画法．$j$番目まで見て$k+1$個に分ける時は，$[0, i)$と$[i, j)$に分けて$dp[i][k]$と$[i, j)$の分散の和を候補としてminを取っていく．

```cpp
#include <bits/stdc++.h>

#define rep(i,n) for(int i=0;i<(int)(n);i++)
#define REP(i,k,n) for(int i=k;i<(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

class MinimumVariancePartition {
	public:
	double minDev(vector <int> mixedSamples, int K) {
		vector<int> v = mixedSamples;
		sort(v.begin(), v.end());

		double dp[55][55];
		rep(i, 55) rep(j, 55) dp[i][j] = INF;
		dp[0][0] = 0;

		double var[55][55];
		memset(var, 0, sizeof(var));
		rep(i, v.size()) {
			REP(j, i+1, v.size()+1) {
				double mean = 0;
				REP(k, i, j) {
					mean += v[k];
				}
				mean /= (j - i);

				REP(k, i, j) {
					var[i][j] += (v[k] - mean) * (v[k] - mean);
				}
				var[i][j] /= (j - i);
			}
		}

		rep(i, v.size()) {
			REP(j, i+1, v.size()+1) {
				rep(k, K) {
					dp[j][k+1] = min(dp[j][k+1], dp[i][k] + var[i][j]);
				}
			}
		}

		return dp[v.size()][K];
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM309 D1M KMonotonic]]></title>
    <link href="http://ry0u.github.io/blog/2016/09/03/srm309-d1m-kmonotonic/"/>
    <updated>2016-09-03T01:31:15+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/09/03/srm309-d1m-kmonotonic</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6516&rd=9989">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

数列を$K$個に分けた時に，それぞれの数列に狭義での単調増加数列か，単調減少数列にしたい．要素の値を$1$変更するには$1$コストがかかる時，その最小コストを求める．

---

区間$[l, r)$を単調増加，単調減少の数列にする最小コストがわかれば，後はどこで区切るか，何回区切るかを持ってメモ化再起すれば良いと分かったが，区間$[l, r)$の最小の出し方が分からなかった．解説を見てしまった．

<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://d.hatena.ne.jp/simezi_tan/20120613/1339542749">TopCoder SRM 309 Div1 Medium KMonotonic - simezi_tanの日記</a></h4><p>問題 n本の相異なる直線が与えられる。 n本の直線の集合の、点対称の中心の個数を求めよ。 無限にある場合..</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
単純に区間$[l, r)$だけを状態として持つわけではなく右端の値も持って

$$
	dp[l][r][k] := [l, r)の右端の値をk変更した時の最小値
$$

として動的計画法をした．この$k$変更するという範囲は$-n \sim n$までやっておけば大丈夫という勘違いをして，単調増加の場合には

```cpp
rep(i, n) {
	REP(j, i + 1, n) {
		REP(k, -n, n) {
			REP(l, -n, n) {
				int a = sequence[j-1] + k;
				int b = sequence[j] + l;

				if(a < b) {
					dp[i][j+1][l] = min(dp[i][j+1][l], dp[i][j][k] + abs(sequence[j] - l));
				}
			}
		}
	}
}
```
としていた．これでは$[0, 10000, 0]$といったようなケースには対応出来ないため，変化させるのは各要素に$-n \sim n$足したものを候補としなければならない．となると$n$個の要素に対して$-n \sim n$足した$2n ^2$個の候補が出来るため，上の方法では計算量が$n ^6$となってしまい間に合わない．$[l, r)$の右端が$k(index)$の時，単調増加数列になっているという時は$[l, r-1)$の右端が$k$より小さければ何でも良いので，一番小さいものからの遷移で大丈夫ということが分かる．

```cpp
rep(i, n) {
	int res = INF;
	rep(j, m) {
		res = min(res, abs(sequence[i] - v[j])); //それより以前にコストが少ないものがあればそれで良い
		dp[i][i+1][j] = res;
	}
}

rep(i, n) {
	REP(j, i + 1, n) {
		REP(k, 1, m) {
			dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j][k-1] + abs(sequence[j] - v[k])); //[l, r-1)の右端がv[k]より小さい時の最適コスト + jをv[k]に変えるコスト
			dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j+1][k-1]); // 以前より小さいものがあればそれを採用
		}
	}
}
```
後は区間$[l, r)$の最小コストは$k$に対してループを回した時の最小値となる．単調減少の場合は，候補のvectorをひっくり返して同じことをやった．これが出ると，あとは再起で区間$[l, r)$を残り$k$回分解しなければならない時の最小値として，区切る場所を全て試した．メモリが厳しくて適当に配列を取ったたらMLEした．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

int dp[50][51][50*51*2], up[55][55], down[55][55];

// int memo[50][51][50*51*2];

int dfs(int l, int r, int k) {
	if(dp[l][r][k] != -1) return dp[l][r][k];
	if(k == 1) return min(up[l][r], down[l][r]);

	int ret = INF;
	REP(i, l + 1, r) {
		ret = min(ret, dfs(l, i, 1) + dfs(i, r, k - 1));
	}

	return dp[l][r][k] = ret;
}

class KMonotonic {
	public:
	int transform(vector <int> sequence, int K) {
		int n = sequence.size();
		vector<int> v;
		rep(i, n) {
			REP(j, -n, n + 1) v.push_back(sequence[i] + j);
		}
		sort(v.begin(), v.end());
		v.erase(unique(v.begin(),v.end()),v.end());
		int m = v.size();

		{
			rep(i, 50) rep(j, 51) {
				up[i][j] = INF;
				rep(k, 50 * 51 * 2) dp[i][j][k] = INF;
			}

			rep(i, n) {
				int res = INF;
				rep(j, m) {
					res = min(res, abs(sequence[i] - v[j]));
					dp[i][i+1][j] = res;
				}
			}

			rep(i, n) {
				REP(j, i + 1, n) {
					REP(k, 1, m) {
						dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j][k-1] + abs(sequence[j] - v[k]));
						dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j+1][k-1]);
					}
				}
			}

			rep(i, n) {
				REP(j, i + 1, n + 1) {
					rep(k, m) {
						up[i][j] = min(up[i][j], dp[i][j][k]);
					}
				}
			}
		}
		{
			reverse(v.begin(), v.end());
			rep(i, 50) rep(j, 51) {
				down[i][j] = INF;
				rep(k, 50 * 51 * 2) dp[i][j][k] = INF;
			}

			rep(i, n) {
				int res = INF;
				rep(j, m) {
					res = min(res, abs(sequence[i] - v[j]));
					dp[i][i+1][j] = res;
				}
			}

			rep(i, n) {
				REP(j, i + 1, n) {
					REP(k, 1, m) {
						dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j][k-1] + abs(sequence[j] - v[k]));
						dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j+1][k-1]);
					}
				}
			}
			
			rep(i, n) {
				REP(j, i + 1, n + 1) {
					rep(k, m) {
						down[i][j] = min(down[i][j], dp[i][j][k]);
					}
				}
			}
		}

		rep(i, n) rep(j, n + 1) rep(k, m) dp[i][j][k] = -1;
		int ret = dfs(0, n, K);
		return ret;
	}

};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM301 D2H CorrectingParenthesization]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/19/srm301-d2h-correctingparenthesization/"/>
    <updated>2016-08-19T18:27:02+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/19/srm301-d2h-correctingparenthesization</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6221&rd=9822">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$(, ), [, ], \\{, \\}$で構成される文字列を，$well\ formed$にするために，最小何回文字を変えることでできるか．$well\ formed$は以下のように定義される．


* 空文字列は$well\ formed$
* $s$を$well\ formed$とした時に，$(s)$，$[s]$，$\\{s\\}$もまた$well\ formed$
* $s, t$を$well\ formed$とした時，それを連結した文字列$st$も$well\ formed$

---

$$
	dp[l][r] := 区間[l, r)をwell\ formedにするための最小回数
$$
とした．$2$番目の条件として区間$[l, r)$を見る場合，$s[l]$と$s[r-1]$が括弧として成立している場合はそのまま，片方違う場合は$+1$，それ以外は$+2$，して括弧を外す(区間$[l+1, r-1)$を見る)．  
$3$番目の条件として，連結しても良いので，分ける場所を全探索する．必ず偶数長になるため，奇数長となる切り方はしないようにする．

# Code

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

int dp[55][55];
string s = "";

int f(int l, int r) {
	char a = s[l], b = s[r-1];
	if(a == '(' && b == ')') return 0;
	if(a == '{' && b == '}') return 0;
	if(a == '[' && b == ']') return 0;

	if(a == '(' || b == ')') return 1;
	if(a == '{' || b == '}') return 1;
	if(a == '[' || b == ']') return 1;

	return 2;
}

int dfs(int l, int r) {
	if(dp[l][r] != INF) return dp[l][r];
	if(l == r) return 0;
	int ret = INF, x = f(l, r);

	if(x == 0) ret = min(ret, dfs(l+1, r-1));
	else if(x == 1) ret = min(ret, dfs(l+1, r-1) + 1);
	else ret = min(ret, dfs(l+1, r-1) + 2);

	REP(i, l+1, r) {
		if((i - l) % 2 == 0) {
			ret = min(ret, dfs(l, i) + dfs(i, r));
		}
	}

	return dp[l][r] = ret;
}

class CorrectingParenthesization {
	public:
	int getMinErrors(string _s) {
		s = _s;
		int n = s.size();
		rep(i, 55) rep(j, 55) dp[i][j] = INF;

		return dfs(0, n);
	}
};
```


]]></content>
  </entry>
  
</feed>
