<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: yukicoder | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/yukicoder/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-26T22:18:32+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[yukicoder No.120 傾向と対策:門松列(その1)]]></title>
    <link href="http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-120-qing-xiang-todui-ce-men-song-lie-sofalse1/"/>
    <updated>2015-09-03T22:07:12+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-120-qing-xiang-todui-ce-men-song-lie-sofalse1</id>
    <content type="html"><![CDATA[<p><a href="http://yukicoder.me/problems/291">http://yukicoder.me/problems/291</a></p>

<h1>考察</h1>

<p>自由に並び替えて良いため，関係あるのは長さの竹が何個あるか．sortして小さい順にとるような貪欲では例えば
<script type="math/tex; mode=display">
{1,1,2,3,3,3,3,3,4,4,4}
</script>
の時に，{1,2,3}とペアを作ってしまうとペアが2つしか作れない．長さが違えばよいで，個数が多い順にとっていく貪欲で上手くいった．多い順に取るのはpriority_queueを使った．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int t;
    cin &gt;&gt; t;

    rep(q,t) {
        int n;
        cin &gt;&gt; n;

        vector&lt;int&gt; v(n);
        map&lt;int,int&gt; m;
        rep(i,n) {
            cin &gt;&gt; v[i];
            m[v[i]]++;
        }

        priority_queue&lt;int&gt; que;
        map&lt;int,int&gt;::iterator ite;
        for(ite = m.begin(); ite != m.end(); ite++) {
            que.push(ite-&gt;second);
        }

        int cnt = 0;
        while(que.size() &gt; 2) {
            cnt++;
            vector&lt;int&gt; t(3);

            rep(i,3) {
                t[i] = que.top();
                que.pop();
            }

            rep(i,3) {
                if(t[i] == 1) continue;
                que.push(t[i]-1);
            }
        }

        cout &lt;&lt; cnt &lt;&lt; endl;

    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yukicoder No.118 門松列(2)]]></title>
    <link href="http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-118-men-song-lie-2/"/>
    <updated>2015-09-03T22:00:55+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-118-men-song-lie-2</id>
    <content type="html"><![CDATA[<p><a href="http://yukicoder.me/problems/221">http://yukicoder.me/problems/221</a></p>

<h1>考察</h1>

<p>今回は与えられるA_{i}が100と小さいので，門松の要素の列挙が出来る．何組の選び方があるあを求めたいので，それぞれの長さが何本あるかを持っておき，一番小さいもの，真ん中，一番大きいものの個数をかける．探す範囲はN本与えられた長さの最小値から最大値までで行った．mod 10<sup>9</sup> + 7を忘れない．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;map&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define MOD 1000000007

using namespace std;
typedef long long ll;

int main()
{
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; v(n);
    map&lt;int,ll&gt; m;
    int vmin = INF, vmax = 0;
    rep(i,n) {
        cin &gt;&gt; v[i];
        m[v[i]]++;

        vmin = min(vmin,v[i]);
        vmax = max(vmax,v[i]);
    }

    ll ans = 0;
    REP(i,vmin,vmax+1) {
        REP(j,i+1,vmax+1) {
            REP(k,j+1,vmax+1) {
                ans += m[i] * m[j] * m[k];
                ans %= MOD;
            }
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yukicoder No.115 遠足のおやつ]]></title>
    <link href="http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-115-yuan-zu-falseoyatu/"/>
    <updated>2015-09-03T21:51:08+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-115-yuan-zu-falseoyatu</id>
    <content type="html"><![CDATA[<p><a href="http://yukicoder.me/problems/205">http://yukicoder.me/problems/205</a></p>

<h1>考察</h1>

<p>買うK個の最小値と最大値を出す．
<script type="math/tex; mode=display">
down[] = {1,2,&hellip;,k}  \
up[] = {n-k+1,&hellip;,n-1,n}
</script>
としてこの中に収まるようにする．辞書順最小にしたいので，左側からdownに近づけていき，その分を右側に持っていく．この操作を可能な限り行い，変化がなくなったら終了．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;cassert&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n,d,k;
    cin &gt;&gt; n &gt;&gt; d &gt;&gt; k;

    int sum = 0, t = n;
    rep(i,k) {
        sum += t;
        t--;
    }

    if(d &lt; (k*(k+1))/2 || d &gt; sum) cout &lt;&lt; -1 &lt;&lt; endl;
    else {
        vector&lt;int&gt; v;
        rep(i,k) v.push_back(d/k);

        int cnt = d % k;
        rep(i,cnt) {
            v[i]++;
        }

        sort(v.begin(),v.end());

        vector&lt;int&gt; down(n), up(n);
        rep(i,n) {
            down[i] = i+1;
            up[i] = n-k+1+i;
        }

        while(true) {
            vector&lt;int&gt; temp(v.begin(),v.end());
            int s = 0, t = v.size()-1;

            while(true) {
                if(s == t) break;

                if(v[s] == down[s] || v[s] == up[s]) {
                    s++;
                    continue;
                }

                if(v[t] == up[t]) {
                    t--;
                    continue;
                }


                int diff;
                if(v[s] &gt;= up[s]) {
                    diff = v[s] - up[s];
                } else {
                    diff = v[s] - down[s];
                }

                while(diff) {
                    if(v[t] + diff &lt;= up[t]) {
                        v[s] -= diff;
                        v[t] += diff;
                        diff = 0;
                    }
                    else {
                        v[s] -= up[t] - v[t];
                        diff -= up[t] - v[t];
                        v[t] = up[t];
                        t--;
                    }

                    if(s == t) break;
                }

            }

            sort(v.begin(),v.end());

            bool flag = true;
            rep(i,k) {
                if(v[i] != temp[i]) flag = false;
            }

            if(flag) break;
        }

        rep(i,v.size()) {
            cout &lt;&lt; v[i];

            if(i == v.size()-1) cout &lt;&lt; endl;
            else cout &lt;&lt; " ";
        }
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yukicoder No.92 逃走経路]]></title>
    <link href="http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-92-tao-zou-jing-lu/"/>
    <updated>2015-09-03T21:40:54+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-92-tao-zou-jing-lu</id>
    <content type="html"><![CDATA[<p><a href="http://yukicoder.me/problems/149">http://yukicoder.me/problems/149</a></p>

<h1>考察</h1>

<p>dfsで行けるとこ全部行ったらTLEした．戻ることも考えられるので，状態数がすごいことになることがわかっていなかった．よくよく考えると，i回目の移動でいる場所としてはmaxでNなので，行ける場所をもって最後まで残った場所を答える．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;int&gt; v;
int n,m,k;

int main() {
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;

    map&lt;int,vector&lt;edge&gt; &gt; edges;
    rep(i,m) {
        int a,b,c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;

        a--;
        b--;

        edges[c].push_back(edge(a,b,c));
        edges[c].push_back(edge(b,a,c));
    }

    v.resize(k);
    rep(i,k) cin &gt;&gt; v[i];

    vector&lt;int&gt; ans(n);
    rep(i,n) ans[i] = i;
    rep(i,k) {
        bool used[105];
        memset(used,0,sizeof(used));

        rep(j,ans.size()) {
            used[ans[j]] = true;
        }

        vector&lt;edge&gt; es = edges[v[i]];
        vector&lt;int&gt; temp;
        rep(j,es.size()) {
            int f = es[j].from;
            int t = es[j].to;

            if(used[f]) {
                temp.push_back(t);
            }
        }

        sort(temp.begin(),temp.end());
        temp.erase(unique(temp.begin(),temp.end()),temp.end());

        ans.resize(temp.size());
        rep(j,temp.size()) ans[j] = temp[j];
    }

    sort(ans.begin(),ans.end());
    cout &lt;&lt; ans.size() &lt;&lt; endl;
    rep(i,ans.size()) {
        cout &lt;&lt; ans[i] + 1;
        if(i == ans.size()-1) cout &lt;&lt; endl;
        else cout &lt;&lt; " ";
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yukicoder No.78 クジ付アイスバー]]></title>
    <link href="http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-7kuzifu-aisuba/"/>
    <updated>2015-09-03T21:15:58+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-7kuzifu-aisuba</id>
    <content type="html"><![CDATA[<p><a href="http://yukicoder.me/problems/152">http://yukicoder.me/problems/152</a></p>

<h1>考察</h1>

<p>以下の通りに場合分けして考えた．<br/>
- n > kの時，食べる予定のアイスバーの分回せばいい(最大50)．<br/>
- そうではない時，まず1箱分回した時に，いくつ当たりが残るかを調べる．<br/>
- ここで残った当たりが1箱勝った数と同じ場合はそれが答え(目標のkまで最初の1箱分だけでいける)<br/>
- 同じでなかった時は，全部開ける箱と，買い終わってアイスが残る箱に分けて考える</p>

<p>まずは愚直にやってTLEをして，&ndash;と++を間違えてWAを生やした</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n,k;
    cin &gt;&gt; n &gt;&gt; k;
    string s;
    cin &gt;&gt; s;

    vector&lt;int&gt; v(n);
    rep(i,n) v[i] = s[i] - '0';

    if(n &gt; k) {
        int ans = 0, cnt = 0;
        rep(i,k) {
            if(cnt &gt; 0) cnt--;
            else ans++;

            cnt += v[i];
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    } else {
        int res = 0, cnt = 0;
        rep(i,n) {
            if(cnt &gt; 0) cnt--;
            else res++;

            cnt += v[i];
        }

        if(cnt &gt;= res) {
            cout &lt;&lt; res &lt;&lt; endl;
        } else {
            int m = 0;
            int ans = 0, q = 0;
            while(m + n &lt;= k) {
                m += n;
                if(q &gt;= res) {
                    q -= res;
                    q += cnt;
                } else {
                    ans += res - q;
                    q = cnt;
                }
            }

            rep(i,k%n) {
                if(q &gt; 0) q--;
                else ans++;

                q += v[i];
            }

            cout &lt;&lt; ans &lt;&lt; endl;
        }

    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
