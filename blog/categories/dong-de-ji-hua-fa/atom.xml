<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 動的計画法 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/dong-de-ji-hua-fa/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-10T23:45:44+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ0599 IOI Manju]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/08/aoj0599-ioi-manju/"/>
    <updated>2016-03-08T15:01:46+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/08/aoj0599-ioi-manju</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0599">IOI Manju | Aizu Online Judge</a></h4><p>ところで，あなたはJust Odd Inventions 社を知っているだろうか？ この会社の業務は「ただ奇妙な発明(just odd inventions)」をすることである．ここでは略してJOI 社と呼ぶ．IOI 社は，饅頭を詰めるための高級な箱をJOI 社に発注することになった．JOI 社の製作する饅頭用の箱は$N$ 種類あり， $j$ 番目$(1 \leq j \leq N)$の箱は最大で$C_j$ 個の饅頭を詰められる大きさであり，販売価格は$E_j$ 円である．これらの$N$ 種類の箱のうちの何種類か(0 種類以上$N$ 種類以下) を1 個ずつ発注し，饅頭をそれらの箱に詰め分けてセットで販売することになった．各饅頭セットの価格は，それに含まれる饅頭の価格の合計である．</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>饅頭{% m %} i {% em %}から饅頭{% m %} j {% em %}まで選んだ時の価格が欲しいので，累積和を取っておく．<br/>
{% math %}
    dp[i][j] := i番目以内の箱を使い，饅頭jまで詰めた時の最大値
{% endmath %}
とする．{% m %} i {% em %}番目の箱を</p>

<ul>
<li>使う遷移は，{% m %} dp[i][j]+(d[j+c[i]]-d[j])-e[i]{% em %}</li>
<li>使わない遷移は{% m %} dp[i][j+c[i]]{% em %}．</li>
</ul>


<p>{% img /images/AOJ/0599.png %}</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll dp[505][10005];

int main() {
    int m, n;
    cin &gt;&gt; m &gt;&gt; n;

    vector&lt;int&gt; v(m);
    rep(i, m) cin &gt;&gt; v[i];

    vector&lt;P&gt; p(n);
    rep(i, n) {
        cin &gt;&gt; p[i].first &gt;&gt; p[i].second;
    }

    sort(v.begin(), v.end(), greater&lt;int&gt;());

    int d[10005];
    memset(d, 0, sizeof(d));
    REP(i, 1, m + 1) {
        d[i] += d[i-1] + v[i-1];
    }

    memset(dp, 0, sizeof(dp));
    rep(i, 505) {
        rep(j, 10005) dp[i][j]  = -1;
    }

    dp[0][0] = 0;

    rep(i, n) {
        rep(j, m + 1) {
            dp[i+1][j] = max(dp[i+1][j], dp[i][j]);
        }

        rep(j, m) {
            if(dp[i][j] == -1) continue;

            int id = j + p[i].first;
            id = min(id, m);
            dp[i+1][id] = max(dp[i+1][id], max(dp[i][id], dp[i][j] + (d[id] - d[j]) - p[i].second));
        }
    }


    ll ans = 0;
    rep(i, n + 1) {
        rep(j, m + 1) {
            ans = max(ans, dp[i][j]);
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0595 Schedule]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/06/aoj0595-schedule/"/>
    <updated>2016-03-06T01:11:01+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/06/aoj0595-schedule</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0595">Schedule | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>J君，O君，I君がいるかいないかを3ビットで持つ．
{% math %}
    dp[i][j] := i日目に状態jの場合のスケジュール表として考えられるものの数
{% endmath %}
とする．</p>

<ul>
<li><p>{% m %} i {% em %}日目の鍵当番がいるか<br/>
{% math %}
  j \ &amp; \ (1 &lt;&lt; d)
{% endmath %}</p></li>
<li><p>{% m %} i-1日目に鍵を持ち帰れた人がいるか {% em %}
{% math %}
  j \ &amp; \ k
{% endmath %}</p></li>
</ul>


<p>この条件を満たす場合に遷移可能．{% m %} O(n \cdot 2 ^3 \cdot 2 ^3) {% em %}．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;bitset&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair
#define MOD 10007

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll dp[1005][8];

int main() {
    int n;
    cin &gt;&gt; n;

    string s;
    cin &gt;&gt; s;

    map&lt;char, int&gt; id;
    id['J'] = 2; id['O'] = 1, id['I'] = 0;

    memset(dp, 0, sizeof(dp));
    dp[0][1 &lt;&lt; 2] = 1;

    REP(i, 1, n + 1) {
        int d = id[ s[i-1] ];
        rep(j, 1 &lt;&lt; 3) {
            if(!(j &amp; (1 &lt;&lt; d))) continue;
            rep(k, 1 &lt;&lt; 3) {
                if(j &amp; k) { 
                    dp[i][j] += dp[i-1][k];
                    dp[i][j] %= MOD;
                }
            }
        }
    }

    ll ans = 0;
    rep(i, 1 &lt;&lt; 3) {
        ans += dp[n][i];
    }

    cout &lt;&lt; ans % MOD &lt;&lt; endl;


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manthan, Codefest 16C Spy Syndrome 2]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16c-spy-syndrome-2/"/>
    <updated>2016-02-29T15:32:14+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16c-spy-syndrome-2</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-chrome="0" data-card-controls="0"><h4><a href="http://codeforces.com/contest/633/problem/C">Problem - C - Codeforces</a></h4><p>After observing the results of Spy Syndrome, Yash realised the errors of his ways. He now believes that a super spy such as Siddhant can't use a cipher as basic and ancient as Caesar cipher. After many weeks of observation of Siddhant's sentences, Yash determined a new cipher technique.</p></blockquote>




<!-- more -->


<p>原文を全て小文字にしてreverseして，接合した文を復元する．<br/>
まずTrie木を作って文字列が単語リストにあるかを判定出来るようにする．<br/>
次に，
{% math %}
    dp[i] := i番目の文字まで復元可能
{% endmath %}
とする．Trieのfind関数にその単語そのものがあればTrue, また現在のノードがendであり，その場所の{% m %} dp[i] {% em %}をみて復元可能な時にTrueを返す．その文字列を{% m %} S[i] {% em %}にとっておく．<br/>
後は末尾から帰ってくれば原文の単語の逆順がわかるのでreverseする．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

string S[10005], ret = "", res = "";
bool dp[10005];

struct Trie {
    Trie *next[26];
    bool end;

    Trie() {
        fill(next,next+26,(Trie *)0);
        end = false;
    }

    void insert(string &amp;s,int i) {
        if(i == s.size()) {
            this-&gt;end = true;
            return;
        }

        if(this-&gt;next[s[i]-'a'] == NULL) {
            this-&gt;next[s[i]-'a'] = new Trie();
        }

        this-&gt;next[s[i]-'a']-&gt;insert(s,i+1);
    }

    bool find(int s, int i) {
        if(s - i &gt;= 0 &amp;&amp; dp[s - i] &amp;&amp; this-&gt;end) {
            string t = "";
            rep(j, i) {
                t += ret[s-j];
            }
            res = t;
            return true;
        }

        if((s + 1) - i == 0) {
            if(this-&gt;end) {
                string t = "";
                rep(j, i) {
                    t += ret[s-j];
                }
                res = t;
                return true;
            }
            else return false;
        }

        if(this-&gt;next[ret[s-i]-'a'] != NULL) {
            if(this-&gt;next[ret[s-i]-'a']-&gt;find(s, i+1)) return true;
        }

        return false;
    }
};


int main() {
    int n;
    cin &gt;&gt; n;

    string s;
    cin &gt;&gt; s;

    int m;
    cin &gt;&gt; m;

    vector&lt;string&gt; v(m);
    map&lt;string, string&gt; f;
    Trie *trie = new Trie();

    rep(i, m) {
        cin &gt;&gt; v[i];

        string t = v[i];
        rep(j, t.size()) {
            t[j] = tolower(t[j]);
        }

        f[t] = v[i];
        trie-&gt;insert(t, 0);
    }

    memset(dp, 0, sizeof(dp));

    rep(i, n) {
        ret = ret + s[i];

        if(trie-&gt;find(i, 0)) {
            S[i] = f[res];
            dp[i] = true;
        }
    }

    vector&lt;string&gt; ans;
    int cur = n-1;
    while(dp[cur]) {
        string t = S[cur];
        ans.push_back(t);
        cur -= t.size();
    }

    reverse(ans.begin(), ans.end());

    rep(i, ans.size()) {
        cout &lt;&lt; ans[i];
        if(i == ans.size()-1) cout &lt;&lt; endl;
        else cout &lt;&lt; " ";
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manthan, Codefest 16A Ebony and lvory]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16-a-ebony-and-lvory/"/>
    <updated>2016-02-29T10:27:42+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16-a-ebony-and-lvory</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-chrome="0" data-card-controls="0"><h4><a href="http://codeforces.com/contest/633/problem/A">Problem - A - Codeforces</a></h4><p>Dante is engaged in a fight with "The Savior". Before he can fight it with his sword, he needs to break its shields. He has two guns, Ebony and Ivory, each of them is able to perform any non-negative number of shots.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more-->


<p>{% math %}
    a, bを用いてcを表せるか．使用回数は0でも良い．
{% endmath %}</p>

<p>{% math %}
    iが表せるならi+a, i+bも表すことが出来る．O(\max&copy;)
{% endmath %}</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

bool used[10500];

int main() {
    int a, b, c;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;

    memset(used, 0, sizeof(used));
    used[0] = true;

    rep(i, c + 1) {
        if(used[i]) {
            used[i+a] = true;
        }
    }

    rep(i, c + 1) {
        if(used[i]) {
            used[i+b] = true;
        }
    }

    if(used[c]) cout &lt;&lt; "Yes" &lt;&lt; endl;
    else cout &lt;&lt; "No" &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM682 D2H FriendlyRobot]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/srm682-d2h-friendlyrobot/"/>
    <updated>2016-02-29T01:13:10+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/srm682-d2h-friendlyrobot</id>
    <content type="html"><![CDATA[<p>文字列{% m %} U,D,R,L {% em %}の命令で動くロボットがある．この文字列を{% m %} K {% em %}回書き換えられることが出来るときに，最大で何回{% m %}(0,0){% em %}を通ることが出来るか．</p>

<!-- more -->


<hr />

<p>移動回数が奇数回の時に{% m %} (0,0) {% em %}に戻ることは出来ない．また偶数回の場合でも横方向，縦方向の移動量が共に偶数回，共に奇数回の場合のみ戻ることが出来る．<br/>
また，{% m %} +を-に，-を+{% em %}に変えることで{% m %} 2 {% em %}移動量が変わる．<br/>
そして，戻るために命令を書き換えなければならない回数も以下のように一意に求まる．
{% math %}
\begin{eqnarray}
    共に偶数回 &amp;:=&amp;  \frac{横方向}{2} + \frac{縦方向}{2} \
    共に奇数回 &amp;:=&amp;  \frac{横方向}{2} + \frac{縦方向}{2} + 1\
\end{eqnarray}
{% endmath %}
共に奇数回の場合に{% m %} +1 {% em %}されるのは，例えば命令が{% m %} UR {% em %}の場合に{% m %} UD {% em %}に書き換えることで{% m %} (0, 0) {% em %}に戻れるためである．</p>

<p>これより
{% math %}
    dp[i][j] := i番目までの命令列をj回変更した時の(0, 0)を訪れる最大値
{% endmath %}
として，総当りしてmaxを取った．</p>

<h1>Code</h1>

<pre><code class="cpp">    public:
    int findMaximumReturns(string s, int K) {

        vector&lt;int&gt; X(s.size() + 1), Y(s.size() + 1);
        int x = 0, y = 0;
        rep(i, s.size()) {
            if(s[i] == 'U') y++;
            if(s[i] == 'D') y--;
            if(s[i] == 'R') x++;
            if(s[i] == 'L') x--;

            X[i+1] = x; Y[i+1] = y;
        }

        rep(i, s.size() + 1) {
            rep(j, K + 1) {
                dp[i][j] = -1;
            }
        }
        dp[0][0] = 0;

        rep(i, s.size() + 1) {
            rep(j, K + 1) {
                if(dp[i][j] == -1) continue;
                for(int k = i + 2; k &lt; s.size() + 1; k += 2) {
                    int s = abs(X[k] - X[i]), t = abs(Y[k] - Y[i]);
                    int res = 0;

                    if(s % 2 == 0 &amp;&amp; t % 2 == 1) continue;
                    if(s % 2 == 1 &amp;&amp; t % 2 == 0) continue;
                    if(s % 2 == 0 &amp;&amp; t % 2 == 0) res = s / 2 + t / 2;
                    if(s % 2 == 1 &amp;&amp; t % 2 == 1) res = s / 2 + t / 2 + 1;

                    if(j + res &gt; K) continue;
                    dp[k][j + res] = max(dp[k][j + res], dp[i][j] + 1);
                }
            }
        }

        ll ans = 0;
        rep(i, s.size() + 1) {
            rep(j, K + 1) {
                ans = max(ans, dp[i][j]);
            }
        }

        return ans;
    }
</code></pre>
]]></content>
  </entry>
  
</feed>
