<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 動的計画法 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/dong-de-ji-hua-fa/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-12-01T23:52:11+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM329 D2H ProbabilisticTranslator]]></title>
    <link href="http://ry0u.github.io/blog/2016/12/01/srm329-d2h-probabilistictranslator/"/>
    <updated>2016-12-01T23:25:59+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/12/01/srm329-d2h-probabilistictranslator</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6010&rd=10009">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

単語列とそれぞれの単語をある単語に変換できる辞書と二つの単語が並んだ時に得られる点が与えられた時に，得点の最大化をする．

$$
	dp[i][j] := i番目の単語を辞書からj番目に変換した時の最大値
$$

として動的計画法．$dp[i][j]$から$i+1$番目に遷移するときに，$i$番目の単語を$j$番目に変換した文字列と，$i+1$番目の単語を$k$番目に変換した文字列のペアで得点が得られる場合は加算する．先に$dp$の添字に対応する文字列のテーブルを作ってしまった方が楽だと思った．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

vector<string> split(const string &str, char delim) {
	vector<string> res;
	size_t current = 0, found;
	while((found = str.find_first_of(delim, current)) != string::npos) {
		res.push_back(string(str, current, found - current));
		current = found + 1;
	}
	res.push_back(string(str, current, str.size() - current));
	return res;
}

int dp[2505][55]; //i番目にその語の辞書からj番目に変換するときの最大値

class ProbabilisticTranslator {
	public:
	int maximumFidelity(vector <string> text, vector <string> dictionary, vector <string> frequencies) {
		vector<string> v;
		rep(i, text.size()) {
			vector<string> ret = split(text[i], ' ');
			rep(j, ret.size()) {
				v.push_back(ret[j]);
			}
		}
		
		map<string, vector<string> > m;
		rep(i, dictionary.size()) {
			vector<string> t = split(dictionary[i], ' ');

			REP(j, 2, t.size()) {
				m[t[0]].push_back(t[j]);
			}
		}

		map<pair<string, string>, int> fre;
		rep(i, frequencies.size()) {
			vector<string> t = split(frequencies[i], ' ');
			stringstream ss;
			ss << t[2];
			ss >> fre[mp(t[0], t[1])];
		}

		vector<vector<string> > table;
		rep(j, v.size()) {
			table.push_back(m[v[j]]);
		}

		memset(dp, 0, sizeof(dp));
		rep(i, v.size()-1) {
			rep(j, table[i].size()) {
				string s = table[i][j];
				rep(k, table[i+1].size()) {
					string t = table[i+1][k];
					if(fre.count(mp(s, t))) {
						dp[i+1][k] = max(dp[i+1][k], dp[i][j] + fre[mp(s, t)]);
					} else {
						dp[i+1][k] = max(dp[i+1][k], dp[i][j]);
					}
				}
			}
		}

		int ans = 0;
		rep(j, 2505) {
			rep(k, 55) {
				ans = max(ans, dp[j][k]);
			}
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM328 D1M BlockEnemy]]></title>
    <link href="http://ry0u.github.io/blog/2016/11/19/srm328-d1m-blockenemy/"/>
    <updated>2016-11-19T00:36:04+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/11/19/srm328-d1m-blockenemy</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6852&rd=10008">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

グラフが与えられる．$occupiedTowns[i]$同士が繋がっていないようにするために，辺を切る最小コストを求める．

---

まずは最小全域木を作る．すると木になったので$root$を$0$に決めて，dfsする．

$$
	dfs(cur, pre) := cur以下の部分木をoccupiedTowns同士が繋がらないようにした時の最小コスト\\\
	dp[i] := i以下の部分木を分離するための最小コスト
$$

葉まで行った時は，$occupiedTowns$の時は$dp[i]$をその辺のコストにして，そうでない場合は切る必要がないので$0$にして$0$を返す．ここから場合分け．今見ている頂点が$occupiedTowns$ではないときを考える．

{% img /images/SRM/328_1.png %}

今訪れている頂点が$1$で，赤の枠で囲まれている場所が$occupiedTowns$，辺のコストはそれぞれ$l$である．この時，このまま頂点$2$に伸びる辺と頂点$4$に伸びる頂点をつないでしまうと，$2$から$4$へ行けてしまうので何とかしなければならない．頂点$2$へ行く方法を切ってしまうと考えた場合，そこへ伸びる辺を切る方法と，頂点$2$以下の部分木を分離してしまう方法がある．下の図でいうと$l1$と$dp[2]$である．これらの$min$が頂点$2$へ行く方法を切る時の最小コストである．

{% img /images/SRM/328_2.png %}

同様に頂点$4$についても$min(l3, dp[4])$である．小さい順につながってしまうとダメな場所$-1$個の場所に行けないようにする．最後の残っている所を親に引き継ぐ(親を赤の枠にする)．今見ている頂点が$occupiedTowns$の時は，子の赤い枠の場所は全て切らねばならないので，その辺を切るか$dp$を切るかの小さい方の合計を持ち上げる．$dfs(0, -1)$の戻り値がそのまま答えとなる．


```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

vector<string> split(const string &str, char delim) {
	vector<string> res;
	size_t current = 0, found;
	while((found = str.find_first_of(delim, current)) != string::npos) {
		res.push_back(string(str, current, found - current));
		current = found + 1;
	}
	res.push_back(string(str, current, str.size() - current));
	return res;
}

int f(string s) {
	int ret;
	stringstream ss(s);
	ss >> ret;
	return ret;
}

struct UnionFind {
	vector<int> par, rank;
	int N;

	UnionFind(int n) {
		N = n;
		par.resize(n);
		rank.resize(n);

		rep(i, n) {
			par[i] = i;
			rank[i] = 0;
		}
	}

	int find(int x) {
		if(par[x] == x) return x;
		else return par[x] = find(par[x]);
	}

	void unite(int x, int y) {
		x = find(x);
		y = find(y);

		if(x == y) return;

		if(rank[x] < rank[y]) {
			par[x] = y;
		} else {
			par[y] = x;
			if(rank[x] == rank[y]) rank[x]++;
		}
	}

	bool same(int x, int y) {
		return find(x) == find(y);
	}

	int size() {
		int cnt = 0;
		rep(i, N) if(find(i) == i) cnt++;
		return cnt;
	}
};

struct edge {
	int from,to;
	int cost;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int f,int t,int c) : from(f),to(t),cost(c) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

vector<edge> G[55];
int dist[55][55];

int kruskal(int n, vector<edge> v) {
	sort(v.begin(),v.end());

	UnionFind uf(n);
	rep(i, 55) G[i].clear();
	rep(i, 55) rep(j, 55) dist[i][j] = INF;

	int ret = 0;
	rep(i, v.size()) {
		edge e = v[i];
		if(!uf.same(e.from,e.to)) {
			uf.unite(e.from,e.to);
			ret += e.cost;

			G[e.from].push_back(edge(e.to, e.cost));
			G[e.to].push_back(edge(e.from, e.cost));

			dist[e.from][e.to] = e.cost;
			dist[e.to][e.from] = e.cost;

			// cout << e.from << " -- " << e.to << " [label = \"" << e.cost << "\"];" << endl;
		}
	}

	return ret;
}

bool O[55];
int dp[55]; // 部分木iを消す時の最善
int n;

int dfs2(int cur, int pre) {
	int cnt = 0;
	rep(i, G[cur].size()) {
		edge e = G[cur][i];
		if(e.to == pre) continue;
		cnt++;
	}

	if(cnt == 0) {
		if(O[cur]) {
			dp[cur] = dist[cur][pre];
			return 0;
		} else {
			dp[cur] = 0;
			return 0;
		}
	}

	vector<int> v;
	int ret = 0;
	rep(i, G[cur].size()) {
		edge e = G[cur][i];
		if(e.to == pre) continue;

		int x = dfs2(e.to, cur);
		ret += x;
		int res = min(dp[e.to], dist[e.to][cur]);

		if(res == 0) continue;
		v.push_back(res);
	}

	if(O[cur]) {
		int sum = 0;
		rep(i, v.size()) {
			sum += v[i];
		}
		return sum + ret;
	} else {
		if(v.size() == 0) {
			dp[cur] = 0;
			return ret;
		}
		else if(v.size() == 1) {
			dp[cur] = v[0];
			return ret;
		} else {
			sort(v.begin(), v.end());

			int sum = 0;
			rep(i, v.size()-1) {
				sum += v[i];
			}

			dp[cur] = v[v.size()-1];
			return sum + ret;
		}
	}
}

class BlockEnemy {
	public:
	int minEffort(int N, vector <string> roads, vector <int> occupiedTowns) {
		n = N;
		memset(O, 0, sizeof(O));
		rep(i, occupiedTowns.size()) {
			O[occupiedTowns[i]] = true;
		}

		rep(i, 55) dp[i] = INF;

		vector<edge> E;
		rep(i, roads.size()) {
			vector<string> ret = split(roads[i], ' ');

			int a = f(ret[0]);
			int b = f(ret[1]);
			int e = f(ret[2]);

			E.push_back(edge(a, b, e));
		}

		kruskal(N, E);

		return dfs2(0, -1);
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM327 D1E-D1H NiceOrUgly]]></title>
    <link href="http://ry0u.github.io/blog/2016/11/18/srm327-d1e-d1h-niceorugly/"/>
    <updated>2016-11-18T23:51:14+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/11/18/srm327-d1e-d1h-niceorugly</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6871&rd=10007">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

母音が$3$つ連続，または子音が$5$つ連続する場合はその文字列は$ugly$である．$nice$とは$ugly$ではない文字列の事を言う．'?'はどの文字列にも変更することができる．$nice$にも$ugly$である場合は$42$を，そうではに場合はその文字列がどちらかを返す．

---

$$
	dp[i][j][k][0] := i番目までに母音がj文字連続，子音がk文字連続して，未だuglyでない\\\
	dp[i][j][k][1] := i番目までに母音がj文字連続，子音がk文字連続して，既にugly
$$

として動的計画法．はてなの場合は，母音にするか子音にするか選べるので，どちらにも遷移する．後は今見ている文字通りに遷移する．母音が$3$つ連続，または子音が$5$つ連続がどこかでしていた場合，$ugly$になる可能性がある．その中で最後まで$ugly$にならなかったものがあれば，双方になり得るので$42$とする．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

bool vowels(char c) {
	if(c == 'A'|| c == 'E' || c == 'I' || c == 'O' ||  c == 'U') return true;
	return false;
}

bool dp[55][55][55][2];

class NiceOrUgly {

    public:

    string describe(string s) {
		
		memset(dp, 0, sizeof(dp));
		dp[0][0][0][0] = true;

		rep(i, s.size()) {
			rep(j, 3) {
				rep(k, 5) {
					rep(l, 2) {
						if(dp[i][j][k][l]) {
							if(s[i] == '?') {
								if(j + 1 == 3) {
									dp[i+1][j+1][0][1] = true;
								} else {
									dp[i+1][j+1][0][0] = true;
								}

								if(k + 1 == 5) {
									dp[i+1][0][k+1][1] = true;
								} else {
									dp[i+1][0][k+1][0] = true;
								}
							} else {
								if(vowels(s[i])) {
									if(j + 1 == 3) {
										dp[i+1][j+1][0][1] = true;
									} else {
										dp[i+1][j+1][0][0] = true;
									}
								} else {
									if(k + 1 == 5) {
										dp[i+1][0][k+1][1] = true;
									} else {
										dp[i+1][0][k+1][0] = true;
									}
								}
							}
						}
					}
				}
			}
		}

		bool flag = false;
		rep(i, s.size() + 1) {
			rep(j, 4) {
				rep(k, 6) {
					flag |= dp[i][j][k][1];
				}
			}
		}

		if(flag) {
			bool check = false;
			rep(j, 4) {
				rep(k, 6) {
					check |= dp[s.size()][j][k][0];
				}
			}

			if(check) return "42";
			return "UGLY";
		}
		else return "NICE";
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM325 D1E FenceRepairing]]></title>
    <link href="http://ry0u.github.io/blog/2016/11/18/srm325-d1e-fencerepairing/"/>
    <updated>2016-11-18T22:53:30+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/11/18/srm325-d1e-fencerepairing</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6827&rd=10005">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

"X"と"."で構成される文字列が与えれる．"X"は壊れているフェンスを示す．全てのフェンスが壊れていない状態にしたい．区間$[i, j]$を修理したい場合は$\sqrt{j - i - 1}$かかる．全体のコストを最小化したい．

---

$$
	dp[i] := i番目までフェンスが壊れていない状態にした時の最小コスト
$$
として動的計画法．$i$からどこまで修理するかの$j$を全探索して，更新する．その区間に"X"があって始めて修理する意味があるので，$left, right$を用意して$[i, j]$内のフェンスの最も左と右を持った．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

double dp[2505];

class FenceRepairing {
	public:
	double calculateCost(vector <string> boards) {
		string s = " ";
		rep(i, boards.size()) {
			s += boards[i];
		}

		rep(i, 2505) dp[i] = INF;
		dp[0] = 0;

		rep(i, s.size()) {
			int left = -1, right = -1;
			REP(j, i, s.size()) {
				if(s[j] == 'X') {
					if(left == -1) left = j;
					right = j;
				}

				if(left == -1 || right == -1) {
					dp[j] = min(dp[j], dp[i]);
				} else {
					dp[j] = min(dp[j], dp[i] + sqrt(right - left + 1));
				}
			}
		}

		return dp[s.size()-1];
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM325 D2M RGBStreet]]></title>
    <link href="http://ry0u.github.io/blog/2016/11/18/srm325-d2m-rgbstreet/"/>
    <updated>2016-11-18T22:44:51+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/11/18/srm325-d2m-rgbstreet</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6680&rd=10005">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

家が横一列に並んでいて，まだ色がついてない．これを三色$RGB$に塗りたいが，隣り合う家が同じ色になってはいけない．家$i$を塗るコストは$R[i]$, $G[i]$, $B[i]$である．全体のコストを最小化したい．

---

$$
	dp[i][j] := 家iを色jに塗る最小コスト
$$
として動的計画法．$R, G, B$を$0, 1, 2$に対応させている．隣り合ってはいけないので遷移は以下のようになる．

{% img /images/SRM/325_1.png %}

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

int dp[25][3];

vector<string> split(const string &str, char delim) {
	vector<string> res;
	size_t current = 0, found;
	while((found = str.find_first_of(delim, current)) != string::npos) {
		res.push_back(string(str, current, found - current));
		current = found + 1;
	}
	res.push_back(string(str, current, str.size() - current));
	return res;
}

int f(string s) {
	int ret;
	stringstream ss;
	ss << s;
	ss >> ret;
	return ret;
}

class RGBStreet {
	public:
	int estimateCost(vector <string> houses) {
		int n = houses.size();
		vector<int> R(n), G(n), B(n);
		rep(i, n) {
			vector<string> ret = split(houses[i], ' ');
			R[i] = f(ret[0]);
			G[i] = f(ret[1]);
			B[i] = f(ret[2]);
		}

		rep(i, 25) {
			rep(j, 3) dp[i][j] = INF;
		}

		rep(j, 3) {
			dp[0][j] = 0;
		}

		rep(i, n) {
			dp[i+1][0] = min(dp[i][1] + R[i], dp[i][2] + R[i]);
			dp[i+1][1] = min(dp[i][0] + G[i], dp[i][2] + G[i]);
			dp[i+1][2] = min(dp[i][0] + B[i], dp[i][1] + B[i]);
		}

		int ans = INF;
		rep(i, 3) {
			ans = min(ans, dp[n][i]);
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
</feed>
