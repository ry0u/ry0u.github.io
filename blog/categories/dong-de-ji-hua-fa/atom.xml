<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 動的計画法 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/dong-de-ji-hua-fa/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-05-29T23:44:23+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ1086 Live Schedule]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/12/aoj1086-live-schedule/"/>
    <updated>2016-05-12T00:53:50+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/12/aoj1086-live-schedule</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1086">Live Schedule | Aizu Online Judge</a></h4><p>YOKARI TAMURAは全国的に有名なアーティストである。今月YOKARIは D 日間にわたってライブツアーを行う。ツアーのスケジュールの決定においてこの国を C 種類の地域でわける。YOKARIがある地域でライブを行うことにより利益を得られ、これは正の整数で表される。YOKARIは原則として 1 日に最大 1 つまでライブを行う。ただし、ある地域でライブを行った後、隣接する地域でライブを行える場合はその地域で同じ日に再びライブを行うことができる。この条件を満たす限り、地域を移動しながら何度もライブを行うことができる。また、同じ日に同じ地域でライブを 2 度以上行うことはできない。さらに、同じ日に 2 回以上のライブを行う日の数はツアー期間中合計 X 以下でなければならない。</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p><script type="math/tex; mode=display">
    dp[i][j][k] := i日目に疲労度jで2回以上ライブを行った回数がkの時の売上の最大値
</script></p>

<p>として，動的計画法．ライブをし終わった地域から，次の日は開始かと思っていて状態に"町<script type="math/tex"> i </script>&ldquo;にいる時，というのを追加していたがいらなかった．ライブを始める町と終わる町はどこでも良いので <script type="math/tex"> C ^2 </script>で区間を全探索し， その区間の疲労度を足した次の日に遷移可能とした．<script type="math/tex"> 2 </script>回以上続けてライブを続けない場合は制限がないので，別に分けた．<br/>
WAが取れなかった原因は，ライブを行わない，というのを追加していないことだった．区間は同じだが後々にライブをした方が利益が高い場合があるので，この行動を追加しなければおかしかった．<br/>
また <script type="math/tex"> E_{i, j} = 0 </script>の時にはライブを行うことが出来ない，という条件に気が付かず時間を溶かした．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;iomanip&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

// i日目に疲労度jで2回以上のライブ回数kの時の売上の最大値
ll dp[35][55][10];
ll E[20][35], F[20][35];

int main() {
    ll c, d, w, x;
    while(cin &gt;&gt; c &gt;&gt; d &gt;&gt; w &gt;&gt; x) {
        if(c == 0 &amp;&amp; d == 0 &amp;&amp; w == 0 &amp;&amp; x == 0) break;

        memset(E, 0, sizeof(E));
        rep(i, c) {
            rep(j, d) cin &gt;&gt; E[i][j];
        }

        memset(F, 0, sizeof(F));
        rep(i, c) {
            rep(j, d) cin &gt;&gt; F[i][j];
        }

        // rep(i, c) {
        //  rep(j, d) {
        //      cout &lt;&lt; "(" &lt;&lt; E[i][j] &lt;&lt; ", " &lt;&lt; F[i][j] &lt;&lt; ") ";
        //  }
        //  cout &lt;&lt; endl;
        // }

        memset(dp, 0, sizeof(dp));

        rep(i, d) {
            rep(j, w + 1) {
                rep(k, x + 1) {
                    dp[i+1][j][k] = max(dp[i+1][j][k], dp[i][j][k]);

                    rep(s, c) {
                        if(E[s][i] == 0) continue;

                        ll sum = E[s][i];
                        ll res = F[s][i];

                        if(j + res &lt;= w) {
                            dp[i+1][j+res][k] = max(dp[i+1][j+res][k], dp[i][j][k] + sum);
                        }

                        REP(t, s + 1, c) {
                            if(E[t][i] == 0) break;

                            sum += E[t][i];
                            res += F[t][i];

                            if(j + res &lt;= w &amp;&amp; k + 1 &lt;= x) {
                                dp[i+1][j+res][k+1] = max(dp[i+1][j+res][k+1], dp[i][j][k] + sum);
                            }
                        }
                    }
                }
            }
        }

        // rep(i, d + 1) {
        //  cout &lt;&lt; " ----- day : " &lt;&lt; i &lt;&lt; endl;
        //  rep(j, w + 1) {
        //      rep(k, x + 1) {
        //          cout &lt;&lt; setw(3) &lt;&lt; dp[i][j][k] &lt;&lt; " ";
        //      }
        //      cout &lt;&lt; endl;
        //  }
        // }

        ll ans = 0;
        // rep(i, d + 1) {
            rep(j, w + 1) {
                rep(k, x + 1) {
                    ans = max(ans, dp[d][j][k]);
                }
            }
        // }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC013C 節制]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/03/abc013c-jie-zhi/"/>
    <updated>2016-04-03T17:31:07+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/03/abc013c-jie-zhi</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://abc013.contest.atcoder.jp/tasks/abc013_3">C: 節制 - AtCoder Beginner Contest 013 | AtCoder</a></h4><p>(null)</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<h3>部分点 1</h3>

<p><script type="math/tex; mode=display">
    dp[i][j] := i日目に満足度jの時の食費の最小値
</script>
として動的計画法．</p>

<ul>
<li>普通の食事 : <script type="math/tex"> dp[i+1][j+b] = {\rm max} (dp[i+1][j+b], dp[i][j] + a) </script></li>
<li>質素の食事 : <script type="math/tex"> dp[i+1][j+d] = {\rm max} (dp[i+1][j+d], dp[i][j] + c) </script></li>
<li>食事抜き : <script type="math/tex"> dp[i+1][j-e] = {\rm max} (dp[i+1][j-e], dp[i][j]) </script></li>
</ul>


<p>この <script type="math/tex"> 3 </script>つの遷移がある．食事抜きの場合に<script type="math/tex"> j-e </script>が <script type="math/tex"> 0 </script>より大きい場合に限ることに注意する．</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll dp[55][100005];

int main() {
    ll n, h;
    cin &gt;&gt; n &gt;&gt; h;

    ll a, b, c, d, e;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;

    rep(i, 55) {
        rep(j, 100005) {
            dp[i][j] = INF;
        }
    }
    dp[0][h] = 0;

    rep(i, n) {
        rep(j, 100005) {
            if(dp[i][j] == INF) continue;

            if(dp[i+1][j+b] == -1) {
                dp[i+1][j+b] = dp[i][j] + a;
            } else {
                dp[i+1][j+b] = min(dp[i+1][j+b], dp[i][j] + a);
            }

            if(dp[i+1][j+d] == -1) {
                dp[i+1][j+d] = dp[i][j] + c;
            } else {
                dp[i+1][j+d] = min(dp[i+1][j+d], dp[i][j] + c);
            }

            if(j - e &gt; 0) {
                if(dp[i+1][j-e] == -1) {
                    dp[i+1][j-e] = dp[i][j];
                } else {
                    dp[i+1][j-e] = min(dp[i+1][j-e], dp[i][j]);
                }
            }
        }
    }

    ll ans = INF;
    rep(i, 100005) {
        ans = min(ans, dp[n][i]);
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>

<h3>部分点2</h3>

<p>普通の食事の回数と，質素な食事の回数を決めれば，残りの日にちが食事抜きとなる．これが <script type="math/tex"> 0 </script>より大きければ，そのペアは存在する．その中で<script type="math/tex"> 普通の食事の回数 * a + 質素な食事の回数 * b </script>の最小を取る．</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    ll n, h;
    cin &gt;&gt; n &gt;&gt; h;

    ll a, b, c, d, e;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;

    ll ans = INF;
    rep(i, n + 1) {
        rep(j, n + 1) {
            if(i + j &gt; n) continue;
            int k = n - i - j;

            // cout &lt;&lt; h &lt;&lt; " " &lt;&lt; i * b &lt;&lt; " " &lt;&lt; j * d &lt;&lt; " " &lt;&lt; k * e &lt;&lt; "  -&gt;  " &lt;&lt; h + i * b + j * d - k * e &lt;&lt; endl;
            if(h + i * b + j * d - k * e &gt; 0) {
                ans = min(ans, i * a + j * c);
            }
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>

<h3>満点解法</h3>

<p>普通の食事の回数を決めれば，後は満足度は単調増加数列になる．この数列の中で初めて <script type="math/tex"> 0 </script>を超える時が，その普通の食事の回数の場合の最小金額である． <script type="math/tex"> O(N logN) </script>．</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1LL&lt;&lt;60
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    ll h;
    cin &gt;&gt; n &gt;&gt; h;

    ll a, b, c, d, e;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;

    ll ans = INF;
    for(ll i = 0; i &lt; n + 1; i++) {
        ll l = -1, r = n - i;
        while(r - l &gt; 1) {
            ll j = (l + r) / 2;
            ll k = n - i - j;

            if(h + i * b + j * d - k * e &gt; 0) {
                r = j;
            } else {
                l = j;
            }
        }

        ll res = i * a + (l + 1) * c;
        ans = min(ans, res);
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2166 Erratic Sleep Habits]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/24/aoj2166-erratic-sleep-habits/"/>
    <updated>2016-03-24T02:13:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/24/aoj2166-erratic-sleep-habits</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2166">Erratic Sleep Habits</a></h4><p>Peter is a person with erratic sleep habits. He goes to sleep at twelve o'lock every midnight. He gets up just after one hour of sleep on some days; he may even sleep for twenty-three hours on other days. His sleeping duration changes in a cycle, where he always sleeps for only one hour on the first day of the cycle.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>睡眠周期 <script type="math/tex"> T_i </script>が与えられる．カフェインを取ることでこの睡眠周期を最初に戻すことが出来るとき，全ての予定をこなせるカフェインの量の最大値を求める．<br/>
<script type="math/tex; mode=display">
    dp[i][j] := i日目に睡眠周期jの時のカフェインの最小値
</script>
とした． <script type="math/tex"> j = 0 </script>の場合は <script type="math/tex"> i-1 </script>のどこからでも <script type="math/tex"> +1 </script>(カフェインを取ること)で遷移できて，他の場合は <script type="math/tex"> T_j </script>が <script type="math/tex"> i </script>日目の一番最初の予定より早ければ， <script type="math/tex"> dp[i-1][j-1] </script>より遷移できる．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int t;
    while(cin &gt;&gt; t &amp;&amp; t) {

        vector&lt;int&gt; v(t);
        rep(i, t) cin &gt;&gt; v[i];

        int n;
        cin &gt;&gt; n;

        vector&lt;int&gt; d(n), m(n);
        int dm[105], day = 0;
        rep(i, 105) dm[i] = INF;

        rep(i, n) {
            cin &gt;&gt; d[i] &gt;&gt; m[i];
            dm[d[i]-1] = min(dm[d[i]-1], m[i]);
            day = max(day, d[i]);
        }

        int dp[105][35];
        rep(i, 105) rep(j, 35) dp[i][j] = INF;

        dp[0][0] = 0;

        REP(i, 1, day) {
            rep(j, t) {
                if(j == 0) {
                    rep(k, t) {
                        dp[i][j] = min(dp[i][j], dp[i-1][k] + 1);
                    }
                    dp[i][j] = min(dp[i][j], dp[i-1][t-1]);
                } else {
                    if(v[j] &lt;= dm[i]) {
                        dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
                    }
                }
            }
        }

        int ans = INF;
        rep(i, t) {
            ans = min(ans, dp[day-1][i]);
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1306 Balloon Collecting]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/23/aoj1306-balloon-collecting/"/>
    <updated>2016-03-23T21:01:17+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/23/aoj1306-balloon-collecting</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1306">Balloon Collecting</a></h4><p>"Balloons should be captured efficiently", the game designer says. He is designing an oldfashioned game with two dimensional graphics. In the game, balloons fall onto the ground one after another, and the player manipulates a robot vehicle on the ground to capture the balloons.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>動的計画法．</p>

<p><script type="math/tex; mode=display">
    dp[i][j] := i個目の風船をj個集めた時の時間の最小値
</script></p>

<p>として， <script type="math/tex"> j \leq 3 </script>の時に風船を取りに行って間に合うならば <script type="math/tex"> dp[i+1][j+1] </script>に遷移可能， 今ある風船を家に置きに行って，次の風船を取りに言って間に合うならば <script type="math/tex"> dp[i+1][1] </script>に遷移可能．<br/>
間に合うかどうかは，そのまま次のを取る<script type="math/tex">\to abs (p[i+1] - p[i]) \cdot (j + 1) </script>，家に置きに行って風船を次の風船を取る<script type="math/tex"> \to p[i] \cdot (j+1) + p[i+1] </script>が， <script type="math/tex"> t[i+1] - t[i] </script>より小さければ良い．<br/>
家に帰る，と次の風船を取りに行くを別々に考えていてどういう遷移か分からずめちゃくちゃ時間を溶かした．こういう考え方がすぐに出来るようになりたい．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int dp[50][4];

int main() {
    int n;
    while(cin &gt;&gt; n &amp;&amp; n) {

        vector&lt;int&gt; p(n + 1), t(n + 1);
        rep(i, n) cin &gt;&gt; p[i + 1] &gt;&gt; t[i + 1];

        rep(i, 50) rep(j, 4) dp[i][j] = INF;

        int id = -1;
        dp[0][0] = 0;
        rep(i, n) {
            int d = abs(p[i+1] - p[i]);
            bool flag = true;

            rep(j, 4) {
                if(dp[i][j] == INF) continue;

                if(j &lt; 3 &amp;&amp; d * (j + 1) &lt;= t[i+1] - t[i]) {
                    flag = false;
                    dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j] + d);
                }

                if(p[i] * (j + 1) + p[i+1] &lt;= t[i+1] - t[i]) {
                    flag = false;
                    dp[i+1][1] = min(dp[i+1][1], dp[i][j] + p[i] + p[i+1]);
                }
            }

            if(flag) {
                id = i+1;
                break;
            }
        }

        if(id != -1) cout &lt;&lt; "NG " &lt;&lt; id &lt;&lt; endl;
        else {
            int ans = INF;
            rep(j, 4) {
                ans = min(ans, dp[n][j] + p[n]);
            }
            cout &lt;&lt; "OK " &lt;&lt; ans &lt;&lt; endl;
        }
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2321 Butterfly]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj2321-butterfly/"/>
    <updated>2016-03-22T18:12:20+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj2321-butterfly</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2321">Butterfly</a></h4><p>Claire is a man-eater. She's a real man-eater. She's going around with dozens of guys. She's dating all the time. And one day she found some conflicts in her date schedule. D'oh! So she needs to pick some dates and give the others up. The dates are set by hours like 13:00 to 15:00.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>デートのもっとも満足度の高くなるスケジュールを組む． <script type="math/tex"> 6時を0 </script>ビットに当てて，デートの時間をビット集合<script type="math/tex"> S </script>と考える．</p>

<p><script type="math/tex; mode=display">
    dp[i][j] := i番目までの男と時間jにデート可能な時の満足度の最大値
</script>
とする．時間 <script type="math/tex"> j </script>と <script type="math/tex"> S[i] </script>の積集合が無い場合， 遷移可能(<script type="math/tex"> dp[i][j] + L[i] </script>)．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;bitset&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll dp[105][1 &lt;&lt; 16];
ll L[105], S[105];

int main() {
    int n;
    while(cin &gt;&gt; n &amp;&amp; n) {

        memset(L, 0, sizeof(L));
        memset(S, 0, sizeof(S));

        rep(i, n) {
            int m;
            cin &gt;&gt; m &gt;&gt; L[i];

            rep(j, m) {
                int s, t;
                cin &gt;&gt; s &gt;&gt; t;

                REP(k, s, t) {
                    S[i] |= 1 &lt;&lt; (k-6);
                }
            }
        }

        memset(dp, 0, sizeof(dp));

        rep(i, n) {
            rep(j, 1&lt;&lt;16) {
                dp[i+1][j] = max(dp[i+1][j], dp[i][j]);
            }

            rep(j, 1&lt;&lt;16) {
                if(j &amp; S[i]) continue;
                dp[i+1][j | S[i]] = max(dp[i+1][j | S[i]], dp[i][j] + L[i]);
            }
        }

        ll ans = 0;
        rep(i, n + 1) {
            rep(j, 1&lt;&lt;16) {
                ans = max(ans, dp[i][j]);
            }
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
