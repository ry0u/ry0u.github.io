<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 動的計画法 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/dong-de-ji-hua-fa/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-09-03T02:19:57+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM309 D1M KMonotonic]]></title>
    <link href="http://ry0u.github.io/blog/2016/09/03/srm309-d1m-kmonotonic/"/>
    <updated>2016-09-03T01:31:15+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/09/03/srm309-d1m-kmonotonic</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6516&rd=9989">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

数列を$K$個に分けた時に，それぞれの数列に狭義での単調増加数列か，単調減少数列にしたい．要素の値を$1$変更するには$1$コストがかかる時，その最小コストを求める．

---

区間$[l, r)$を単調増加，単調減少の数列にする最小コストがわかれば，後はどこで区切るか，何回区切るかを持ってメモ化再起すれば良いと分かったが，区間$[l, r)$の最小の出し方が分からなかった．解説を見てしまった．

<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://d.hatena.ne.jp/simezi_tan/20120613/1339542749">TopCoder SRM 309 Div1 Medium KMonotonic - simezi_tanの日記</a></h4><p>問題 n本の相異なる直線が与えられる。 n本の直線の集合の、点対称の中心の個数を求めよ。 無限にある場合..</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
単純に区間$[l, r)$だけを状態として持つわけではなく右端の値も持って

$$
	dp[l][r][k] := [l, r)の右端の値をk変更した時の最小値
$$

として動的計画法をした．この$k$変更するという範囲は$-n \sim n$までやっておけば大丈夫という勘違いをして，単調増加の場合には

```cpp
rep(i, n) {
	REP(j, i + 1, n) {
		REP(k, -n, n) {
			REP(l, -n, n) {
				int a = sequence[j-1] + k;
				int b = sequence[j] + l;

				if(a < b) {
					dp[i][j+1][l] = min(dp[i][j+1][l], dp[i][j][k] + abs(sequence[j] - l));
				}
			}
		}
	}
}
```
としていた．これでは$[0, 10000, 0]$といったようなケースには対応出来ないため，変化させるのは各要素に$-n \sim n$足したものを候補としなければならない．となると$n$個の要素に対して$-n \sim n$足した$2n ^2$個の候補が出来るため，上の方法では計算量が$n ^6$となってしまい間に合わない．$[l, r)$の右端が$k(index)$の時，単調増加数列になっているという時は$[l, r-1)$の右端が$k$より小さければ何でも良いので，一番小さいものからの遷移で大丈夫ということが分かる．

```cpp
rep(i, n) {
	int res = INF;
	rep(j, m) {
		res = min(res, abs(sequence[i] - v[j])); //それより以前にコストが少ないものがあればそれで良い
		dp[i][i+1][j] = res;
	}
}

rep(i, n) {
	REP(j, i + 1, n) {
		REP(k, 1, m) {
			dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j][k-1] + abs(sequence[j] - v[k])); //[l, r-1)の右端がv[k]より小さい時の最適コスト + jをv[k]に変えるコスト
			dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j+1][k-1]); // 以前より小さいものがあればそれを採用
		}
	}
}
```
後は区間$[l, r)$の最小コストは$k$に対してループを回した時の最小値となる．単調減少の場合は，候補のvectorをひっくり返して同じことをやった．これが出ると，あとは再起で区間$[l, r)$を残り$k$回分解しなければならない時の最小値として，区切る場所を全て試した．メモリが厳しくて適当に配列を取ったたらMLEした．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

int dp[50][51][50*51*2], up[55][55], down[55][55];

// int memo[50][51][50*51*2];

int dfs(int l, int r, int k) {
	if(dp[l][r][k] != -1) return dp[l][r][k];
	if(k == 1) return min(up[l][r], down[l][r]);

	int ret = INF;
	REP(i, l + 1, r) {
		ret = min(ret, dfs(l, i, 1) + dfs(i, r, k - 1));
	}

	return dp[l][r][k] = ret;
}

class KMonotonic {
	public:
	int transform(vector <int> sequence, int K) {
		int n = sequence.size();
		vector<int> v;
		rep(i, n) {
			REP(j, -n, n + 1) v.push_back(sequence[i] + j);
		}
		sort(v.begin(), v.end());
		v.erase(unique(v.begin(),v.end()),v.end());
		int m = v.size();

		{
			rep(i, 50) rep(j, 51) {
				up[i][j] = INF;
				rep(k, 50 * 51 * 2) dp[i][j][k] = INF;
			}

			rep(i, n) {
				int res = INF;
				rep(j, m) {
					res = min(res, abs(sequence[i] - v[j]));
					dp[i][i+1][j] = res;
				}
			}

			rep(i, n) {
				REP(j, i + 1, n) {
					REP(k, 1, m) {
						dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j][k-1] + abs(sequence[j] - v[k]));
						dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j+1][k-1]);
					}
				}
			}

			rep(i, n) {
				REP(j, i + 1, n + 1) {
					rep(k, m) {
						up[i][j] = min(up[i][j], dp[i][j][k]);
					}
				}
			}
		}
		{
			reverse(v.begin(), v.end());
			rep(i, 50) rep(j, 51) {
				down[i][j] = INF;
				rep(k, 50 * 51 * 2) dp[i][j][k] = INF;
			}

			rep(i, n) {
				int res = INF;
				rep(j, m) {
					res = min(res, abs(sequence[i] - v[j]));
					dp[i][i+1][j] = res;
				}
			}

			rep(i, n) {
				REP(j, i + 1, n) {
					REP(k, 1, m) {
						dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j][k-1] + abs(sequence[j] - v[k]));
						dp[i][j+1][k] = min(dp[i][j+1][k], dp[i][j+1][k-1]);
					}
				}
			}
			
			rep(i, n) {
				REP(j, i + 1, n + 1) {
					rep(k, m) {
						down[i][j] = min(down[i][j], dp[i][j][k]);
					}
				}
			}
		}

		rep(i, n) rep(j, n + 1) rep(k, m) dp[i][j][k] = -1;
		int ret = dfs(0, n, K);
		return ret;
	}

};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM308 D2H TreasuresPacking]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/31/srm308-d2h-treasurespacking/"/>
    <updated>2016-08-31T02:36:51+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/31/srm308-d2h-treasurespacking</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6476&rd=9988">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$weight, cost,$分割できるかどうかが与えられる．$W$まで持つことが出来る時の$cost$の最大値を求める．  
まず分割できないものを先に$dp[i][j] := i$番目まで見た時, 重さ$j$の時の最大値として動的計画法．分割出来るものは全て重さ$1$ずつに分けて，価値が高い順に使うのが良い．$dp[i][j] + (W - j)$個の分割したものを出してその最大値を取った．  

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

vector<string> split(const string &str, char delim) {
	vector<string> res;
	size_t current = 0, found;
	while((found = str.find_first_of(delim, current)) != string::npos) {
		res.push_back(string(str, current, found - current));
		current = found + 1;
	}
	res.push_back(string(str, current, str.size() - current));
	return res;
}

double dp[55][10005];

class TreasuresPacking {
	public:
	double maximizeCost(vector <string> treasures, int W) {
		vector<int> w, c;
		vector<double> v;

		rep(i, treasures.size()) {
			int a, b;
			vector<string> ret = split(treasures[i], ' ');

			{
				stringstream ss(ret[0]);
				ss >> a;
			}
			{
				stringstream ss(ret[1]);
				ss >> b;
			}

			if(ret[2] == "Y") {
				REP(i, 1, a + 1) {
					v.push_back(1.0 / a * b);
				}
			} else {
				w.push_back(a);
				c.push_back(b);
			}
		}

		sort(v.begin(), v.end(), greater<double>());
		v.insert(v.begin(), 0);
		REP(i, 1, v.size()) {
			v[i] += v[i-1];
		}

		int n = w.size();
		memset(dp, 0, sizeof(dp));

		rep(i, n) {
			rep(j, W + 1) {
				if(j - w[i] < 0) {
					dp[i+1][j] = dp[i][j];
				} else {
					dp[i+1][j] = max(dp[i][j], dp[i][j-w[i]] + c[i]);
				}
			}
		}

		double ans = 0;
		rep(j, W + 1) {
			int m = W - j;
			if(m < v.size()) {
				ans = max(ans, dp[n][j] + v[m]);
			}
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM306 D2H BlockDistance]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/25/srm306-d2h-blockdistance/"/>
    <updated>2016-08-25T13:58:16+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/25/srm306-d2h-blockdistance</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6417&rd=9986">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$oldText$に対してある文字列を挿入する操作をして$newText$にしたい．最小で何回の挿入で出来るか．出来ない場合は$-1$を出力する．

---

topcoderの制約上?なのかもしれないけど$oldText$, $newText$は分割されてvectorで来るので，どうせ連結するなら最初からその文字列を渡せば良いのに，と思った．

$$
	dp[i+1][j+1] := oldTextをi番目まででnewTextをj番目まで合わせる時の最小の挿入回数
$$

として動的計画法．文字列のindexを$1-indexed$にしたため，最終的に答える場所は$dp[|oldText|][|newText|]$．遷移は，$oldText[i]$と$newText[j]$が一致している時は何も挿入する必要がないので，そのまま$dp[i][j]$ $\to$ $dp[i+1][j+1]$．後はそこから何文字目まで合わせる挿入を行うかを探索して，例えば$k$文字目まで合わせるとすると$dp[i][j] + 1$ $\to$ $dp[i+1][j+1]$．これでは$oldText$の先頭に追加することは考えられるが，最後に挿入することが考えられていないので，番兵として$X$を末尾に追加して合わせるようにした．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int dp[1005][1005];

class BlockDistance {

    public:

    int minDist(vector <string> oldText, vector <string> newText) {
		rep(i, 1005) rep(j, 1005) dp[i][j] = INF;

		string s = "", t = "";
		rep(i, oldText.size()) s += oldText[i];
		rep(i, newText.size()) t += newText[i];
		s += "X";
		t += "X";

		dp[0][0] = 0;

		rep(i, s.size()) {
			rep(j, t.size()) {
				if(s[i] == t[j]) {
					dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j]);
				}

				REP(k, j+1, t.size()) {
					dp[i][k] = min(dp[i][k], dp[i][j] + 1);
				}
			}
		}

		if(dp[s.size()][t.size()] == INF) return -1;
		return dp[s.size()][t.size()];
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM304 D1M Conditional]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/24/srm304-d1m-conditional/"/>
    <updated>2016-08-24T00:34:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/24/srm304-d1m-conditional</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6412&rd=9825">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$maxSide$まであるサイコロを$nDice$個振った時，少なくとも$1$つは$v$が出て，$theSum$を超える確率を求める．

---

少なくとも$1$つ$v$が出るという条件が無ければ
```cpp
dp[0][0] = 1.0;
rep(i, nDice) {
	rep(j, 55 * 55) {
		REP(k, 1, maxSide) {
			dp[i+1][j + k] += dp[i][j] * (1.0 / maxSide);
		}
	}
}
```
として，$theSum$以上の和を取れば良いが，この条件がある場合は$v$が出た場合と出ない場合で分ける必要がある．そのためdpを

$$
\begin{eqnarray}
	dp[i][j][0] \&:=\& i個目のサイコロを振って和がjで，一回もvが出ない時の確率 \\\
	dp[i][j][1] \&:=\& i個目のサイコロを振って和がjで，少なくとも一回はvが出た時の確率
\end{eqnarray}
$$

として分けて考える．今まで$v$がでなくて，今回初めて$v$が出た時に$[1]$に遷移する．後は少なくとも$1$つ$v$が出る確率を出して割れば良い．この確率は$(1 - vが一回も出ない確率)$として出した．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

double dp[55][55 * 55][2];

class Conditional {

    public:

    double probability(int nDice, int maxSide, int v, int theSum) {
		memset(dp, 0, sizeof(dp));
		dp[0][0][0] = 1.0;

		rep(i, nDice) {
			rep(j, 55 * 55) {
				REP(k, 1, maxSide + 1) {
					if(j + k >= 55 * 55) continue;
					dp[i+1][j + k][1] += dp[i][j][1] * (1.0 / maxSide);

					if(k == v) {
						dp[i+1][j + k][1] += dp[i][j][0] * (1.0 / maxSide);
					} else {
						dp[i+1][j + k][0] += dp[i][j][0] * (1.0 / maxSide);
					}
				}
			}
		}

		double ans = 0.0;
		REP(i, theSum, 55 * 55) {
			ans += dp[nDice][i][1];
		}

		double t = 1.0;
		rep(i, nDice) {
			t *= double(maxSide - 1) / maxSide;
		}

		return ans / (1 - t);
    }

};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM304 D1E-D2H PolyMove]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/23/srm304-d1e-d2h-polymove/"/>
    <updated>2016-08-23T23:43:47+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/23/srm304-d1e-d2h-polymove</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6190&rd=9825">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

凸包が与えられる．隣り合わない点を選び，距離が$1$以下なら移動することができる．この条件の時に最大面積の増加分を答える

---
正六角形の場合を考えてみた．

{% img /images/SRM/304-01.png %}

右上の点について考える．

{% img /images/SRM/304-02.png %}

まずは移動しない場合の青の部分の面積を出してみる．

{% img /images/SRM/304-03.png %}

この面積を出すには赤の線を底辺$a$として，緑の線を高さ$h$とすると，$\frac{ah}{2}$である．

{% img /images/SRM/304-05.png %}

ここからこの点を移動することを考えるが，移動後の三角形もこの式で計算出来るため$h$を最大にすれば良い．最大の$h$とは，底辺に対して垂直に伸ばせば良いので，新しい三角形の高さは$h + 1$となる．つまり緑の点の場所に移動する．

{% img /images/SRM/304-06.png %}

次に面積の増加分を求める．増加した部分は緑の場所である．

{% img /images/SRM/304-07.png %}

これは移動後の三角形(赤)から移動前の三角形(青)を引けば出てくる．

{% img /images/SRM/304-08.png %}
{% img /images/SRM/304-09.png %}
{% img /images/SRM/304-10.png %}

$\frac{a(h + 1)}{2} - \frac{ah}{2} = \frac{a}{2}$となり，高さが分かる必要がないことが分かる．後は移動する点が隣り合わないという条件を満たすようにdpで計算していく．

$$
	dp[i][j] := 点\_{i}まで見て，点\_{i}を移動した場合はj=1, していない場合はj=0とした時の増加分の最大
$$

$0$と$n-1$番目が隣接しているため，$0$を使って$n-1$を見ないパターンと，$1$から始めて$n-1$まで見るパターンをやる．下の図は移動した場合の点が緑で，遷移が線となる．割り当てた状態をtextで書いてみた．

{% img /images/SRM/304-14.png %}

この場合は以下の$2$つが答えとなる．

{% img /images/SRM/304-12.png %}
{% img /images/SRM/304-13.png %}

# Code

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

double dp[55][2];

class PolyMove {
	public:
	double addedArea(vector <int> x, vector <int> y) {
		int n = x.size();
		memset(dp, 0, sizeof(dp));

		REP(i, 1, n) {
			int j = (i - 1 + n) % n;
			int k = (i + 1 + n) % n;

			dp[i][0] = max(dp[j][0], dp[j][1]);
			dp[i][1] = dp[j][0] + sqrt((x[j] - x[k]) * (x[j] - x[k]) + (y[j] - y[k]) * (y[j] - y[k]));
		}

		double ans = 0;
		rep(i, n) {
			rep(j, 2) {
				ans = max(ans, dp[i][j]);
			}
		}

		memset(dp, 0, sizeof(dp));
		rep(i, n - 1) {
			int j = (i - 1 + n) % n;
			int k = (i + 1 + n) % n;

			dp[i][0] = max(dp[j][0], dp[j][1]);
			dp[i][1] = dp[j][0] + sqrt((x[j] - x[k]) * (x[j] - x[k]) + (y[j] - y[k]) * (y[j] - y[k]));
		}

		rep(i, n) {
			rep(j, 2) {
				ans = max(ans, dp[i][j]);
			}
		}

		return ans / 2;
	}
};
```

]]></content>
  </entry>
  
</feed>
