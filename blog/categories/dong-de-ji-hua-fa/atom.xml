<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 動的計画法 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/dong-de-ji-hua-fa/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-15T23:55:03+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM684D2M DivFreed2]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/15/srm684d2m-divfreed2/"/>
    <updated>2016-03-15T23:11:13+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/15/srm684d2m-divfreed2</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14186&rd=16688">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>数列の隣り合う全ての要素<script type="math/tex"> A(1 \leq A \leq k), B(1 \leq B \leq k) </script>が</p>

<ul>
<li><script type="math/tex"> A \leq B </script></li>
<li><script type="math/tex"> A \ \rm{mod} \  B \neq 0 </script></li>
</ul>


<p>のどちらかを満たす数列の数を<script type="math/tex"> \rm{mod} \ 10 ^9 + 7 </script> で求める．</p>

<hr />

<p><script type="math/tex; mode=display">
    dp[i][j] := i番目にjを選んだ時の数列の数
</script></p>

<p>とする．数列に追加する可能なものを選ぶので<script type="math/tex"> B </script>から考えると，<script type="math/tex"> B </script>より大きい，または<script type="math/tex"> AがB </script>を約数に持たなければ良い．基本的に全て遷移可能として(<script type="math/tex"> dp[i+1][j] += \sum_{l = 1} ^{k} dp[i][l]</script>)，後に約数の場所の遷移を無かったことにすれば良い．</p>

<h1>Code</h1>

<pre><code class="cpp">ll dp[15][100005];
vector&lt;ll&gt; d[100005];

vector&lt;ll&gt; divisor(ll n) {
    vector&lt;ll&gt; res;
    for(ll i = 2; i*i &lt;= n; i++) {
        if(n % i == 0) {
            res.push_back(i);
            if(i != n/i) res.push_back(n/i);
        }
    }
    return res;
}

class DivFreed2 {
    public:
    int count(int n, int k) {
        memset(dp, 0, sizeof(dp));

        rep(i, k + 1) {
            d[i].clear();
        }

        REP(i, 2, k + 1) {
            vector&lt;ll&gt; ret = divisor(i);
            ret.push_back(1);

            d[i].resize(ret.size());
            rep(j, ret.size()) {
                d[i][j] = ret[j];
            }
        }

        REP(i, 1, k + 1) {
            dp[1][i] = 1;
        }

        REP(i, 1, n) {
            ll sum = 0;
            REP(j, 1, k + 1) {
                sum += dp[i][j];
                sum %= MOD;
            }

            REP(j, 1, k + 1) {
                dp[i+1][j] += sum;
                dp[i+1][j] %= MOD;
            }

            REP(j, 1, k + 1) {
                rep(l, d[j].size()) {
                    dp[i+1][d[j][l]] -= dp[i][j];
                }
            }
        }

        ll ans = 0;
        rep(j, k + 1) {
            ans += dp[n][j];
            ans %= MOD;
        }

        return ans;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0599 IOI Manju]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/08/aoj0599-ioi-manju/"/>
    <updated>2016-03-08T15:01:46+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/08/aoj0599-ioi-manju</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0599">IOI Manju | Aizu Online Judge</a></h4><p>ところで，あなたはJust Odd Inventions 社を知っているだろうか？ この会社の業務は「ただ奇妙な発明(just odd inventions)」をすることである．ここでは略してJOI 社と呼ぶ．IOI 社は，饅頭を詰めるための高級な箱をJOI 社に発注することになった．JOI 社の製作する饅頭用の箱は$N$ 種類あり， $j$ 番目$(1 \leq j \leq N)$の箱は最大で$C_j$ 個の饅頭を詰められる大きさであり，販売価格は$E_j$ 円である．これらの$N$ 種類の箱のうちの何種類か(0 種類以上$N$ 種類以下) を1 個ずつ発注し，饅頭をそれらの箱に詰め分けてセットで販売することになった．各饅頭セットの価格は，それに含まれる饅頭の価格の合計である．</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>饅頭<script type="math/tex"> i </script>から饅頭<script type="math/tex"> j </script>まで選んだ時の価格が欲しいので，累積和を取っておく．<br/>
<script type="math/tex; mode=display">
    dp[i][j] := i番目以内の箱を使い，饅頭jまで詰めた時の最大値
</script>
とする．<script type="math/tex"> i </script>番目の箱を</p>

<ul>
<li>使う遷移は，<script type="math/tex"> dp[i][j]+(d[j+c[i]]-d[j])-e[i]</script></li>
<li>使わない遷移は<script type="math/tex"> dp[i][j+c[i]]</script>．</li>
</ul>


<p><img src="/images/AOJ/0599.png"></p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll dp[505][10005];

int main() {
    int m, n;
    cin &gt;&gt; m &gt;&gt; n;

    vector&lt;int&gt; v(m);
    rep(i, m) cin &gt;&gt; v[i];

    vector&lt;P&gt; p(n);
    rep(i, n) {
        cin &gt;&gt; p[i].first &gt;&gt; p[i].second;
    }

    sort(v.begin(), v.end(), greater&lt;int&gt;());

    int d[10005];
    memset(d, 0, sizeof(d));
    REP(i, 1, m + 1) {
        d[i] += d[i-1] + v[i-1];
    }

    memset(dp, 0, sizeof(dp));
    rep(i, 505) {
        rep(j, 10005) dp[i][j]  = -1;
    }

    dp[0][0] = 0;

    rep(i, n) {
        rep(j, m + 1) {
            dp[i+1][j] = max(dp[i+1][j], dp[i][j]);
        }

        rep(j, m) {
            if(dp[i][j] == -1) continue;

            int id = j + p[i].first;
            id = min(id, m);
            dp[i+1][id] = max(dp[i+1][id], max(dp[i][id], dp[i][j] + (d[id] - d[j]) - p[i].second));
        }
    }


    ll ans = 0;
    rep(i, n + 1) {
        rep(j, m + 1) {
            ans = max(ans, dp[i][j]);
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0595 Schedule]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/06/aoj0595-schedule/"/>
    <updated>2016-03-06T01:11:01+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/06/aoj0595-schedule</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0595">Schedule | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>J君，O君，I君がいるかいないかを3ビットで持つ．
<script type="math/tex; mode=display">
    dp[i][j] := i日目に状態jの場合のスケジュール表として考えられるものの数
</script>
とする．</p>

<ul>
<li><p><script type="math/tex"> i </script>日目の鍵当番がいるか<br/>
<script type="math/tex; mode=display">
  j \ &amp; \ (1 &lt;&lt; d)
</script></p></li>
<li><p><script type="math/tex"> i-1日目に鍵を持ち帰れた人がいるか </script>
<script type="math/tex; mode=display">
  j \ &amp; \ k
</script></p></li>
</ul>


<p>この条件を満たす場合に遷移可能．<script type="math/tex"> O(n \cdot 2 ^3 \cdot 2 ^3) </script>．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;bitset&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair
#define MOD 10007

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll dp[1005][8];

int main() {
    int n;
    cin &gt;&gt; n;

    string s;
    cin &gt;&gt; s;

    map&lt;char, int&gt; id;
    id['J'] = 2; id['O'] = 1, id['I'] = 0;

    memset(dp, 0, sizeof(dp));
    dp[0][1 &lt;&lt; 2] = 1;

    REP(i, 1, n + 1) {
        int d = id[ s[i-1] ];
        rep(j, 1 &lt;&lt; 3) {
            if(!(j &amp; (1 &lt;&lt; d))) continue;
            rep(k, 1 &lt;&lt; 3) {
                if(j &amp; k) { 
                    dp[i][j] += dp[i-1][k];
                    dp[i][j] %= MOD;
                }
            }
        }
    }

    ll ans = 0;
    rep(i, 1 &lt;&lt; 3) {
        ans += dp[n][i];
    }

    cout &lt;&lt; ans % MOD &lt;&lt; endl;


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manthan, Codefest 16C Spy Syndrome 2]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16c-spy-syndrome-2/"/>
    <updated>2016-02-29T15:32:14+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16c-spy-syndrome-2</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-chrome="0" data-card-controls="0"><h4><a href="http://codeforces.com/contest/633/problem/C">Problem - C - Codeforces</a></h4><p>After observing the results of Spy Syndrome, Yash realised the errors of his ways. He now believes that a super spy such as Siddhant can't use a cipher as basic and ancient as Caesar cipher. After many weeks of observation of Siddhant's sentences, Yash determined a new cipher technique.</p></blockquote>




<!-- more -->


<p>原文を全て小文字にしてreverseして，接合した文を復元する．<br/>
まずTrie木を作って文字列が単語リストにあるかを判定出来るようにする．<br/>
次に，
<script type="math/tex; mode=display">
    dp[i] := i番目の文字まで復元可能
</script>
とする．Trieのfind関数にその単語そのものがあればTrue, また現在のノードがendであり，その場所の<script type="math/tex"> dp[i] </script>をみて復元可能な時にTrueを返す．その文字列を<script type="math/tex"> S[i] </script>にとっておく．<br/>
後は末尾から帰ってくれば原文の単語の逆順がわかるのでreverseする．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

string S[10005], ret = "", res = "";
bool dp[10005];

struct Trie {
    Trie *next[26];
    bool end;

    Trie() {
        fill(next,next+26,(Trie *)0);
        end = false;
    }

    void insert(string &amp;s,int i) {
        if(i == s.size()) {
            this-&gt;end = true;
            return;
        }

        if(this-&gt;next[s[i]-'a'] == NULL) {
            this-&gt;next[s[i]-'a'] = new Trie();
        }

        this-&gt;next[s[i]-'a']-&gt;insert(s,i+1);
    }

    bool find(int s, int i) {
        if(s - i &gt;= 0 &amp;&amp; dp[s - i] &amp;&amp; this-&gt;end) {
            string t = "";
            rep(j, i) {
                t += ret[s-j];
            }
            res = t;
            return true;
        }

        if((s + 1) - i == 0) {
            if(this-&gt;end) {
                string t = "";
                rep(j, i) {
                    t += ret[s-j];
                }
                res = t;
                return true;
            }
            else return false;
        }

        if(this-&gt;next[ret[s-i]-'a'] != NULL) {
            if(this-&gt;next[ret[s-i]-'a']-&gt;find(s, i+1)) return true;
        }

        return false;
    }
};


int main() {
    int n;
    cin &gt;&gt; n;

    string s;
    cin &gt;&gt; s;

    int m;
    cin &gt;&gt; m;

    vector&lt;string&gt; v(m);
    map&lt;string, string&gt; f;
    Trie *trie = new Trie();

    rep(i, m) {
        cin &gt;&gt; v[i];

        string t = v[i];
        rep(j, t.size()) {
            t[j] = tolower(t[j]);
        }

        f[t] = v[i];
        trie-&gt;insert(t, 0);
    }

    memset(dp, 0, sizeof(dp));

    rep(i, n) {
        ret = ret + s[i];

        if(trie-&gt;find(i, 0)) {
            S[i] = f[res];
            dp[i] = true;
        }
    }

    vector&lt;string&gt; ans;
    int cur = n-1;
    while(dp[cur]) {
        string t = S[cur];
        ans.push_back(t);
        cur -= t.size();
    }

    reverse(ans.begin(), ans.end());

    rep(i, ans.size()) {
        cout &lt;&lt; ans[i];
        if(i == ans.size()-1) cout &lt;&lt; endl;
        else cout &lt;&lt; " ";
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manthan, Codefest 16A Ebony and lvory]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16-a-ebony-and-lvory/"/>
    <updated>2016-02-29T10:27:42+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16-a-ebony-and-lvory</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-chrome="0" data-card-controls="0"><h4><a href="http://codeforces.com/contest/633/problem/A">Problem - A - Codeforces</a></h4><p>Dante is engaged in a fight with "The Savior". Before he can fight it with his sword, he needs to break its shields. He has two guns, Ebony and Ivory, each of them is able to perform any non-negative number of shots.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more-->


<p><script type="math/tex; mode=display">
    a, bを用いてcを表せるか．使用回数は0でも良い．
</script></p>

<p><script type="math/tex; mode=display">
    iが表せるならi+a, i+bも表すことが出来る．O(\max&copy;)
</script></p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

bool used[10500];

int main() {
    int a, b, c;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;

    memset(used, 0, sizeof(used));
    used[0] = true;

    rep(i, c + 1) {
        if(used[i]) {
            used[i+a] = true;
        }
    }

    rep(i, c + 1) {
        if(used[i]) {
            used[i+b] = true;
        }
    }

    if(used[c]) cout &lt;&lt; "Yes" &lt;&lt; endl;
    else cout &lt;&lt; "No" &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
