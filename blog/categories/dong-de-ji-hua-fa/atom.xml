<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 動的計画法 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/dong-de-ji-hua-fa/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-04T17:26:15+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Manthan, Codefest 16C Spy Syndrome 2]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16c-spy-syndrome-2/"/>
    <updated>2016-02-29T15:32:14+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16c-spy-syndrome-2</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-chrome="0" data-card-controls="0"><h4><a href="http://codeforces.com/contest/633/problem/C">Problem - C - Codeforces</a></h4><p>After observing the results of Spy Syndrome, Yash realised the errors of his ways. He now believes that a super spy such as Siddhant can't use a cipher as basic and ancient as Caesar cipher. After many weeks of observation of Siddhant's sentences, Yash determined a new cipher technique.</p></blockquote>




<!-- more -->


<p>原文を全て小文字にしてreverseして，接合した文を復元する．<br/>
まずTrie木を作って文字列が単語リストにあるかを判定出来るようにする．<br/>
次に，
<script type="math/tex; mode=display">
    dp[i] := i番目の文字まで復元可能
</script>
とする．Trieのfind関数にその単語そのものがあればTrue, また現在のノードがendであり，その場所の<script type="math/tex"> dp[i] </script>をみて復元可能な時にTrueを返す．その文字列を<script type="math/tex"> S[i] </script>にとっておく．<br/>
後は末尾から帰ってくれば原文の単語の逆順がわかるのでreverseする．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

string S[10005], ret = "", res = "";
bool dp[10005];

struct Trie {
    Trie *next[26];
    bool end;

    Trie() {
        fill(next,next+26,(Trie *)0);
        end = false;
    }

    void insert(string &amp;s,int i) {
        if(i == s.size()) {
            this-&gt;end = true;
            return;
        }

        if(this-&gt;next[s[i]-'a'] == NULL) {
            this-&gt;next[s[i]-'a'] = new Trie();
        }

        this-&gt;next[s[i]-'a']-&gt;insert(s,i+1);
    }

    bool find(int s, int i) {
        if(s - i &gt;= 0 &amp;&amp; dp[s - i] &amp;&amp; this-&gt;end) {
            string t = "";
            rep(j, i) {
                t += ret[s-j];
            }
            res = t;
            return true;
        }

        if((s + 1) - i == 0) {
            if(this-&gt;end) {
                string t = "";
                rep(j, i) {
                    t += ret[s-j];
                }
                res = t;
                return true;
            }
            else return false;
        }

        if(this-&gt;next[ret[s-i]-'a'] != NULL) {
            if(this-&gt;next[ret[s-i]-'a']-&gt;find(s, i+1)) return true;
        }

        return false;
    }
};


int main() {
    int n;
    cin &gt;&gt; n;

    string s;
    cin &gt;&gt; s;

    int m;
    cin &gt;&gt; m;

    vector&lt;string&gt; v(m);
    map&lt;string, string&gt; f;
    Trie *trie = new Trie();

    rep(i, m) {
        cin &gt;&gt; v[i];

        string t = v[i];
        rep(j, t.size()) {
            t[j] = tolower(t[j]);
        }

        f[t] = v[i];
        trie-&gt;insert(t, 0);
    }

    memset(dp, 0, sizeof(dp));

    rep(i, n) {
        ret = ret + s[i];

        if(trie-&gt;find(i, 0)) {
            S[i] = f[res];
            dp[i] = true;
        }
    }

    vector&lt;string&gt; ans;
    int cur = n-1;
    while(dp[cur]) {
        string t = S[cur];
        ans.push_back(t);
        cur -= t.size();
    }

    reverse(ans.begin(), ans.end());

    rep(i, ans.size()) {
        cout &lt;&lt; ans[i];
        if(i == ans.size()-1) cout &lt;&lt; endl;
        else cout &lt;&lt; " ";
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manthan, Codefest 16A Ebony and lvory]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16-a-ebony-and-lvory/"/>
    <updated>2016-02-29T10:27:42+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16-a-ebony-and-lvory</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-chrome="0" data-card-controls="0"><h4><a href="http://codeforces.com/contest/633/problem/A">Problem - A - Codeforces</a></h4><p>Dante is engaged in a fight with "The Savior". Before he can fight it with his sword, he needs to break its shields. He has two guns, Ebony and Ivory, each of them is able to perform any non-negative number of shots.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more-->


<p><script type="math/tex; mode=display">
    a, bを用いてcを表せるか．使用回数は0でも良い．
</script></p>

<p><script type="math/tex; mode=display">
    iが表せるならi+a, i+bも表すことが出来る．O(\max&copy;)
</script></p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

bool used[10500];

int main() {
    int a, b, c;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;

    memset(used, 0, sizeof(used));
    used[0] = true;

    rep(i, c + 1) {
        if(used[i]) {
            used[i+a] = true;
        }
    }

    rep(i, c + 1) {
        if(used[i]) {
            used[i+b] = true;
        }
    }

    if(used[c]) cout &lt;&lt; "Yes" &lt;&lt; endl;
    else cout &lt;&lt; "No" &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM682 D2H FriendlyRobot]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/srm682-d2h-friendlyrobot/"/>
    <updated>2016-02-29T01:13:10+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/srm682-d2h-friendlyrobot</id>
    <content type="html"><![CDATA[<p>文字列<script type="math/tex"> U,D,R,L </script>の命令で動くロボットがある．この文字列を<script type="math/tex"> K </script>回書き換えられることが出来るときに，最大で何回<script type="math/tex">(0,0)</script>を通ることが出来るか．</p>

<!-- more -->


<hr />

<p>移動回数が奇数回の時に<script type="math/tex"> (0,0) </script>に戻ることは出来ない．また偶数回の場合でも横方向，縦方向の移動量が共に偶数回，共に奇数回の場合のみ戻ることが出来る．<br/>
また，<script type="math/tex"> +を-に，-を+</script>に変えることで<script type="math/tex"> 2 </script>移動量が変わる．<br/>
そして，戻るために命令を書き換えなければならない回数も以下のように一意に求まる．
<script type="math/tex; mode=display">
\begin{eqnarray}
    共に偶数回 &amp;:=&amp;  \frac{横方向}{2} + \frac{縦方向}{2} \
    共に奇数回 &amp;:=&amp;  \frac{横方向}{2} + \frac{縦方向}{2} + 1\
\end{eqnarray}
</script>
共に奇数回の場合に<script type="math/tex"> +1 </script>されるのは，例えば命令が<script type="math/tex"> UR </script>の場合に<script type="math/tex"> UD </script>に書き換えることで<script type="math/tex"> (0, 0) </script>に戻れるためである．</p>

<p>これより
<script type="math/tex; mode=display">
    dp[i][j] := i番目までの命令列をj回変更した時の(0, 0)を訪れる最大値
</script>
として，総当りしてmaxを取った．</p>

<h1>Code</h1>

<pre><code class="cpp">    public:
    int findMaximumReturns(string s, int K) {

        vector&lt;int&gt; X(s.size() + 1), Y(s.size() + 1);
        int x = 0, y = 0;
        rep(i, s.size()) {
            if(s[i] == 'U') y++;
            if(s[i] == 'D') y--;
            if(s[i] == 'R') x++;
            if(s[i] == 'L') x--;

            X[i+1] = x; Y[i+1] = y;
        }

        rep(i, s.size() + 1) {
            rep(j, K + 1) {
                dp[i][j] = -1;
            }
        }
        dp[0][0] = 0;

        rep(i, s.size() + 1) {
            rep(j, K + 1) {
                if(dp[i][j] == -1) continue;
                for(int k = i + 2; k &lt; s.size() + 1; k += 2) {
                    int s = abs(X[k] - X[i]), t = abs(Y[k] - Y[i]);
                    int res = 0;

                    if(s % 2 == 0 &amp;&amp; t % 2 == 1) continue;
                    if(s % 2 == 1 &amp;&amp; t % 2 == 0) continue;
                    if(s % 2 == 0 &amp;&amp; t % 2 == 0) res = s / 2 + t / 2;
                    if(s % 2 == 1 &amp;&amp; t % 2 == 1) res = s / 2 + t / 2 + 1;

                    if(j + res &gt; K) continue;
                    dp[k][j + res] = max(dp[k][j + res], dp[i][j] + 1);
                }
            }
        }

        ll ans = 0;
        rep(i, s.size() + 1) {
            rep(j, K + 1) {
                ans = max(ans, dp[i][j]);
            }
        }

        return ans;
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0579 Hot days]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/22/aoj0579-hot-days/"/>
    <updated>2016-02-22T22:24:12+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/22/aoj0579-hot-days</id>
    <content type="html"><![CDATA[<p>問題文<br/>
<a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0579">http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0579</a></p>

<!-- more -->


<p><script type="math/tex; mode=display">
    dp[i][j] := i日目に服jを着た時の最大値 \
</script>
として，最大化したい値は</p>

<p><script type="math/tex; mode=display">
    |C<em>{x_1} - C</em>{x_2}| + |C<em>{x_2} - C</em>{x_3}| + \cdots +  |C<em>{x</em>{D-1}} - C_{x_D}|
</script></p>

<p>なので，<script type="math/tex"> 1日目に切れる服には0を入れておき， i-1日目からi日目に遷移する．(2 \leq i \leq D)</script><br/>
遷移可能(<script type="math/tex">i</script>日目の最高気温によって服が着れるか着れないか)な場合，<script type="math/tex">i-1</script>日目に何を着ていた場合が値が最大になるかを選ぶ．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int d, n;
    cin &gt;&gt; d &gt;&gt; n;

    vector&lt;int&gt; t(d);
    rep(i, d) cin &gt;&gt; t[i];

    vector&lt;int&gt; a(n), b(n), c(n);
    rep(i, n) cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];

    int dp[205][205];
    rep(i, 205) rep(j, 205) dp[i][j] = -1;

    rep(i, n) {
        if(a[i] &lt;= t[0] &amp;&amp; t[0] &lt;= b[i]) dp[0][i] = 0;
    }

    REP(i, 1, d) {
        rep(j, n) {
            if(a[j] &lt;= t[i] &amp;&amp; t[i] &lt;= b[j]) {
                rep(k, n) {
                    if(dp[i-1][k] == -1) continue;
                    dp[i][j] = max(dp[i][j], dp[i-1][k] + abs(c[k] - c[j]));
                }
            }
        }
    }

    int ans = 0;
    rep(i, n) {
        ans = max(ans, dp[d-1][i]);
    }

    cout &lt;&lt; ans &lt;&lt; endl;


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0573 Night Market]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/16/aoj0573-night-market/"/>
    <updated>2016-02-16T23:20:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/16/aoj0573-night-market</id>
    <content type="html"><![CDATA[<p>問題文<br/>
<a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0573">http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0573</a></p>

<!-- more -->


<p>ずっとグラフだろうと考えていた．
頂点を(楽しさ，時間)で持って，indexが大きい頂点にコストを時間とした辺を貼ったグラフを作っても，何を優先度にしてどう探索するか分からない．<br/>
最短時間を求めてながら楽しさを更新しても，時間が長く楽しさが非常に高い辺が来たら答えが合わないことに気づき，ダメ．</p>

<p>時間に注目してみた．ある時間での楽しさの最大値を考えるとナップサックのDPになった．indexの小さい順に訪れるというのは，与えられた順に<script type="math/tex"> i</script>番目のお店以内，と考えれば解決で，花火の時間について時刻<script type="math/tex"> S </script>をまたがる遷移をやめれば良さそうである．</p>

<p><script type="math/tex; mode=display">
    dp[i][j] := i番目以内のお店で，時刻jまで遊んだ時の楽しさの最大値
</script>
として，花火の時間をまたがる遷移をやめ，その最大値を求めたらACした．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair
#define mpp(t1, t2, t3, t4) mp(mp(t1, t2), mp(t3, t4))

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;
typedef pair&lt;P, P&gt; PP;

int dp[3005][3005];

int main() {
    int n, t, s;
    cin &gt;&gt; n &gt;&gt; t &gt;&gt; s;

    vector&lt;P&gt; v(n);
    rep(i, n) {
        cin &gt;&gt; v[i].first &gt;&gt; v[i].second;
    }

    memset(dp, 0, sizeof(dp));

    REP(i, 0, n) {
        rep(j, t + 1) {
            if(j - v[i].second &lt; 0 || (j - v[i].second &lt; s &amp;&amp; s &lt; j) ) {
                dp[i+1][j] = dp[i][j];
            } else {
                dp[i+1][j] = max(dp[i][j], dp[i][j-v[i].second] + v[i].first);
            }
        }
    }

    int ans = 0;
    rep(i, n + 1 ) {
        rep(j, t + 1) {
            ans = max(ans, dp[i][j]);
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
