<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 動的計画法 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/dong-de-ji-hua-fa/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-01-28T01:43:17+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ARC043-B 難易度]]></title>
    <link href="http://ry0u.github.io/blog/2015/10/25/arc043-b-nan-yi-du/"/>
    <updated>2015-10-25T01:41:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/10/25/arc043-b-nan-yi-du</id>
    <content type="html"><![CDATA[<p>難易度の2倍以上の問題に対して選ぶことが出来る．<br/>
まずは，難易度でソート．<br/>
今見ている問題数をiとすると，i+1問目でその問題を選ぶことが出来る場所に足していく．</p>

<p><img src="/images/Atcoder/001/g.png"><br/>
縦を問題，横を問題数と見て，遷移出来る場所を見つけたい．これを愚直に探すと，探索に<script type="math/tex"> n </script>かかってしまう．しかし，難易度でソートされているので，lower_boundで<script type="math/tex"> log(n) </script>で見つけることが出来る．最初に見つけた場所に足していって，累積和を取った．全体で<script type="math/tex"> O(nlog(n)) </script>で間に合う．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair
#define MOD 1000000007

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    ll vmax = 0;
    vector&lt;ll&gt; v(n);
    rep(i,n) {
        cin &gt;&gt; v[i];
        vmax = max(vmax, v[i]);
    }

    sort(v.begin(), v.end());

    ll cnt[100005][4];
    memset(cnt, 0, sizeof(cnt)) ;

    rep(i,n) {
        cnt[i][0]++;
    }

    rep(i,3) {
        rep(j,n) {
            if(v[j]*2 &gt; vmax) continue;
            int id = lower_bound(v.begin(), v.end(), v[j]*2) - v.begin();

            cnt[id][i+1] += cnt[j][i];
            cnt[id][i+1] %= MOD;
        }

        REP(j,1,n) {
            cnt[j][i+1] += cnt[j-1][i+1];
            cnt[j][i+1] %= MOD;
        }
    }

    ll ans = 0;
    rep(i,n) {
        ans += cnt[i][3];
        ans %= MOD;
    }
    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>2倍するので，オーバーフローしてWA．llに直した時に，cntの初期化を消してしまったらしく，それに気づかずWAを連発してしまった．．．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yukicoder No.45 回転寿司]]></title>
    <link href="http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-45-hui-zhuan-shou-si/"/>
    <updated>2015-09-03T14:00:37+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-45-hui-zhuan-shou-si</id>
    <content type="html"><![CDATA[<p><a href="http://yukicoder.me/problems/78">http://yukicoder.me/problems/78</a></p>

<h1>考察</h1>

<p>動的計画法で解く．[i][0]をi番目を取らない，[i][1]をi番目を取るとして，dp[i][j]をi番目までの最大値とする．dp[i][0] = max(i-1番目を取った，i-2番目を取った)，dp[i][1] = max(i-1番目を取らない+i番目の価値，i-2番目を取った+i番目の価値)で求める．</p>

<p><script type="math/tex; mode=display">
\begin{eqnarray}
\begin{cases}
dp[0][1] = v[0] \
dp[1][0] = v[0] \
dp[1][1] = v[1] \
dp[i][0] = max(dp[i-1][1],dp[i-2][1]) (i \geq 2) \
dp[i][1] = max(dp[i-1][0]+v[i],dp[i-2][1]+v[i]) (i \geq 2)
\end{cases}
\end{eqnarray}
</script></p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; v(n);
    rep(i,n) cin &gt;&gt; v[i];

    int dp[1005][2];
    memset(dp,0,sizeof(dp));

    dp[0][1] = v[0];
    dp[1][0] = v[0];
    dp[1][1] = v[1];

    REP(i,2,n) {
        dp[i][0] = max(dp[i-1][1],dp[i-2][1]);
        dp[i][1] = max(dp[i-1][0] + v[i],dp[i-2][1] + v[i]);
    }

    cout &lt;&lt; max(dp[n-1][0],dp[n-1][1]) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yukicoder No.44 DPなすごろく]]></title>
    <link href="http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-44-dpnasugoroku/"/>
    <updated>2015-09-03T13:53:47+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-44-dpnasugoroku</id>
    <content type="html"><![CDATA[<p><a href="http://yukicoder.me/problems/76">http://yukicoder.me/problems/76</a></p>

<h1>考察</h1>

<p>1または2前に進むことが出来るので，i+2番目にマスに訪れるにはi番目のマス，またはi+1番目のマスから来るしかない．よって</p>

<p><script type="math/tex; mode=display">
\begin{eqnarray}
\begin{cases}
dp[0] = 1 \
dp[1] = 1 \
dp[i+2] = dp[i+1] + dp[i] (i \geq 2)
\end{cases}
\end{eqnarray}
</script></p>

<p>が成り立つ．フィボナッチ階段を同じ考えである．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;ll&gt; dp(55);
    dp[0] = 1;
    dp[1] = 1;

    rep(i,n-1) {
        dp[i+2] = dp[i] + dp[i+1];
    }

    cout &lt;&lt; dp[n] &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
