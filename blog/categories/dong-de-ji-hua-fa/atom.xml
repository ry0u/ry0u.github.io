<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 動的計画法 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/dong-de-ji-hua-fa/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-24T02:26:22+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ2166 Erratic Sleep Habits]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/24/aoj2166-erratic-sleep-habits/"/>
    <updated>2016-03-24T02:13:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/24/aoj2166-erratic-sleep-habits</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2166">Erratic Sleep Habits</a></h4><p>Peter is a person with erratic sleep habits. He goes to sleep at twelve o'lock every midnight. He gets up just after one hour of sleep on some days; he may even sleep for twenty-three hours on other days. His sleeping duration changes in a cycle, where he always sleeps for only one hour on the first day of the cycle.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>睡眠周期 {% m %} T_i {% em %}が与えられる．カフェインを取ることでこの睡眠周期を最初に戻すことが出来るとき，全ての予定をこなせるカフェインの量の最大値を求める．<br/>
{% math %}
    dp[i][j] := i日目に睡眠周期jの時のカフェインの最小値
{% endmath %}
とした． {% m %} j = 0 {% em %}の場合は {% m %} i-1 {% em %}のどこからでも {% m %} +1 {% em %}(カフェインを取ること)で遷移できて，他の場合は {% m %} T_j {% em %}が {% m %} i {% em %}日目の一番最初の予定より早ければ， {% m %} dp[i-1][j-1] {% em %}より遷移できる．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int t;
    while(cin &gt;&gt; t &amp;&amp; t) {

        vector&lt;int&gt; v(t);
        rep(i, t) cin &gt;&gt; v[i];

        int n;
        cin &gt;&gt; n;

        vector&lt;int&gt; d(n), m(n);
        int dm[105], day = 0;
        rep(i, 105) dm[i] = INF;

        rep(i, n) {
            cin &gt;&gt; d[i] &gt;&gt; m[i];
            dm[d[i]-1] = min(dm[d[i]-1], m[i]);
            day = max(day, d[i]);
        }

        int dp[105][35];
        rep(i, 105) rep(j, 35) dp[i][j] = INF;

        dp[0][0] = 0;

        REP(i, 1, day) {
            rep(j, t) {
                if(j == 0) {
                    rep(k, t) {
                        dp[i][j] = min(dp[i][j], dp[i-1][k] + 1);
                    }
                    dp[i][j] = min(dp[i][j], dp[i-1][t-1]);
                } else {
                    if(v[j] &lt;= dm[i]) {
                        dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
                    }
                }
            }
        }

        int ans = INF;
        rep(i, t) {
            ans = min(ans, dp[day-1][i]);
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1306 Balloon Collecting]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/23/aoj1306-balloon-collecting/"/>
    <updated>2016-03-23T21:01:17+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/23/aoj1306-balloon-collecting</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1306">Balloon Collecting</a></h4><p>"Balloons should be captured efficiently", the game designer says. He is designing an oldfashioned game with two dimensional graphics. In the game, balloons fall onto the ground one after another, and the player manipulates a robot vehicle on the ground to capture the balloons.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>動的計画法．</p>

<p>{% math %}
    dp[i][j] := i個目の風船をj個集めた時の時間の最小値
{% endmath %}</p>

<p>として， {% m %} j \leq 3 {% em %}の時に風船を取りに行って間に合うならば {% m %} dp[i+1][j+1] {% em %}に遷移可能， 今ある風船を家に置きに行って，次の風船を取りに言って間に合うならば {% m %} dp[i+1][1] {% em %}に遷移可能．<br/>
間に合うかどうかは，そのまま次のを取る{% m %}\to abs (p[i+1] - p[i]) \cdot (j + 1) {% em %}，家に置きに行って風船を次の風船を取る{% m %} \to p[i] \cdot (j+1) + p[i+1] {% em %}が， {% m %} t[i+1] - t[i] {% em %}より小さければ良い．<br/>
家に帰る，と次の風船を取りに行くを別々に考えていてどういう遷移か分からずめちゃくちゃ時間を溶かした．こういう考え方がすぐに出来るようになりたい．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int dp[50][4];

int main() {
    int n;
    while(cin &gt;&gt; n &amp;&amp; n) {

        vector&lt;int&gt; p(n + 1), t(n + 1);
        rep(i, n) cin &gt;&gt; p[i + 1] &gt;&gt; t[i + 1];

        rep(i, 50) rep(j, 4) dp[i][j] = INF;

        int id = -1;
        dp[0][0] = 0;
        rep(i, n) {
            int d = abs(p[i+1] - p[i]);
            bool flag = true;

            rep(j, 4) {
                if(dp[i][j] == INF) continue;

                if(j &lt; 3 &amp;&amp; d * (j + 1) &lt;= t[i+1] - t[i]) {
                    flag = false;
                    dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j] + d);
                }

                if(p[i] * (j + 1) + p[i+1] &lt;= t[i+1] - t[i]) {
                    flag = false;
                    dp[i+1][1] = min(dp[i+1][1], dp[i][j] + p[i] + p[i+1]);
                }
            }

            if(flag) {
                id = i+1;
                break;
            }
        }

        if(id != -1) cout &lt;&lt; "NG " &lt;&lt; id &lt;&lt; endl;
        else {
            int ans = INF;
            rep(j, 4) {
                ans = min(ans, dp[n][j] + p[n]);
            }
            cout &lt;&lt; "OK " &lt;&lt; ans &lt;&lt; endl;
        }
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2321 Butterfly]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj2321-butterfly/"/>
    <updated>2016-03-22T18:12:20+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj2321-butterfly</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2321">Butterfly</a></h4><p>Claire is a man-eater. She's a real man-eater. She's going around with dozens of guys. She's dating all the time. And one day she found some conflicts in her date schedule. D'oh! So she needs to pick some dates and give the others up. The dates are set by hours like 13:00 to 15:00.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>デートのもっとも満足度の高くなるスケジュールを組む． {% m %} 6時を0 {% em %}ビットに当てて，デートの時間をビット集合{% m %} S {% em %}と考える．</p>

<p>{% math %}
    dp[i][j] := i番目までの男と時間jにデート可能な時の満足度の最大値
{% endmath %}
とする．時間 {% m %} j {% em %}と {% m %} S[i] {% em %}の積集合が無い場合， 遷移可能({% m %} dp[i][j] + L[i] {% em %})．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;bitset&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll dp[105][1 &lt;&lt; 16];
ll L[105], S[105];

int main() {
    int n;
    while(cin &gt;&gt; n &amp;&amp; n) {

        memset(L, 0, sizeof(L));
        memset(S, 0, sizeof(S));

        rep(i, n) {
            int m;
            cin &gt;&gt; m &gt;&gt; L[i];

            rep(j, m) {
                int s, t;
                cin &gt;&gt; s &gt;&gt; t;

                REP(k, s, t) {
                    S[i] |= 1 &lt;&lt; (k-6);
                }
            }
        }

        memset(dp, 0, sizeof(dp));

        rep(i, n) {
            rep(j, 1&lt;&lt;16) {
                dp[i+1][j] = max(dp[i+1][j], dp[i][j]);
            }

            rep(j, 1&lt;&lt;16) {
                if(j &amp; S[i]) continue;
                dp[i+1][j | S[i]] = max(dp[i+1][j | S[i]], dp[i][j] + L[i]);
            }
        }

        ll ans = 0;
        rep(i, n + 1) {
            rep(j, 1&lt;&lt;16) {
                ans = max(ans, dp[i][j]);
            }
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1286 Expected Allowance]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj1286-expected-allowance/"/>
    <updated>2016-03-18T22:54:03+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj1286-expected-allowance</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1286">Expected Allowance | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>{% math %}
    dp[i][j] := i回，m面のサイコロを降った時にjが出る回数
{% endmath %}</p>

<p>として，シュミレーション．サイコロを振るのは {% m %} dp[i+1][j+k] += dp[i][j] {% em %}と書ける．配列を再利用するために，{% m %} iとi+1 {% em %}の偶奇を見て遷移する．次に遷移する場所に値が残っているとおかしいことになるので，{% m %} dp[i][j] {% em %}からサイコロを振ったらそこは初期化する．分母は全て {% m %} m ^n {% em %}で， {% m %} k {% em %}引いた時に最低でも {% m %} 1 {% em %}になるようにして期待値を求める．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int dp[2][100005];

int main() {
    int n, m, k;
    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; k) {
        if(n == 0 &amp;&amp; m == 0 &amp;&amp; k == 0) break;

        memset(dp, 0, sizeof(dp));
        REP(j, 1, m + 1) {
            dp[1][j] = 1;
        }

        rep(i, n) {
            rep(j, 100005) {
                if(dp[i &amp; 1][j] == 0) continue;
                REP(k, 1, m+1) {
                    dp[(i+1)&amp;1][j+k] += dp[i&amp;1][j];
                }
                dp[i&amp;1][j] = 0;
            }
        }

        double ans = 0, t = 1;
        rep(i, n) {
            t *= m;
        }

        rep(j, 100005) {
            if(dp[n&amp;1][j] == 0) continue;

            double l = j - k;
            if(l &lt;= 0) l = 1;
            ans += (dp[n &amp; 1][j] / t) * l;
        }

        cout &lt;&lt; fixed;
        cout.precision(20);
        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1277 Minimal Backgammon]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj1277-minimal-backgammon/"/>
    <updated>2016-03-18T22:14:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj1277-minimal-backgammon</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1277">Minimal Backgammon</a></h4><p>Here is a very simple variation of the game backgammon, named "Minimal Backgammon". The game is played by only one player, using only one of the dice and only one checker (the token used by the player). The game board is a line of ( N + 1) squares labeled as 0 (the start) to N (the goal).</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>動的計画法．
{% math %}
    dp[i][j] := iターン目にマスjにいる確率
{% endmath %}</p>

<p>とする．{% m %} i {% em %}ターン目にマス{% m %} j {% em %}にいる時にサイコロを振るのは
{% math %}
    dp[i+1][j+k] = dp[i][j] \cdot (1.0 / 6.0);
{% endmath %}
と書ける．一回休みの時は{% m %} dp[i+2][j+k] {% em %}，戻るマスは {% m %} dp[i+1][0] {% em %}に遷移する．{% m %} n {% em %}マスを追い越した時に戻ってくる処理でバグバグした．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

double dp[105][105];

int main() {
    int n, t, l, b;
    while(cin &gt;&gt; n &gt;&gt; t &gt;&gt; l &gt;&gt; b) {
        if(n == 0 &amp;&amp; t == 0 &amp;&amp; l == 0 &amp;&amp; b == 0) break;

        memset(dp, 0, sizeof(dp));

        bool lose[105], back[1005];
        memset(lose, 0, sizeof(lose));
        memset(back, 0, sizeof(back));

        rep(i, l) {
            int x;
            cin &gt;&gt; x;
            lose[x] = true;
        }

        rep(i, b) {
            int x;
            cin &gt;&gt; x;
            back[x] = true;
        }

        memset(dp, 0, sizeof(dp));

        dp[0][0] = 1.0;
        rep(i, t) {
            rep(j, n) {
                if(dp[i][j] == 0.0) continue;
                REP(k, 1, 7) {
                    int p = j + k;
                    if(p &gt; n) p = n - (p - n);

                    if(lose[p]) {
                        dp[i+2][p] += dp[i][j] * (1.0 / 6.0);
                    } else if(back[p]) {
                        dp[i+1][0] += dp[i][j] * (1.0 / 6.0);
                    } else {
                        dp[i+1][p] += dp[i][j] * (1.0 / 6.0);
                    }
                }
            }
        }

        double ans = 0;
        rep(i, t + 1) {
            ans += dp[i][n];
        }

        cout &lt;&lt; fixed;
        cout.precision(20);
        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
