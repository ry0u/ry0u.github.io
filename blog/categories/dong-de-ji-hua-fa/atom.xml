<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 動的計画法 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/dong-de-ji-hua-fa/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-24T01:59:00+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ1306 Balloon Collecting]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/23/aoj1306-balloon-collecting/"/>
    <updated>2016-03-23T21:01:17+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/23/aoj1306-balloon-collecting</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1306">Balloon Collecting</a></h4><p>"Balloons should be captured efficiently", the game designer says. He is designing an oldfashioned game with two dimensional graphics. In the game, balloons fall onto the ground one after another, and the player manipulates a robot vehicle on the ground to capture the balloons.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>動的計画法．</p>

<p>{% math %}
    dp[i][j] := i個目の風船をj個集めた時の時間の最小値
{% endmath %}</p>

<p>として， {% m %} j \leq 3 {% em %}の時に風船を取りに行って間に合うならば {% m %} dp[i+1][j+1] {% em %}に遷移可能， 今ある風船を家に置きに行って，次の風船を取りに言って間に合うならば {% m %} dp[i+1][1] {% em %}に遷移可能．<br/>
間に合うかどうかは，そのまま次のを取る{% m %}\to abs (p[i+1] - p[i]) \cdot (j + 1) {% em %}，家に置きに行って風船を次の風船を取る{% m %} \to p[i] \cdot (j+1) + p[i+1] {% em %}が， {% m %} t[i+1] - t[i] {% em %}より小さければ良い．<br/>
家に帰る，と次の風船を取りに行くを別々に考えていてどういう遷移か分からずめちゃくちゃ時間を溶かした．こういう考え方がすぐに出来るようになりたい．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int dp[50][4];

int main() {
    int n;
    while(cin &gt;&gt; n &amp;&amp; n) {

        vector&lt;int&gt; p(n + 1), t(n + 1);
        rep(i, n) cin &gt;&gt; p[i + 1] &gt;&gt; t[i + 1];

        rep(i, 50) rep(j, 4) dp[i][j] = INF;

        int id = -1;
        dp[0][0] = 0;
        rep(i, n) {
            int d = abs(p[i+1] - p[i]);
            bool flag = true;

            rep(j, 4) {
                if(dp[i][j] == INF) continue;

                if(j &lt; 3 &amp;&amp; d * (j + 1) &lt;= t[i+1] - t[i]) {
                    flag = false;
                    dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j] + d);
                }

                if(p[i] * (j + 1) + p[i+1] &lt;= t[i+1] - t[i]) {
                    flag = false;
                    dp[i+1][1] = min(dp[i+1][1], dp[i][j] + p[i] + p[i+1]);
                }
            }

            if(flag) {
                id = i+1;
                break;
            }
        }

        if(id != -1) cout &lt;&lt; "NG " &lt;&lt; id &lt;&lt; endl;
        else {
            int ans = INF;
            rep(j, 4) {
                ans = min(ans, dp[n][j] + p[n]);
            }
            cout &lt;&lt; "OK " &lt;&lt; ans &lt;&lt; endl;
        }
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2321 Butterfly]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj2321-butterfly/"/>
    <updated>2016-03-22T18:12:20+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj2321-butterfly</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2321">Butterfly</a></h4><p>Claire is a man-eater. She's a real man-eater. She's going around with dozens of guys. She's dating all the time. And one day she found some conflicts in her date schedule. D'oh! So she needs to pick some dates and give the others up. The dates are set by hours like 13:00 to 15:00.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>デートのもっとも満足度の高くなるスケジュールを組む． {% m %} 6時を0 {% em %}ビットに当てて，デートの時間をビット集合{% m %} S {% em %}と考える．</p>

<p>{% math %}
    dp[i][j] := i番目までの男と時間jにデート可能な時の満足度の最大値
{% endmath %}
とする．時間 {% m %} j {% em %}と {% m %} S[i] {% em %}の積集合が無い場合， 遷移可能({% m %} dp[i][j] + L[i] {% em %})．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;bitset&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll dp[105][1 &lt;&lt; 16];
ll L[105], S[105];

int main() {
    int n;
    while(cin &gt;&gt; n &amp;&amp; n) {

        memset(L, 0, sizeof(L));
        memset(S, 0, sizeof(S));

        rep(i, n) {
            int m;
            cin &gt;&gt; m &gt;&gt; L[i];

            rep(j, m) {
                int s, t;
                cin &gt;&gt; s &gt;&gt; t;

                REP(k, s, t) {
                    S[i] |= 1 &lt;&lt; (k-6);
                }
            }
        }

        memset(dp, 0, sizeof(dp));

        rep(i, n) {
            rep(j, 1&lt;&lt;16) {
                dp[i+1][j] = max(dp[i+1][j], dp[i][j]);
            }

            rep(j, 1&lt;&lt;16) {
                if(j &amp; S[i]) continue;
                dp[i+1][j | S[i]] = max(dp[i+1][j | S[i]], dp[i][j] + L[i]);
            }
        }

        ll ans = 0;
        rep(i, n + 1) {
            rep(j, 1&lt;&lt;16) {
                ans = max(ans, dp[i][j]);
            }
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1286 Expected Allowance]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj1286-expected-allowance/"/>
    <updated>2016-03-18T22:54:03+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj1286-expected-allowance</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1286">Expected Allowance | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>{% math %}
    dp[i][j] := i回，m面のサイコロを降った時にjが出る回数
{% endmath %}</p>

<p>として，シュミレーション．サイコロを振るのは {% m %} dp[i+1][j+k] += dp[i][j] {% em %}と書ける．配列を再利用するために，{% m %} iとi+1 {% em %}の偶奇を見て遷移する．次に遷移する場所に値が残っているとおかしいことになるので，{% m %} dp[i][j] {% em %}からサイコロを振ったらそこは初期化する．分母は全て {% m %} m ^n {% em %}で， {% m %} k {% em %}引いた時に最低でも {% m %} 1 {% em %}になるようにして期待値を求める．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int dp[2][100005];

int main() {
    int n, m, k;
    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; k) {
        if(n == 0 &amp;&amp; m == 0 &amp;&amp; k == 0) break;

        memset(dp, 0, sizeof(dp));
        REP(j, 1, m + 1) {
            dp[1][j] = 1;
        }

        rep(i, n) {
            rep(j, 100005) {
                if(dp[i &amp; 1][j] == 0) continue;
                REP(k, 1, m+1) {
                    dp[(i+1)&amp;1][j+k] += dp[i&amp;1][j];
                }
                dp[i&amp;1][j] = 0;
            }
        }

        double ans = 0, t = 1;
        rep(i, n) {
            t *= m;
        }

        rep(j, 100005) {
            if(dp[n&amp;1][j] == 0) continue;

            double l = j - k;
            if(l &lt;= 0) l = 1;
            ans += (dp[n &amp; 1][j] / t) * l;
        }

        cout &lt;&lt; fixed;
        cout.precision(20);
        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1277 Minimal Backgammon]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj1277-minimal-backgammon/"/>
    <updated>2016-03-18T22:14:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj1277-minimal-backgammon</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1277">Minimal Backgammon</a></h4><p>Here is a very simple variation of the game backgammon, named "Minimal Backgammon". The game is played by only one player, using only one of the dice and only one checker (the token used by the player). The game board is a line of ( N + 1) squares labeled as 0 (the start) to N (the goal).</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>動的計画法．
{% math %}
    dp[i][j] := iターン目にマスjにいる確率
{% endmath %}</p>

<p>とする．{% m %} i {% em %}ターン目にマス{% m %} j {% em %}にいる時にサイコロを振るのは
{% math %}
    dp[i+1][j+k] = dp[i][j] \cdot (1.0 / 6.0);
{% endmath %}
と書ける．一回休みの時は{% m %} dp[i+2][j+k] {% em %}，戻るマスは {% m %} dp[i+1][0] {% em %}に遷移する．{% m %} n {% em %}マスを追い越した時に戻ってくる処理でバグバグした．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

double dp[105][105];

int main() {
    int n, t, l, b;
    while(cin &gt;&gt; n &gt;&gt; t &gt;&gt; l &gt;&gt; b) {
        if(n == 0 &amp;&amp; t == 0 &amp;&amp; l == 0 &amp;&amp; b == 0) break;

        memset(dp, 0, sizeof(dp));

        bool lose[105], back[1005];
        memset(lose, 0, sizeof(lose));
        memset(back, 0, sizeof(back));

        rep(i, l) {
            int x;
            cin &gt;&gt; x;
            lose[x] = true;
        }

        rep(i, b) {
            int x;
            cin &gt;&gt; x;
            back[x] = true;
        }

        memset(dp, 0, sizeof(dp));

        dp[0][0] = 1.0;
        rep(i, t) {
            rep(j, n) {
                if(dp[i][j] == 0.0) continue;
                REP(k, 1, 7) {
                    int p = j + k;
                    if(p &gt; n) p = n - (p - n);

                    if(lose[p]) {
                        dp[i+2][p] += dp[i][j] * (1.0 / 6.0);
                    } else if(back[p]) {
                        dp[i+1][0] += dp[i][j] * (1.0 / 6.0);
                    } else {
                        dp[i+1][p] += dp[i][j] * (1.0 / 6.0);
                    }
                }
            }
        }

        double ans = 0;
        rep(i, t + 1) {
            ans += dp[i][n];
        }

        cout &lt;&lt; fixed;
        cout.precision(20);
        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0611 Silk Road]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj0611-silk-road/"/>
    <updated>2016-03-18T01:27:54+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj0611-silk-road</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0611">Silk Road | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>{% math %}
    dp[i][j] := 都市iにj日目に到達した時に疲労度の最小値
{% endmath %}</p>

<p>とする．{% m %} 都市i-1 {% em %}に{% m %} j日未満に {% em %}到達している時の最小値から移動するのが，都市{% m %} i {% em %}に {% m %} j {% em %}日目に到達する時の最小となる．これを繰り返す．{% m %} O(nm log m) {% em %}．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct RMQ {
    int n;
    vector&lt;ll&gt; dat;

    RMQ(int n_) {
        n = 1;
        while(n &lt; n_) n *= 2;

        dat.resize(n*4);
        rep(i,n*4) dat[i] = INF;
    }

    void update(int k,ll a) {
        int i = k+n-1;
        dat[i] = a;

        while(i &gt; 0) {
            i = (i-1) / 2;
            dat[i] = min(dat[i*2+1],dat[i*2+2]);
        }
    }

    //[a,b)
    //query(a,b,0,0,n)
    ll _query(int a,int b,int k,int l,int r) {
        if(r &lt;= a || b &lt;= l) return INF;

        if(a &lt;= l &amp;&amp; r &lt;= b) return dat[k];
        else { 
            ll vl = _query(a,b,k*2+1,l,(l+r)/2);
            ll vr = _query(a,b,k*2+2,(l+r)/2,r);
            return min(vl,vr);
        }
    }

    //[a,b)
    ll query(int a,int b) {
        return _query(a,b,0,0,n);
    }
};

ll dp[1005][1005], d[1005][1005];

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;ll&gt; D(n), C(m);
    rep(i, n) cin &gt;&gt; D[i];
    rep(i, m) cin &gt;&gt; C[i];

    rep(i, n) {
        rep(j, m) dp[i][j] = INF;
    }

    rep(i, n) {
        rep(j, m) d[i][j] = D[i] * C[j];
    }

    rep(j, m) dp[0][j] = D[0] * C[j];

    REP(i, 1, n) {
        RMQ rmq(m);
        rep(j, m) rmq.update(j, dp[i-1][j]);

        rep(j, m) {
            dp[i][j] = rmq.query(0, j) + d[i][j];
        }
    }

    ll ans = INF;
    rep(j, m) {
        ans = min(ans, dp[n-1][j]);
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
