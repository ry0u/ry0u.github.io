<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 動的計画法 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/dong-de-ji-hua-fa/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-05T20:01:22+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM335 D2H MinimumVariancePartition]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/05/srm335-d2h-minimumvariancepartition/"/>
    <updated>2017-02-05T19:28:10+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/05/srm335-d2h-minimumvariancepartition</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7363&rd=10659">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

数列が与えられる．この数列を$k$個の数列に分け，それぞれの数列の分散の和を最小化したい．まず初めに$[i, j)$の分散を全て計算しておく．

$$
	dp[i][j] := i番目までをj個に分けた時の分散の和の最小値
$$

として動的計画法．$j$番目まで見て$k+1$個に分ける時は，$[0, i)$と$[i, j)$に分けて$dp[i][k]$と$[i, j)$の分散の和を候補としてminを取っていく．

```cpp
#include <bits/stdc++.h>

#define rep(i,n) for(int i=0;i<(int)(n);i++)
#define REP(i,k,n) for(int i=k;i<(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

class MinimumVariancePartition {
	public:
	double minDev(vector <int> mixedSamples, int K) {
		vector<int> v = mixedSamples;
		sort(v.begin(), v.end());

		double dp[55][55];
		rep(i, 55) rep(j, 55) dp[i][j] = INF;
		dp[0][0] = 0;

		double var[55][55];
		memset(var, 0, sizeof(var));
		rep(i, v.size()) {
			REP(j, i+1, v.size()+1) {
				double mean = 0;
				REP(k, i, j) {
					mean += v[k];
				}
				mean /= (j - i);

				REP(k, i, j) {
					var[i][j] += (v[k] - mean) * (v[k] - mean);
				}
				var[i][j] /= (j - i);
			}
		}

		rep(i, v.size()) {
			REP(j, i+1, v.size()+1) {
				rep(k, K) {
					dp[j][k+1] = min(dp[j][k+1], dp[i][k] + var[i][j]);
				}
			}
		}

		return dp[v.size()][K];
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM331 D1M Shopping]]></title>
    <link href="http://ry0u.github.io/blog/2016/12/04/srm331-d1m-shopping/"/>
    <updated>2016-12-04T00:27:55+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/12/04/srm331-d1m-shopping</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6479&rd=10011">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

コインの価値が与えられる．同じコインを何枚でも使って良いので$1 \sim X$を全て表せる，コインの枚数を最小化したい．

$$
	dp[i] := 現在持っているコインで価値iを表せるか
$$

として動的計画法．出来るだけ少ない枚数にしたいので，大きい数から減らせるだけ減らしていく．同じ配列を使ってしまうと何個も同じ数を使うdpになってしまうので，配列は分ける．最終的に$1 \sim X$全ての数字を表せているかをチェックする．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

class Shopping {

    public:

    int minNumber(int X, vector <int> values) {
		sort(values.begin(), values.end());

		vector<bool> dp(1005);
		dp[0] = true;

		vector<int> ans;
		REP(i, 1, X + 1) {
			if(dp[i]) continue;

			int res = i;
			vector<int> v;
			for(int j = values.size()-1; j >= 0; j--) {
				if(res - values[j] >= 0) {
					res -= values[j];
					v.push_back(values[j]);
					ans.push_back(values[j]);
					j++;
				}

				if(dp[res]) break;
			}

			vector<bool> dp2 = dp;
			REP(j, 0, X + 1) {
				if(dp[j]) {
					rep(k, v.size()) {
						if(j + v[k] <= X) {
							dp2[j + v[k]] = true;
						}
					}
				}
			}

			dp = dp2;
		}

		rep(i, X + 1) {
			if(!dp[i]) return -1;
		}

		return ans.size();
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM331 D2H ChrismasTree]]></title>
    <link href="http://ry0u.github.io/blog/2016/12/04/srm331-d2h-chrismastree/"/>
    <updated>2016-12-04T00:09:28+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/12/04/srm331-d2h-chrismastree</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7261&rd=10011">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

$N$段目に$N$個のノードがあり，これを$R, G, B$の三色に乗り分けたい．各段には色が同じ数ではないといけない．その段に無い色はカウントしない．方法としては，一色に塗るか，二色に塗るか，三色に塗るかがある．

* 一色の場合，${}\_n C\_n$
* 二色の場合，${}\_n C\_{\frac{n}{2}} \times {}\_{\frac{n}{2}} C \_{\frac{n}{2}}$
* 三色の場合，${}\_n C\_{\frac{n}{3}} \times {}\_{\frac{2*n}{3}} C \_{\frac{n}{3}} \times {}\_{\frac{n}{3}} C \_{\frac{n}{3}}$

通り選び方があるのでかける．状態を$i$段目で各色が何色残っているかでメモ化した．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair
#define MOD 1000000007

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

int n;
ll dp[12][51][51][51];

ll C[2005][2005];
void combination(int size) {
	for (int i = 0; i < size; i++) C[i][0] = 1LL;
	for (int i = 1; i < size; i++) {
		for (int j = 1; j <= i; j++) {
			C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
		}
	}
}

ll dfs(int dep, int r, int g, int b) {
	if(dp[dep][r][g][b] != -1) return dp[dep][r][g][b];
	if(dep == n + 1) {
		return dp[dep][r][g][b] = 1;
	}

	ll ret = 0;
	if(r - dep >= 0) {
		ret += dfs(dep + 1, r - dep, g, b);
	}
	if(g - dep >= 0) {
		ret += dfs(dep + 1, r, g - dep, b);
	}
	if(b - dep >= 0) {
		ret += dfs(dep + 1, r, g, b - dep);
	}

	if(dep % 2 == 0) {
		if(r - dep / 2 >= 0 && g - dep / 2 >= 0) {
			ret += dfs(dep + 1, r - dep / 2, g - dep / 2, b) * C[dep][dep/2];
		}
		if(g - dep / 2 >= 0 && b - dep / 2 >= 0) {
			ret += dfs(dep + 1, r, g - dep / 2, b - dep / 2) * C[dep][dep/2];
		}
		if(r - dep / 2 >= 0 && b - dep / 2 >= 0) {
			ret += dfs(dep + 1, r - dep / 2, g, b - dep / 2) * C[dep][dep/2];
		}
	}

	if(dep % 3 == 0) {
		if(r - dep / 3 >= 0 && g - dep / 3 >= 0 && b - dep / 3 >= 0) {
			ret += dfs(dep + 1, r - dep / 3, g - dep / 3, b - dep / 3) * C[dep][dep/3] * C[dep - dep / 3][dep/3];
		}
	}

	return dp[dep][r][g][b] = ret;
}

class ChristmasTree {
	public:
	long long decorationWays(int N, int red, int green, int blue) {
		n = N;
		combination(55);
		memset(dp, -1, sizeof(dp));

		return dfs(1, red, green, blue);
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM330 D1M PrefixFreeSubsets]]></title>
    <link href="http://ry0u.github.io/blog/2016/12/02/srm330-d1m-prefixfreesubsets/"/>
    <updated>2016-12-02T00:22:27+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/12/02/srm330-d1m-prefixfreesubsets</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7255&rd=10010">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

文字列の集合の全ての要素が，他の要素で始まっていない時に$prefix-free$という．与えられた文字列集合の部分集合の内，$prefix-free$である集合の個数を答える．  

---

重複をどう列挙すればいいの全然分からなかった．解説を見た．
$$
	dp[i] := i番目以降のprefix-freeの集合の個数
$$
として動的計画法．基本的に，$dp[i+1]$が分かっているときに，$i$番目の文字列を追加したい場合は，その文字列を選ぶ場合と選ばない場合の$2$通りがあるので単純に$2$倍で良い．しかし，選ぶ場合に$prefix-free$になってしまってはいけないので，そうではない所から遷移させる．一度辞書順でsortしてしまえば，$pfefix$が同じ場合はsort後に隣接しているはずなので，同じにならない所にまで$1$個ずつずらせばよい．このずらした場所を$j$とすると，$i$番目の文字を選ばない時は$dp[i+1]$，選ぶ時は$dp[j]$なのでこれらの和が$dp[i]$となる．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

bool check(string s, string t) {
	if(s.size() > t.size()) swap(s, t);
	rep(i, s.size()) {
		if(s[i] == t[i]) continue;
		return false;
	}
	return true;
}

class PrefixFreeSubsets {
	public:
	long long cantPrefFreeSubsets(vector <string> words) {
		int n = words.size();
		vector<string> s = words;
		sort(s.begin(), s.end());

		ll dp[55];
		memset(dp, 0, sizeof(dp));
		dp[n] = 1;

		for(int i = n - 1; i >= 0; i--) {
			int j = i + 1;
			while(j < n && check(s[i], s[j])) j++;
			dp[i] = dp[i+1] + dp[j];
		}

		return dp[0];
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM329 D2H ProbabilisticTranslator]]></title>
    <link href="http://ry0u.github.io/blog/2016/12/01/srm329-d2h-probabilistictranslator/"/>
    <updated>2016-12-01T23:25:59+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/12/01/srm329-d2h-probabilistictranslator</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6010&rd=10009">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

単語列とそれぞれの単語をある単語に変換できる辞書と二つの単語が並んだ時に得られる点が与えられた時に，得点の最大化をする．

$$
	dp[i][j] := i番目の単語を辞書からj番目に変換した時の最大値
$$

として動的計画法．$dp[i][j]$から$i+1$番目に遷移するときに，$i$番目の単語を$j$番目に変換した文字列と，$i+1$番目の単語を$k$番目に変換した文字列のペアで得点が得られる場合は加算する．先に$dp$の添字に対応する文字列のテーブルを作ってしまった方が楽だと思った．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

vector<string> split(const string &str, char delim) {
	vector<string> res;
	size_t current = 0, found;
	while((found = str.find_first_of(delim, current)) != string::npos) {
		res.push_back(string(str, current, found - current));
		current = found + 1;
	}
	res.push_back(string(str, current, str.size() - current));
	return res;
}

int dp[2505][55]; //i番目にその語の辞書からj番目に変換するときの最大値

class ProbabilisticTranslator {
	public:
	int maximumFidelity(vector <string> text, vector <string> dictionary, vector <string> frequencies) {
		vector<string> v;
		rep(i, text.size()) {
			vector<string> ret = split(text[i], ' ');
			rep(j, ret.size()) {
				v.push_back(ret[j]);
			}
		}
		
		map<string, vector<string> > m;
		rep(i, dictionary.size()) {
			vector<string> t = split(dictionary[i], ' ');

			REP(j, 2, t.size()) {
				m[t[0]].push_back(t[j]);
			}
		}

		map<pair<string, string>, int> fre;
		rep(i, frequencies.size()) {
			vector<string> t = split(frequencies[i], ' ');
			stringstream ss;
			ss << t[2];
			ss >> fre[mp(t[0], t[1])];
		}

		vector<vector<string> > table;
		rep(j, v.size()) {
			table.push_back(m[v[j]]);
		}

		memset(dp, 0, sizeof(dp));
		rep(i, v.size()-1) {
			rep(j, table[i].size()) {
				string s = table[i][j];
				rep(k, table[i+1].size()) {
					string t = table[i+1][k];
					if(fre.count(mp(s, t))) {
						dp[i+1][k] = max(dp[i+1][k], dp[i][j] + fre[mp(s, t)]);
					} else {
						dp[i+1][k] = max(dp[i+1][k], dp[i][j]);
					}
				}
			}
		}

		int ans = 0;
		rep(j, 2505) {
			rep(k, 55) {
				ans = max(ans, dp[j][k]);
			}
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
</feed>
