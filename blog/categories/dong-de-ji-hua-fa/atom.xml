<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 動的計画法 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/dong-de-ji-hua-fa/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-10T01:42:35+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM339 D1M TestBettingStrategy]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/10/srm339-d1m-testbettingstrategy/"/>
    <updated>2017-02-10T01:32:03+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/10/srm339-d1m-testbettingstrategy</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7422&rd=10663">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

勝ったら$bet$は$1$，負けたら次の$bet$を$2$倍にする．勝負に勝つ確立は毎回$prob$である．はじめ$initSum$所持していて，$rounds$回行い，$goalSum$以上になる確立を求める．

$$
	dp[i][j][k] := iターン目に所持金jでk回負けた時の確立
$$

何回負けたかを持つと$bet$が$(1 << k)$で求まる．後は$bet$が所持金を超えないならば，勝つ，負ける，それぞれの場合に遷移させる．勝った場合は$k$は$0$になる．$goalSum$以上超えた場合は終わりなので，$j$は$goalSum$未満しか見ない．最後には，全てのラウンド内で$goalSum$以上になったものを全て足す．

```cpp
#include <bits/stdc++.h>

#define rep(i,n) for(int i=0;i<(int)(n);i++)
#define REP(i,k,n) for(int i=k;i<(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

double dp[55][1005][10];

class TestBettingStrategy {
	public:
	double winProbability(int initSum, int goalSum, int rounds, int prob) {
		memset(dp, 0, sizeof(dp));
		dp[0][initSum][0] = 1;

		double p = prob / 100.0;

		rep(i, rounds) {
			rep(j, goalSum) {
				rep(k, 10) {
					int bet = (1 << k);
					if(j >= bet) {
						dp[i+1][j + bet][0] += dp[i][j][k] * p;
						dp[i+1][j - bet][k+1] += dp[i][j][k] * (1 - p);
					}
				}
			}
		}

		double ans = 0;
		REP(i, 1, rounds + 1) {
			REP(j, goalSum, 1005) {
				rep(k, 10) {
					ans += dp[i][j][k];
				}
			}
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM338 D1M RandomSwaps]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/09/srm338-d1m-randomswaps/"/>
    <updated>2017-02-09T23:31:27+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/09/srm338-d1m-randomswaps</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7289&rd=10662">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

長さ$arrayLength$の配列の要素を$swapCount$回swapする．初めに$a$番目にあったものが$b$番目にいる確立を求める．

$$
	dp[i][j] := i回swapした時にb番目にいる確立
$$

一回のswapの選択肢は$\displaystyle \frac{n*(n-1)}{2}$通りある．swap後に$b$番目にいる場合は，元々$b$番目にいてswapに$b$番目が選ばれない場合と，他の場所にいてその場所と$b$番目をswapする場合である．swap後に$b$番目にいない場合は，元々$b$番目にいて他の場所にswapされる場合と，他の場所にいてその場所と$b$番目がswapされない場合である．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

double dp[100005][2];

class RandomSwaps {

    public:

    double getProbability(int arrayLength, int swapCount, int a, int b) {
		int n = arrayLength;
		int cnt = swapCount;

		memset(dp, 0, sizeof(dp));
		
		dp[0][a == b] = 1;

		double N = (n * (n - 1)) / 2;
		rep(i, cnt) {
			dp[i+1][1] = dp[i][1] * (1 - (n - 1) / N) + dp[i][0] * (1.0 / N);
			dp[i+1][0] = dp[i][1] * ((n - 1) / N) + dp[i][0] * (1 - 1.0 / N);
		}

		return dp[cnt][1];
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM335 D2H MinimumVariancePartition]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/05/srm335-d2h-minimumvariancepartition/"/>
    <updated>2017-02-05T19:28:10+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/05/srm335-d2h-minimumvariancepartition</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7363&rd=10659">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

数列が与えられる．この数列を$k$個の数列に分け，それぞれの数列の分散の和を最小化したい．まず初めに$[i, j)$の分散を全て計算しておく．

$$
	dp[i][j] := i番目までをj個に分けた時の分散の和の最小値
$$

として動的計画法．$j$番目まで見て$k+1$個に分ける時は，$[0, i)$と$[i, j)$に分けて$dp[i][k]$と$[i, j)$の分散の和を候補としてminを取っていく．

```cpp
#include <bits/stdc++.h>

#define rep(i,n) for(int i=0;i<(int)(n);i++)
#define REP(i,k,n) for(int i=k;i<(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

class MinimumVariancePartition {
	public:
	double minDev(vector <int> mixedSamples, int K) {
		vector<int> v = mixedSamples;
		sort(v.begin(), v.end());

		double dp[55][55];
		rep(i, 55) rep(j, 55) dp[i][j] = INF;
		dp[0][0] = 0;

		double var[55][55];
		memset(var, 0, sizeof(var));
		rep(i, v.size()) {
			REP(j, i+1, v.size()+1) {
				double mean = 0;
				REP(k, i, j) {
					mean += v[k];
				}
				mean /= (j - i);

				REP(k, i, j) {
					var[i][j] += (v[k] - mean) * (v[k] - mean);
				}
				var[i][j] /= (j - i);
			}
		}

		rep(i, v.size()) {
			REP(j, i+1, v.size()+1) {
				rep(k, K) {
					dp[j][k+1] = min(dp[j][k+1], dp[i][k] + var[i][j]);
				}
			}
		}

		return dp[v.size()][K];
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM331 D1M Shopping]]></title>
    <link href="http://ry0u.github.io/blog/2016/12/04/srm331-d1m-shopping/"/>
    <updated>2016-12-04T00:27:55+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/12/04/srm331-d1m-shopping</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6479&rd=10011">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

コインの価値が与えられる．同じコインを何枚でも使って良いので$1 \sim X$を全て表せる，コインの枚数を最小化したい．

$$
	dp[i] := 現在持っているコインで価値iを表せるか
$$

として動的計画法．出来るだけ少ない枚数にしたいので，大きい数から減らせるだけ減らしていく．同じ配列を使ってしまうと何個も同じ数を使うdpになってしまうので，配列は分ける．最終的に$1 \sim X$全ての数字を表せているかをチェックする．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

class Shopping {

    public:

    int minNumber(int X, vector <int> values) {
		sort(values.begin(), values.end());

		vector<bool> dp(1005);
		dp[0] = true;

		vector<int> ans;
		REP(i, 1, X + 1) {
			if(dp[i]) continue;

			int res = i;
			vector<int> v;
			for(int j = values.size()-1; j >= 0; j--) {
				if(res - values[j] >= 0) {
					res -= values[j];
					v.push_back(values[j]);
					ans.push_back(values[j]);
					j++;
				}

				if(dp[res]) break;
			}

			vector<bool> dp2 = dp;
			REP(j, 0, X + 1) {
				if(dp[j]) {
					rep(k, v.size()) {
						if(j + v[k] <= X) {
							dp2[j + v[k]] = true;
						}
					}
				}
			}

			dp = dp2;
		}

		rep(i, X + 1) {
			if(!dp[i]) return -1;
		}

		return ans.size();
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM331 D2H ChrismasTree]]></title>
    <link href="http://ry0u.github.io/blog/2016/12/04/srm331-d2h-chrismastree/"/>
    <updated>2016-12-04T00:09:28+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/12/04/srm331-d2h-chrismastree</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7261&rd=10011">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

$N$段目に$N$個のノードがあり，これを$R, G, B$の三色に乗り分けたい．各段には色が同じ数ではないといけない．その段に無い色はカウントしない．方法としては，一色に塗るか，二色に塗るか，三色に塗るかがある．

* 一色の場合，${}\_n C\_n$
* 二色の場合，${}\_n C\_{\frac{n}{2}} \times {}\_{\frac{n}{2}} C \_{\frac{n}{2}}$
* 三色の場合，${}\_n C\_{\frac{n}{3}} \times {}\_{\frac{2*n}{3}} C \_{\frac{n}{3}} \times {}\_{\frac{n}{3}} C \_{\frac{n}{3}}$

通り選び方があるのでかける．状態を$i$段目で各色が何色残っているかでメモ化した．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair
#define MOD 1000000007

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

int n;
ll dp[12][51][51][51];

ll C[2005][2005];
void combination(int size) {
	for (int i = 0; i < size; i++) C[i][0] = 1LL;
	for (int i = 1; i < size; i++) {
		for (int j = 1; j <= i; j++) {
			C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
		}
	}
}

ll dfs(int dep, int r, int g, int b) {
	if(dp[dep][r][g][b] != -1) return dp[dep][r][g][b];
	if(dep == n + 1) {
		return dp[dep][r][g][b] = 1;
	}

	ll ret = 0;
	if(r - dep >= 0) {
		ret += dfs(dep + 1, r - dep, g, b);
	}
	if(g - dep >= 0) {
		ret += dfs(dep + 1, r, g - dep, b);
	}
	if(b - dep >= 0) {
		ret += dfs(dep + 1, r, g, b - dep);
	}

	if(dep % 2 == 0) {
		if(r - dep / 2 >= 0 && g - dep / 2 >= 0) {
			ret += dfs(dep + 1, r - dep / 2, g - dep / 2, b) * C[dep][dep/2];
		}
		if(g - dep / 2 >= 0 && b - dep / 2 >= 0) {
			ret += dfs(dep + 1, r, g - dep / 2, b - dep / 2) * C[dep][dep/2];
		}
		if(r - dep / 2 >= 0 && b - dep / 2 >= 0) {
			ret += dfs(dep + 1, r - dep / 2, g, b - dep / 2) * C[dep][dep/2];
		}
	}

	if(dep % 3 == 0) {
		if(r - dep / 3 >= 0 && g - dep / 3 >= 0 && b - dep / 3 >= 0) {
			ret += dfs(dep + 1, r - dep / 3, g - dep / 3, b - dep / 3) * C[dep][dep/3] * C[dep - dep / 3][dep/3];
		}
	}

	return dp[dep][r][g][b] = ret;
}

class ChristmasTree {
	public:
	long long decorationWays(int N, int red, int green, int blue) {
		n = N;
		combination(55);
		memset(dp, -1, sizeof(dp));

		return dfs(1, red, green, blue);
	}
};
```
]]></content>
  </entry>
  
</feed>
