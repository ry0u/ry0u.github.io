<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 動的計画法 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/dong-de-ji-hua-fa/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-18T16:21:13+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ0611 Silk Road]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj0611-silk-road/"/>
    <updated>2016-03-18T01:27:54+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj0611-silk-road</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0611">Silk Road | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p><script type="math/tex; mode=display">
    dp[i][j] := 都市iにj日目に到達した時に疲労度の最小値
</script></p>

<p>とする．<script type="math/tex"> 都市i-1 </script>に<script type="math/tex"> j日未満に </script>到達している時の最小値から移動するのが，都市<script type="math/tex"> i </script>に <script type="math/tex"> j </script>日目に到達する時の最小となる．これを繰り返す．<script type="math/tex"> O(nm log m) </script>．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct RMQ {
    int n;
    vector&lt;ll&gt; dat;

    RMQ(int n_) {
        n = 1;
        while(n &lt; n_) n *= 2;

        dat.resize(n*4);
        rep(i,n*4) dat[i] = INF;
    }

    void update(int k,ll a) {
        int i = k+n-1;
        dat[i] = a;

        while(i &gt; 0) {
            i = (i-1) / 2;
            dat[i] = min(dat[i*2+1],dat[i*2+2]);
        }
    }

    //[a,b)
    //query(a,b,0,0,n)
    ll _query(int a,int b,int k,int l,int r) {
        if(r &lt;= a || b &lt;= l) return INF;

        if(a &lt;= l &amp;&amp; r &lt;= b) return dat[k];
        else { 
            ll vl = _query(a,b,k*2+1,l,(l+r)/2);
            ll vr = _query(a,b,k*2+2,(l+r)/2,r);
            return min(vl,vr);
        }
    }

    //[a,b)
    ll query(int a,int b) {
        return _query(a,b,0,0,n);
    }
};

ll dp[1005][1005], d[1005][1005];

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;ll&gt; D(n), C(m);
    rep(i, n) cin &gt;&gt; D[i];
    rep(i, m) cin &gt;&gt; C[i];

    rep(i, n) {
        rep(j, m) dp[i][j] = INF;
    }

    rep(i, n) {
        rep(j, m) d[i][j] = D[i] * C[j];
    }

    rep(j, m) dp[0][j] = D[0] * C[j];

    REP(i, 1, n) {
        RMQ rmq(m);
        rep(j, m) rmq.update(j, dp[i-1][j]);

        rep(j, m) {
            dp[i][j] = rmq.query(0, j) + d[i][j];
        }
    }

    ll ans = INF;
    rep(j, m) {
        ans = min(ans, dp[n-1][j]);
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0604 Take the 'IOI' train]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/16/aoj0604-take-the-ioi-train/"/>
    <updated>2016-03-16T00:31:03+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/16/aoj0604-take-the-ioi-train</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0604">Take the 'IOI' train | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>待機用レールは列車を組み始めたら使えない．最初に避難させることは出来るが使いはじめる場所を決めたら，その列車を使うか，その列車以降を使わないかになる．</p>

<p><script type="math/tex; mode=display">
\begin{eqnarray}
    dp[i][j][0] &amp;:=&amp; Sをiまで，Tをjまで見て，末尾がOの時の最大値 \
    dp[i][j][1] &amp;:=&amp; Sをiまで，Tをjまで見て，末尾がIの時の最大値
\end{eqnarray}
</script></p>

<p>このように状態を持つと遷移は4パターンになる．</p>

<p><img src="/images/AOJ/0604-1.png">
<img src="/images/AOJ/0604-2.png"></p>

<p><img src="/images/AOJ/0604-3.png">
<img src="/images/AOJ/0604-4.png"></p>

<p>最初は <script type="math/tex"> I </script>で始め， <script type="math/tex"> I </script>で終わることに注意する．また，どちらかの列車を全く使わなくても良いので最初に空白を入れて表現してみた(変だ)．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int dp[2005][2005][2];

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    string s, t;
    cin &gt;&gt; s &gt;&gt; t;

    n++;
    m++;
    s = " " + s;
    t = " " + t;

    memset(dp, 0, sizeof(dp));

    REP(i, 0, n) {
        REP(j, 0, m) {

            if(i == 0 &amp;&amp; j == 0) continue;

            bool a = false, b = false;
            if(i == 0) {
                b = true;
            } else if(j == 0) {
                a = true;
            } else {
                a = true;
                b = true;
            }

            if(a) {
                if(dp[i-1][j][1] == 0) {
                    if(s[i] == 'I') {
                        dp[i][j][1] = max(dp[i][j][1], dp[i-1][j][0] + 1);
                    }
                } else {
                    if(s[i] == 'I') {
                        dp[i][j][1] = max(dp[i][j][1], dp[i-1][j][0] + 1);
                    } else {
                        dp[i][j][0] = max(dp[i][j][0], dp[i-1][j][1] + 1);
                    }
                }
            }

            if(b) {
                if(dp[i][j-1][1] == 0) {
                    if(t[j] == 'I') {
                        dp[i][j][1] = max(dp[i][j][1], dp[i][j-1][0] + 1);
                    }
                } else {
                    if(t[j] == 'I') {
                        dp[i][j][1] = max(dp[i][j][1], dp[i][j-1][0] + 1);
                    } else {
                        dp[i][j][0] = max(dp[i][j][0], dp[i][j-1][1] + 1);
                    }
                }
            }
        }
    }

    int ans = 0;
    rep(i, n) {
        rep(j, m) {
            // cout &lt;&lt; "(" &lt;&lt; dp[i][j][0] &lt;&lt; "," &lt;&lt; dp[i][j][1] &lt;&lt; ") ";
            ans = max(ans, dp[i][j][1]);
        }
        // cout &lt;&lt; endl;
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM684D2M DivFreed2]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/15/srm684d2m-divfreed2/"/>
    <updated>2016-03-15T23:11:13+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/15/srm684d2m-divfreed2</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14186&rd=16688">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>数列の隣り合う全ての要素<script type="math/tex"> A(1 \leq A \leq k), B(1 \leq B \leq k) </script>が</p>

<ul>
<li><script type="math/tex"> A \leq B </script></li>
<li><script type="math/tex"> A \ \rm{mod} \  B \neq 0 </script></li>
</ul>


<p>のどちらかを満たす数列の数を<script type="math/tex"> \rm{mod} \ 10 ^9 + 7 </script> で求める．</p>

<hr />

<p><script type="math/tex; mode=display">
    dp[i][j] := i番目にjを選んだ時の数列の数
</script></p>

<p>とする．数列に追加する可能なものを選ぶので<script type="math/tex"> B </script>から考えると，<script type="math/tex"> B </script>より大きい，または<script type="math/tex"> AがB </script>を約数に持たなければ良い．基本的に全て遷移可能として(<script type="math/tex"> dp[i+1][j] += \sum_{l = 1} ^{k} dp[i][l]</script>)，後に約数の場所の遷移を無かったことにすれば良い．</p>

<h1>Code</h1>

<pre><code class="cpp">ll dp[15][100005];
vector&lt;ll&gt; d[100005];

vector&lt;ll&gt; divisor(ll n) {
    vector&lt;ll&gt; res;
    for(ll i = 2; i*i &lt;= n; i++) {
        if(n % i == 0) {
            res.push_back(i);
            if(i != n/i) res.push_back(n/i);
        }
    }
    return res;
}

class DivFreed2 {
    public:
    int count(int n, int k) {
        memset(dp, 0, sizeof(dp));

        rep(i, k + 1) {
            d[i].clear();
        }

        REP(i, 2, k + 1) {
            vector&lt;ll&gt; ret = divisor(i);
            ret.push_back(1);

            d[i].resize(ret.size());
            rep(j, ret.size()) {
                d[i][j] = ret[j];
            }
        }

        REP(i, 1, k + 1) {
            dp[1][i] = 1;
        }

        REP(i, 1, n) {
            ll sum = 0;
            REP(j, 1, k + 1) {
                sum += dp[i][j];
                sum %= MOD;
            }

            REP(j, 1, k + 1) {
                dp[i+1][j] += sum;
                dp[i+1][j] %= MOD;
            }

            REP(j, 1, k + 1) {
                rep(l, d[j].size()) {
                    dp[i+1][d[j][l]] -= dp[i][j];
                }
            }
        }

        ll ans = 0;
        rep(j, k + 1) {
            ans += dp[n][j];
            ans %= MOD;
        }

        return ans;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0599 IOI Manju]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/08/aoj0599-ioi-manju/"/>
    <updated>2016-03-08T15:01:46+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/08/aoj0599-ioi-manju</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0599">IOI Manju | Aizu Online Judge</a></h4><p>ところで，あなたはJust Odd Inventions 社を知っているだろうか？ この会社の業務は「ただ奇妙な発明(just odd inventions)」をすることである．ここでは略してJOI 社と呼ぶ．IOI 社は，饅頭を詰めるための高級な箱をJOI 社に発注することになった．JOI 社の製作する饅頭用の箱は$N$ 種類あり， $j$ 番目$(1 \leq j \leq N)$の箱は最大で$C_j$ 個の饅頭を詰められる大きさであり，販売価格は$E_j$ 円である．これらの$N$ 種類の箱のうちの何種類か(0 種類以上$N$ 種類以下) を1 個ずつ発注し，饅頭をそれらの箱に詰め分けてセットで販売することになった．各饅頭セットの価格は，それに含まれる饅頭の価格の合計である．</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>饅頭<script type="math/tex"> i </script>から饅頭<script type="math/tex"> j </script>まで選んだ時の価格が欲しいので，累積和を取っておく．<br/>
<script type="math/tex; mode=display">
    dp[i][j] := i番目以内の箱を使い，饅頭jまで詰めた時の最大値
</script>
とする．<script type="math/tex"> i </script>番目の箱を</p>

<ul>
<li>使う遷移は，<script type="math/tex"> dp[i][j]+(d[j+c[i]]-d[j])-e[i]</script></li>
<li>使わない遷移は<script type="math/tex"> dp[i][j+c[i]]</script>．</li>
</ul>


<p><img src="/images/AOJ/0599.png"></p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll dp[505][10005];

int main() {
    int m, n;
    cin &gt;&gt; m &gt;&gt; n;

    vector&lt;int&gt; v(m);
    rep(i, m) cin &gt;&gt; v[i];

    vector&lt;P&gt; p(n);
    rep(i, n) {
        cin &gt;&gt; p[i].first &gt;&gt; p[i].second;
    }

    sort(v.begin(), v.end(), greater&lt;int&gt;());

    int d[10005];
    memset(d, 0, sizeof(d));
    REP(i, 1, m + 1) {
        d[i] += d[i-1] + v[i-1];
    }

    memset(dp, 0, sizeof(dp));
    rep(i, 505) {
        rep(j, 10005) dp[i][j]  = -1;
    }

    dp[0][0] = 0;

    rep(i, n) {
        rep(j, m + 1) {
            dp[i+1][j] = max(dp[i+1][j], dp[i][j]);
        }

        rep(j, m) {
            if(dp[i][j] == -1) continue;

            int id = j + p[i].first;
            id = min(id, m);
            dp[i+1][id] = max(dp[i+1][id], max(dp[i][id], dp[i][j] + (d[id] - d[j]) - p[i].second));
        }
    }


    ll ans = 0;
    rep(i, n + 1) {
        rep(j, m + 1) {
            ans = max(ans, dp[i][j]);
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0595 Schedule]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/06/aoj0595-schedule/"/>
    <updated>2016-03-06T01:11:01+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/06/aoj0595-schedule</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0595">Schedule | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>J君，O君，I君がいるかいないかを3ビットで持つ．
<script type="math/tex; mode=display">
    dp[i][j] := i日目に状態jの場合のスケジュール表として考えられるものの数
</script>
とする．</p>

<ul>
<li><p><script type="math/tex"> i </script>日目の鍵当番がいるか<br/>
<script type="math/tex; mode=display">
  j \ &amp; \ (1 &lt;&lt; d)
</script></p></li>
<li><p><script type="math/tex"> i-1日目に鍵を持ち帰れた人がいるか </script>
<script type="math/tex; mode=display">
  j \ &amp; \ k
</script></p></li>
</ul>


<p>この条件を満たす場合に遷移可能．<script type="math/tex"> O(n \cdot 2 ^3 \cdot 2 ^3) </script>．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;bitset&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair
#define MOD 10007

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll dp[1005][8];

int main() {
    int n;
    cin &gt;&gt; n;

    string s;
    cin &gt;&gt; s;

    map&lt;char, int&gt; id;
    id['J'] = 2; id['O'] = 1, id['I'] = 0;

    memset(dp, 0, sizeof(dp));
    dp[0][1 &lt;&lt; 2] = 1;

    REP(i, 1, n + 1) {
        int d = id[ s[i-1] ];
        rep(j, 1 &lt;&lt; 3) {
            if(!(j &amp; (1 &lt;&lt; d))) continue;
            rep(k, 1 &lt;&lt; 3) {
                if(j &amp; k) { 
                    dp[i][j] += dp[i-1][k];
                    dp[i][j] %= MOD;
                }
            }
        }
    }

    ll ans = 0;
    rep(i, 1 &lt;&lt; 3) {
        ans += dp[n][i];
    }

    cout &lt;&lt; ans % MOD &lt;&lt; endl;


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
