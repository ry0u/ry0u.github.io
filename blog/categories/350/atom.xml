<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 350 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/350/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-05-21T03:15:08+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ2301 Sleeping Time]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/21/aoj2301-sleeping-time/"/>
    <updated>2016-05-21T03:02:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/21/aoj2301-sleeping-time</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2301">Sleeping Time | Aizu Online Judge</a></h4><p>Miki is a high school student. She has a part time job, so she cannot take enough sleep on weekdays. She wants to take good sleep on holidays, but she doesn't know the best length of sleeping time for her.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>愚直に <script type="math/tex"> k </script>回のシュミレーションに対して，間違う/間違わないをすると <script type="math/tex"> 2 ^{30} </script>となる．ここで枝刈りを行う．シュミレーションが2分探索みたいな感じなので，一度解区間 <script type="math/tex"> [T-E, T+E] </script>を外れたら，再度解区間に入ることは無いので切って良い．この枝刈りだけで <script type="math/tex"> 04.91s </script>でACが取れた．</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int k;
double p, e, t;

double ans = 0;

void dfs(double l, double r, int cnt, double x) {
    if(r &lt; t - e) return;
    if(l &gt; t + e) return;

    double h = (l + r) / 2;

    if(cnt == k) {
        if(t - e &lt;= h &amp;&amp; h &lt;= t + e) ans += x;
        return;
    }

    if(h &gt;= t) {
        dfs(l, h, cnt + 1, (1.0 - p) * x);
        dfs(h, r, cnt + 1, p * x);
    } else {
        dfs(h, r, cnt + 1, (1.0 - p) * x);
        dfs(l, h, cnt + 1, p * x);
    }
}

int main() {
    double l, r;
    cin &gt;&gt; k &gt;&gt; l &gt;&gt; r;
    cin &gt;&gt; p &gt;&gt; e &gt;&gt; t;

    dfs(l, r, 0, 1.0);

    cout &lt;&lt; fixed;
    cout.precision(20);
    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>しかし，他の人の解答を見てみると<script type="math/tex"> 0.0s </script>ばかりだった．自分の解法は <script type="math/tex"> E </script>が十分小さい時に有効な枝刈りで， <script type="math/tex"> E </script>が大きい場合を考えていなかった． この時は解区間が探索区間を内包しているので，この先解区間を出ることはない．よってその枝刈りを追加すると <script type="math/tex"> 0.0s </script>とめちゃくちゃ早くなった．</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int k;
double p, e, t;

double ans = 0;

void dfs(double l, double r, int cnt, double x) {
    if(r &lt; t - e) return;
    if(l &gt; t + e) return;
    if(t - e &lt;= l &amp;&amp; r &lt;= t + e) {
        ans += x;
        return;
    }

    double h = (l + r) / 2;

    if(cnt == k) {
        if(t - e &lt;= h &amp;&amp; h &lt;= t + e) ans += x;
        return;
    }

    if(h &gt;= t) {
        dfs(l, h, cnt + 1, (1.0 - p) * x);
        dfs(h, r, cnt + 1, p * x);
    } else {
        dfs(h, r, cnt + 1, (1.0 - p) * x);
        dfs(l, h, cnt + 1, p * x);
    }
}

int main() {
    double l, r;
    cin &gt;&gt; k &gt;&gt; l &gt;&gt; r;
    cin &gt;&gt; p &gt;&gt; e &gt;&gt; t;

    dfs(l, r, 0, 1.0);

    cout &lt;&lt; fixed;
    cout.precision(20);
    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>まとめると，</p>

<ul>
<li><script type="math/tex"> E </script>が十分小さい時に，解区間から外れた場合の枝刈りが有効</li>
<li><script type="math/tex"> E </script>が十分大きい時に，解区間が内包する場合の枝刈りが有効</li>
</ul>


<p>となって， <script type="math/tex"> 2 ^{30} </script>にはならないで間に合う．(どのくらい減るのかよく分かっていない)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1280 Slim Span]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/21/aoj1280-slim-span/"/>
    <updated>2016-05-21T02:41:52+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/21/aoj1280-slim-span</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1280">Slim Span</a></h4><p>Given an undirected weighted graph G, you should find one of spanning trees specified as follows. A spanning tree T is a tree (a connected subgraph without cycles) which connects all the n vertices with n - 1 edges.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>The <script type="math/tex"> slimness </script> of a spanning tree Tは全域木を構成する辺の最大値 <script type="math/tex"> - </script>最小値と定義される．この値の最小値を求める．<br/>
出来るだけコストが近いものを使った方が良いので，まず使うコストの一番小さいものを決めて，それからコストを増やしていく．全域木が構成出来た時点でのコストのminを取る． <script type="math/tex"> O(nm) </script>．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct UnionFind {
    vector&lt;int&gt; par,rank;
    int N;

    UnionFind(int n) {
        N = n;
        par.resize(n);
        rank.resize(n);

        rep(i,n) {
            par[i] = i;
            rank[i] = 0;
        }
    }

    int find(int x) {
        if(par[x] == x) return x;
        else return par[x] = find(par[x]);
    }

    void unite(int x,int y) {
        x = find(x);
        y = find(y);

        if(x == y) return;

        if(rank[x] &lt; rank[y]) {
            par[x] = y;
        }
        else {
            par[y] = x;
            if(rank[x] == rank[y]) rank[x]++;
        }
    }

    bool same(int x,int y) {
        return find(x) == find(y);
    }

    int size() {
        int cnt = 0;
        rep(i,N) if(find(i) == i) cnt++;
        return cnt;
    }
};

int main() {
    int n, m;

    while(cin &gt;&gt; n &gt;&gt; m) {
        if(n == 0 &amp;&amp; m == 0) break;

        vector&lt;int&gt; a(m), b(m), c(m);
        map&lt;int, vector&lt;P&gt; &gt; es;
        rep(i, m) {
            cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];
            a[i]--; b[i]--;

            es[c[i]].push_back(P(a[i], b[i]));
        }

        int ans = INF;

        REP(i, 1, 10001) {
            if(es[i].size() == 0) continue;
            UnionFind uf(n);
            REP(j, i, 10001) {
                if(es[j].size() == 0) continue;
                rep(k, es[j].size()) {
                    int a = es[j][k].first;
                    int b = es[j][k].second;

                    if(uf.same(a, b)) continue;
                    uf.unite(a, b);
                }

                if(uf.size() == 1) {
                    ans = min(ans, j - i);
                    break;
                }
            }
        }

        if(ans == INF) cout &lt;&lt; -1 &lt;&lt; endl;
        else cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2153 Mirror Cave]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/21/aoj2153-mirror-cave/"/>
    <updated>2016-05-21T02:18:25+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/21/aoj2153-mirror-cave</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2153">Mirror Cave | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>状態を<script type="math/tex">(ay, ax, by, bx)</script>として幅優先探索．このようにすれば，片方が移動して片方が壁で立ち止まる場合も表現出来る．左右を逆にするのが面倒だったので，まず最初にLenの方の部屋を反転して，同じ <script type="math/tex"> (dy, dx) </script>を使った．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int h, w;
int sax, say, sbx, sby, gax, gay, gbx, gby;
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1};
bool used[55][55][55][55];

bool can(int y, int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}

int main() {
    while(cin &gt;&gt; w &gt;&gt; h) {
        if(w == 0 &amp;&amp; h == 0) break;

        string A[h], B[h];
        rep(i, h) cin &gt;&gt; A[i] &gt;&gt; B[i];
        rep(i, h) reverse(B[i].begin(), B[i].end());

        rep(i, h) {
            rep(j, w) {
                if(A[i][j] == 'L') {
                    say = i;
                    sax = j;
                    A[i][j] = '.';
                }

                if(B[i][j] == 'R') {
                    sby = i;
                    sbx = j;
                    B[i][j] = '.';
                }

                if(A[i][j] == '%') {
                    gay = i;
                    gax = j;
                    A[i][j] = '.';
                }

                if(B[i][j] == '%') {
                    gby = i;
                    gbx = j;
                    B[i][j] = '.';
                }
            }
        }

        queue&lt;pair&lt; P, P &gt; &gt; que;
        que.push(mp( mp(say, sax), mp(sby, sbx) ));

        memset(used, 0, sizeof(used));
        used[say][sax][sby][sbx] = true;

        bool flag = false;

        while(que.size()) {
            pair&lt;P, P&gt; p = que.front(); que.pop();

            int ay = p.first.first, ax = p.first.second;
            int by = p.second.first, bx = p.second.second;

            if(ay == gay &amp;&amp; ax == gax &amp;&amp; by == gby &amp;&amp; bx == gbx) {
                flag = true;
                break;
            }

            if((ay == gay &amp;&amp; ax == gax) || (by == gby &amp;&amp; bx == gbx)) {
                continue;
            }

            rep(i, 4) {
                int nay = ay + dy[i];
                int nax = ax + dx[i];

                int nby = by + dy[i];
                int nbx = bx + dx[i];

                if(!can(nay, nax) || A[nay][nax] == '#') {
                    nay -= dy[i];
                    nax -= dx[i];
                }

                if(!can(nby, nbx) || B[nby][nbx] == '#') {
                    nby -= dy[i];
                    nbx -= dx[i];
                }

                if(!used[nay][nax][nby][nbx]) {
                    que.push(mp( mp(nay, nax), mp(nby, nbx) ));
                    used[nay][nax][nby][nbx] = true;
                }
            }
        }

        if(flag) {
            cout &lt;&lt; "Yes" &lt;&lt; endl;
        } else {
            cout &lt;&lt; "No" &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1175 And Then. How Many Any There?]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/21/and-then-how-many-any-there/"/>
    <updated>2016-05-21T01:35:44+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/21/and-then-how-many-any-there</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1175&lang=jp">And Then. How Many Are There? | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>別の円盤が上に無い状態の円盤は同じ色が偶数の場合は全部消し，奇数の場合は <script type="math/tex"> 1 </script>個消さないのを選ぶ，というやり方でやっていたが，消す順番によりそれより多く消せるパターンというのがありこれは間違いだった．<br/>
選ぶ順番によって消せる枚数が違ってくるので，各状態毎に <script type="math/tex"> (i, j) </script>を列挙して消せるかどうかを調べる． <script type="math/tex"> n </script>は最大で <script type="math/tex"> 4 * 6 = 24 </script>なので，状態数は <script type="math/tex"> 2 ^{24} </script>．intのbitでどの円盤を使ったかを管理した． <script type="math/tex"> O(2 ^n n ^2)  </script>．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;

struct P {
    int x, y, r, c;

    P() : x(0), y(0), r(0), c(0) {}
    P(int x, int y, int r, int c) : x(x), y(y), r(r), c(c) {}
};

int n, ans;
vector&lt;P&gt; v;
set&lt;int&gt; memo;

void dfs(int S) {
    if(memo.find(S) != memo.end()) return;
    memo.insert(S);

    ans = max(ans, __builtin_popcount(S));
    if(ans == n) return;

    bool up[50];
    memset(up, 0, sizeof(up));
    for(int i = n-1; i &gt;= 0; i--) {
        if(S &amp; (1&lt;&lt;i)) continue;

        bool flag = true;
        for(int j = i-1; j &gt;= 0; j--) {
            if(S &amp; (1&lt;&lt;j)) continue;
            int dist = (v[j].x - v[i].x) * (v[j].x - v[i].x) + (v[j].y - v[i].y) * (v[j].y - v[i].y);
            int len = (v[i].r + v[j].r) * (v[i].r + v[j].r);

            if(dist &lt; len) {
                flag = false;
            }
        }

        if(!flag) up[i] = true;
    }

    set&lt;int&gt; st[5];
    for(int i = n-1; i &gt;= 0; i--) {
        if((S &amp; (1&lt;&lt;i)) || up[i]) continue;

        bool flag = true;

        for(int j = i-1; j &gt;= 0; j--) {
            if((S &amp; (1&lt;&lt;j)) || up[j]) continue;

            int dist = (v[j].x - v[i].x) * (v[j].x - v[i].x) + (v[j].y - v[i].y) * (v[j].y - v[i].y);
            int len = (v[i].r + v[j].r) * (v[i].r + v[j].r);

            if(dist &gt;= len &amp;&amp; v[i].c == v[j].c) {
                dfs(S + (1&lt;&lt;i) + (1&lt;&lt;j));
            }
        }
    }
}

int main() {
    while(cin &gt;&gt; n &amp;&amp; n) {

        v.clear();
        memo.clear();

        rep(i, n) {
            int x, y, r, c;
            cin &gt;&gt; x &gt;&gt; y &gt;&gt; r &gt;&gt; c;
            v.push_back(P(x, y, r, c));
        }

        vector&lt;bool&gt; used(n);
        rep(i, n) used[i] = false;

        ans = 0;
        int S = 0;
        dfs(S);

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2005 Water Pipe Construction]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/20/aoj2005-water-pipe-construction/"/>
    <updated>2016-05-20T23:21:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/20/aoj2005-water-pipe-construction</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2005">Water Pipe Construction | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>水源<script type="math/tex"> s </script>から， <script type="math/tex"> 2つの </script>主要な基地 <script type="math/tex"> g_1, g_2 </script>まで水を運ぶための導水管の敷設にかかるコストを最小化する．<br/>
以下の<script type="math/tex"> 3 </script>パターンに分かれる．</p>

<p><img src="/images/AOJ/2005-1.png">
<img src="/images/AOJ/2005-2.png">
<img src="/images/AOJ/2005-3.png"></p>

<p>　<script type="math/tex"> n(3 \leq n \leq 100) </script>なのでwarshall-floydで最短経路を出してこの <script type="math/tex"> 3 </script>パターンのminを取った．<br/>
経路復元がいるかと思ったけど，いらなかった．もし <script type="math/tex"> s \to g1 \to g2 </script>で <script type="math/tex"> s \to g1 </script>と <script type="math/tex"> g1 \to g2 </script>の通る頂点に重なりがある場合，重複して道を数えているのでそのパターンではなく，パターン <script type="math/tex"> 3 </script>のケースの方が良い．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll d[105][105];
int to[105][105];

void warshall_floyd(int n, int m) {
    rep(i, n) rep(j, n) d[i][j] = INF;
    rep(i, n) d[i][i] = 0;

    rep(i, n) rep(j, n) to[i][j] = j;

    //input
    rep(i, m) {
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;

        a--; b--;
        d[a][b] = c;
        // d[b][a] = c;
    }

    rep(k,n) {
        rep(i,n) {
            rep(j,n) {
                if(d[i][k] == INF || d[k][j] == INF) continue;
                if(d[i][j] &gt; d[i][k] + d[k][j]) {
                    d[i][j] = d[i][k] + d[k][j];
                    to[i][j] = to[i][k];
                }
            }
        }
    }
}

vector&lt;int&gt; path(int s, int g) {
    int cur = s;
    vector&lt;int&gt; ret;
    for(; cur != g; cur = to[cur][g]) {
        ret.push_back(cur);
    }

    ret.push_back(g);
    return ret;
}

int main() {
    int n, m, s, g1, g2;
    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; g1 &gt;&gt; g2) {
        if(n == 0 &amp;&amp; m == 0 &amp;&amp; s == 0 &amp;&amp; g1 == 0 &amp;&amp; g2 == 0) break;

        s--; g1--; g2--;
        warshall_floyd(n, m);

        ll ans = INF;
        rep(i, n) {
            ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);
        }

        ans = min(ans, d[s][g1] + d[g1][g2]);
        ans = min(ans, d[s][g2] + d[g2][g1]);

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
