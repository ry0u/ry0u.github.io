<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 350 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/350/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-06-09T14:11:03+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ2608 Minus One]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/06/aoj2608-minus-one/"/>
    <updated>2016-06-06T23:24:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/06/aoj2608-minus-one</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2608">Minus One | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>$G$に$e$を付け加えて無向グラフにおける$s$から$t$への最短路の長さより$1$だけ大きいものの個数を答える．これはつまり，パスを貼った時に最短経路長が$1$小さくなるものである．</p>

<p>$s$からの最短経路長を$d[i]$，$t$からの最短経路長を$d2[i]$とする．点$a$と点$b$を結んだ場合，$s \to a \to b \to t$という経路を行くとすると，コストは$d[a] + 1 + d2[b]$となる．この時$s \to t$の最短経路長$+1$となる経路は，
$$
\begin{eqnarray}
    d[t] - 1 &amp;=&amp; d[a] + 1 + d2[b] \\
    d2[b] &amp;=&amp; d[t] - 2 - d[a]
\end{eqnarray}
$$
が条件となる．愚直に$a, b$のペアを列挙して確認すると$O(n ^2)$で間に合わないが，点$a$を決めた時に，経路長$1$少なくなる$b$の選び方は$d[t] - 2 - d[a]$となる$d2[i]$の個数と決まるので，先に$d2[i]$をカウントしておくと$O(n)$で求められる．最短経路を求めるのが一番時間がかかるので全体で$O(n logn)$．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[100005];
int d[100005], d2[100005], cnt[100005];

void dijkstra(int s) {
    priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que;
    rep(i, 100005) d[i] = INF;

    que.push(mp(0, s));
    d[s] = 0;

    while(que.size()) {
        P p = que.top(); que.pop();
        int cost = p.first;
        int v = p.second;

        if(d[v] &lt; cost) continue;

        rep(i, G[v].size()) {
            edge e = G[v][i];
            if(d[e.to] &gt; d[v] + e.cost) {
                d[e.to] = d[v] + e.cost;
                que.push(mp(d[e.to], e.to));
            }
        }
    }
}

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    int s, t;
    cin &gt;&gt; s &gt;&gt; t;
    s--; t--;

    rep(i, m) {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        a--; b--;

        G[a].push_back(edge(b, 1));
        G[b].push_back(edge(a, 1));
    }

    dijkstra(s);
    rep(i, n) d2[i] = d[i];

    dijkstra(t);
    rep(i, n) swap(d[i], d2[i]);

    memset(cnt, 0, sizeof(cnt));
    rep(i, n) {
        if(d2[i] == INF) continue;
        cnt[d2[i]]++;
    }

    ll ans = 0;
    rep(i, n) {
        if(d[i] == INF || d2[i] == INF) continue;
        int x = d[t] - 2 - d[i];

        if(x &gt;= 0) {
            ans += cnt[x];
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>経路復元とか色々していて，色々考えた後に書き直したら非常にスッキリして面白いと思った．但し解くのに時間がかかりすぎている&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2241 Usaneko Matrix]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/04/aoj2241-usaneko-matrix/"/>
    <updated>2016-06-04T17:34:11+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/04/aoj2241-usaneko-matrix</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2241">Usaneko Matrix | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>ビンゴゲームをやる．行，列，斜めで揃っているものが$u$，$v$以上になれば勝ちとなる．それぞれの数字がどこの座標にあったかをチェックし，引いた数の座標から，縦横斜めの該当する所を$+1$する．先にどちらかが勝った場合は後は続けなくて良いので，毎回引くごとに合計を確認した．$n=1$は，場合分けした．$O(nm)$</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n, u, v, m;
    cin &gt;&gt; n &gt;&gt; u &gt;&gt; v &gt;&gt; m;

    map&lt;int, vector&lt;P&gt; &gt; ma[2];
    vector&lt;vector&lt;int&gt; &gt; a(n, vector&lt;int&gt;(n)), b(n, vector&lt;int&gt;(n));

    rep(i, n) {
        rep(j, n) {
            cin &gt;&gt; a[i][j];
            ma[0][a[i][j]].push_back(mp(i, j));
        }
    }

    rep(i, n) {
        rep(j, n) {
            cin &gt;&gt; b[i][j];
            ma[1][b[i][j]].push_back(mp(i, j));
        }
    }

    vector&lt;int&gt; x(m);
    rep(i, m) cin &gt;&gt; x[i];

    if(n == 1) {
        rep(i, m) {
            int sum[2];
            memset(sum, 0, sizeof(sum));

            rep(j, 2) {
                vector&lt;P&gt; res = ma[j][x[i]];
                if(res.size() &gt;= 1) sum[j]++;
            }

            bool f1 = (sum[0] &gt;= u);
            bool f2 = (sum[1] &gt;= v);

            if(f1 &amp;&amp; f2) {
                cout &lt;&lt; "DRAW" &lt;&lt; endl;
                return 0;
            } else if(f1) {
                cout &lt;&lt; "USAGI" &lt;&lt; endl;
                return 0;
            } else if(f2) {
                cout &lt;&lt; "NEKO" &lt;&lt; endl;
                return 0;
            }
        }

        cout &lt;&lt; "DRAW" &lt;&lt; endl;
        return 0;
    }


    int cy[2][505], cx[2][505], cross[2][2];
    memset(cy, 0, sizeof(cy));
    memset(cx, 0, sizeof(cx));
    memset(cross, 0, sizeof(cross));

    rep(i, m) {

        rep(j, 2) {
            vector&lt;P&gt; res = ma[j][x[i]];
            rep(k, res.size()) {
                int f = res[k].first, s = res[k].second;
                cy[j][f]++;
                cx[j][s]++;

                if(f == s) cross[j][0]++;
                if(f == n - 1 - s) cross[j][1]++;
            }
        }

        int sum[2];
        memset(sum, 0, sizeof(sum));

        rep(j, 2) {
            rep(k, 2) {
                sum[j] += (cross[j][k] == n);
            }
        }

        rep(j, 2) {
            rep(k, n) {
                sum[j] += (cy[j][k] == n);
                sum[j] += (cx[j][k] == n);
            }
        }

        bool f1 = (sum[0] &gt;= u), f2 = (sum[1] &gt;= v);
        if(f1 &amp;&amp; f2) {
            cout &lt;&lt; "DRAW" &lt;&lt; endl;
            return 0;
        } else if(f1) {
            cout &lt;&lt; "USAGI" &lt;&lt; endl;
            return 0;
        } else if(f2) {
            cout &lt;&lt; "NEKO" &lt;&lt; endl;
            return 0;
        }
    }

    cout &lt;&lt; "DRAW" &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2383 Rabbit Game Playing]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/30/aoj2383-rabbit-game-playing/"/>
    <updated>2016-05-30T21:06:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/30/aoj2383-rabbit-game-playing</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2383">Rabbit Game Playing | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>現在プレイした(ステージの難易度 <script type="math/tex"> -T </script>)以上の難易度のステージをプレイ出来る． <script type="math/tex"> N </script>ステージ全てプレイする時に，何通りの方法があるか？ <script type="math/tex"> mod\ 1000000007 </script>で求める．</p>

<p>難易度でsortして，小さい順に列に入れていく． <script type="math/tex"> i-1個 </script>で構成される上記のルールを満たす列に <script type="math/tex"> v[i] </script>を入れることを考える．列の中に <script type="math/tex"> v[i]-t </script>以上のものがあれば，その後に <script type="math/tex"> v[i] </script>を入れることが出来る．つまり， (<script type="math/tex"> i-1 </script>までの場合の数 <script type="math/tex"> \times </script> <script type="math/tex"> iまででv[i]-t </script>以上のステージの個数)通りとなる．これを <script type="math/tex"> N </script>回繰り返す．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair
#define MOD 1000000007

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n, t;
    cin &gt;&gt; n &gt;&gt; t;

    vector&lt;int&gt; v(n);
    rep(i, n) cin &gt;&gt; v[i];

    sort(v.begin(), v.end());

    ll ans = 1;
    vector&lt;int&gt; res;
    rep(i, n) {
        res.push_back(v[i]);
        int id = lower_bound(res.begin(), res.end(), v[i] - t) - res.begin();
        ans *= (res.size() - id);
        ans %= MOD;
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2176 For the Peace]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/29/aoj2176-for-the-peace/"/>
    <updated>2016-05-29T23:33:39+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/29/aoj2176-for-the-peace</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2176">For the Peace</a></h4><p>This is a story of a world somewhere far from the earth. In this world, the land is parted into a number of countries ruled by empires. This world is not very peaceful: they have been involved in army race. They are competing in production of missiles in particular.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>それぞれの国の <script type="math/tex"> war\ potential </script>はミサイルの威力の合計で決まる．ミサイルはそれぞれの国と差が <script type="math/tex"> d </script>以下なら捨てることが出来る．全ての国はミサイルを捨てることが出来るか？</p>

<p>何かを捨てたことによって，本来捨てられるべきものが捨てられなかった，という場合がないので，捨てられるものから捨てていった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;stack&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n, d;
    while(cin &gt;&gt; n &gt;&gt; d) {
        if(n == 0 &amp;&amp; d == 0) break;

        stack&lt;int&gt; st[n];
        vector&lt;int&gt; sum(n);
        rep(i, n) {
            int m;
            cin &gt;&gt; m;

            rep(j, m) {
                int x;
                cin &gt;&gt; x;

                st[i].push(x);
                sum[i] += x;
            }
        }

        int id = 0, cnt = 0;
        while(cnt != n) {
            if(st[id].size() == 0) {
                id = (id + 1) % n;
                cnt++;
                continue;
            }

            int p = st[id].top();
            sum[id] -= p;

            int vmin = INF, vmax = 0;
            rep(i, n) {
                vmin = min(vmin, sum[i]);
                vmax = max(vmax, sum[i]);
            }

            if(vmax - vmin &lt;= d) {
                st[id].pop();
                cnt = 0;
            } else {
                sum[id] += p;
                cnt++;
            }

            id = (id + 1) % n;
        }

        bool flag = true;
        rep(i, n) {
            if(sum[i] == 0) continue;
            flag  = false;
        }

        if(flag) cout &lt;&lt; "Yes" &lt;&lt; endl;
        else cout &lt;&lt; "No" &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2299 Tiles are Colorful]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/28/aoj2299-tiles-are-colorful/"/>
    <updated>2016-05-28T23:31:22+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/28/aoj2299-tiles-are-colorful</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2299">Tiles are Colorful | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>マスを叩くとその，上下左右各方向に進んでいき，最初に当たったタイルに同じ色があればそのタイルを消す．最大で何個消せるか？</p>

<blockquote><p>1 ≤ M ≤ 500，1 ≤ N ≤ 500 を満たす．各アルファベット大文字は入力中に 0 個または 2 個現れる．</p></blockquote>

<p>Inputの一番最後に重要なことが書いてあって最初は見逃していた．つまり各アルファベットの対が <script type="math/tex"> 1 </script>個あるかないか，という制約である．各ペアのアルファベットを消すために，どのアルファベットが消されている必要があるかを考える．特に依存関係が無ければそのタイルを消し，他のアルファベットの依存関係になっている箇所があればそこも消す．これを繰り返す．<br/>
縦，横，斜めのパターンに分けて依存関係を調べた．自分の実装では斜めのパターンが結構面倒だった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int m, n;
    cin &gt;&gt; m &gt;&gt; n;

    vector&lt;string&gt; v(m);
    rep(i, m) cin &gt;&gt; v[i];

    map&lt;char, vector&lt;int&gt; &gt; x, y;
    rep(i, m) {
        rep(j, n) {
            if('A' &lt;= v[i][j] &amp;&amp; v[i][j] &lt;= 'Z') {
                y[v[i][j]].push_back(i);
                x[v[i][j]].push_back(j);
            }
        }
    }

    set&lt;char&gt; st[30][2];
    bool used[30][2];
    memset(used, 0, sizeof(used));

    rep(i, 26) {
        char c = 'A' + i;
        if(x[c].size() == 0) continue;

        if(x[c][0] == x[c][1]) {
            if(abs(y[c][0] - y[c][1]) == 1) continue;
            used[i][0] = true;
            int x1 = x[c][0];
            int y1 = y[c][0], y2 = y[c][1];

            REP(j, min(y1, y2) + 1, max(y1, y2)) {
                if(v[j][x1] == '.') continue;
                st[i][0].insert(v[j][x1]);
            }
        } else if(y[c][0] == y[c][1]) {
            if(abs(x[c][0] - x[c][1]) == 1) continue;
            used[i][0] = true;
            int y1 = y[c][0];
            int x1 = x[c][0], x2 = x[c][1];
            REP(j, min(x1, x2) + 1, max(x1, x2)) {
                if(v[y1][j] == '.') continue;
                st[i][0].insert(v[y1][j]);
            }
        } else {
            used[i][0] = true;
            used[i][1] = true;
            int x1 = x[c][0], x2 = x[c][1];
            int y1 = y[c][0], y2 = y[c][1];

            REP(j, min(x1, x2), max(x1, x2) + 1) {
                if(v[y1][j] == '.' || v[y1][j] == c) continue;
                st[i][0].insert(v[y1][j]);
            }

            REP(j, min(y1, y2), max(y1, y2) + 1) {
                if(v[j][x2] == '.' || v[j][x2] == c) continue;
                st[i][0].insert(v[j][x2]);
            }

            REP(j, min(y1, y2), max(y1, y2) + 1) {
                if(v[j][x1] == '.' || v[j][x1] == c) continue;
                st[i][1].insert(v[j][x1]);
            }

            REP(j, min(x1, x2), max(x1, x2) + 1) {
                if(v[y2][j] == '.' || v[y2][j] == c) continue;
                st[i][1].insert(v[y2][j]);
            }
        }
    }

    int sum = 0;
    while(true) {
        bool flag = true;
        rep(i, 26) {
            char c = 'A' + i;

            rep(j, 2) {
                if(!used[i][j]) continue;
                if(st[i][j].size() == 0) {
                    flag = false;
                    used[i][j] = false;
                    used[i][!j] = false;

                    rep(k, 26) {
                        rep(l, 2) {
                            st[k][l].erase(c);
                        }
                    }
                    sum += 2;
                }
            }
        }

        if(flag) break;
    }

    cout &lt;&lt; sum &lt;&lt; endl;


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
