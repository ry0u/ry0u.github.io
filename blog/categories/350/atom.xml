<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 350 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/350/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-06-05T02:02:13+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ2241 Usaneko Matrix]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/04/aoj2241-usaneko-matrix/"/>
    <updated>2016-06-04T17:34:11+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/04/aoj2241-usaneko-matrix</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2241">Usaneko Matrix | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>ビンゴゲームをやる．行，列，斜めで揃っているものが$u$，$v$以上になれば勝ちとなる．それぞれの数字がどこの座標にあったかをチェックし，引いた数の座標から，縦横斜めの該当する所を$+1$する．先にどちらかが勝った場合は後は続けなくて良いので，毎回引くごとに合計を確認した．$O(nm)$</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2383 Rabbit Game Playing]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/30/aoj2383-rabbit-game-playing/"/>
    <updated>2016-05-30T21:06:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/30/aoj2383-rabbit-game-playing</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2383">Rabbit Game Playing | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>現在プレイした(ステージの難易度 <script type="math/tex"> -T </script>)以上の難易度のステージをプレイ出来る． <script type="math/tex"> N </script>ステージ全てプレイする時に，何通りの方法があるか？ <script type="math/tex"> mod\ 1000000007 </script>で求める．</p>

<p>難易度でsortして，小さい順に列に入れていく． <script type="math/tex"> i-1個 </script>で構成される上記のルールを満たす列に <script type="math/tex"> v[i] </script>を入れることを考える．列の中に <script type="math/tex"> v[i]-t </script>以上のものがあれば，その後に <script type="math/tex"> v[i] </script>を入れることが出来る．つまり， (<script type="math/tex"> i-1 </script>までの場合の数 <script type="math/tex"> \times </script> <script type="math/tex"> iまででv[i]-t </script>以上のステージの個数)通りとなる．これを <script type="math/tex"> N </script>回繰り返す．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair
#define MOD 1000000007

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n, t;
    cin &gt;&gt; n &gt;&gt; t;

    vector&lt;int&gt; v(n);
    rep(i, n) cin &gt;&gt; v[i];

    sort(v.begin(), v.end());

    ll ans = 1;
    vector&lt;int&gt; res;
    rep(i, n) {
        res.push_back(v[i]);
        int id = lower_bound(res.begin(), res.end(), v[i] - t) - res.begin();
        ans *= (res.size() - id);
        ans %= MOD;
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2176 For the Peace]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/29/aoj2176-for-the-peace/"/>
    <updated>2016-05-29T23:33:39+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/29/aoj2176-for-the-peace</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2176">For the Peace</a></h4><p>This is a story of a world somewhere far from the earth. In this world, the land is parted into a number of countries ruled by empires. This world is not very peaceful: they have been involved in army race. They are competing in production of missiles in particular.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>それぞれの国の <script type="math/tex"> war\ potential </script>はミサイルの威力の合計で決まる．ミサイルはそれぞれの国と差が <script type="math/tex"> d </script>以下なら捨てることが出来る．全ての国はミサイルを捨てることが出来るか？</p>

<p>何かを捨てたことによって，本来捨てられるべきものが捨てられなかった，という場合がないので，捨てられるものから捨てていった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;stack&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n, d;
    while(cin &gt;&gt; n &gt;&gt; d) {
        if(n == 0 &amp;&amp; d == 0) break;

        stack&lt;int&gt; st[n];
        vector&lt;int&gt; sum(n);
        rep(i, n) {
            int m;
            cin &gt;&gt; m;

            rep(j, m) {
                int x;
                cin &gt;&gt; x;

                st[i].push(x);
                sum[i] += x;
            }
        }

        int id = 0, cnt = 0;
        while(cnt != n) {
            if(st[id].size() == 0) {
                id = (id + 1) % n;
                cnt++;
                continue;
            }

            int p = st[id].top();
            sum[id] -= p;

            int vmin = INF, vmax = 0;
            rep(i, n) {
                vmin = min(vmin, sum[i]);
                vmax = max(vmax, sum[i]);
            }

            if(vmax - vmin &lt;= d) {
                st[id].pop();
                cnt = 0;
            } else {
                sum[id] += p;
                cnt++;
            }

            id = (id + 1) % n;
        }

        bool flag = true;
        rep(i, n) {
            if(sum[i] == 0) continue;
            flag  = false;
        }

        if(flag) cout &lt;&lt; "Yes" &lt;&lt; endl;
        else cout &lt;&lt; "No" &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2299 Tiles are Colorful]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/28/aoj2299-tiles-are-colorful/"/>
    <updated>2016-05-28T23:31:22+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/28/aoj2299-tiles-are-colorful</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2299">Tiles are Colorful | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>マスを叩くとその，上下左右各方向に進んでいき，最初に当たったタイルに同じ色があればそのタイルを消す．最大で何個消せるか？</p>

<blockquote><p>1 ≤ M ≤ 500，1 ≤ N ≤ 500 を満たす．各アルファベット大文字は入力中に 0 個または 2 個現れる．</p></blockquote>

<p>Inputの一番最後に重要なことが書いてあって最初は見逃していた．つまり各アルファベットの対が <script type="math/tex"> 1 </script>個あるかないか，という制約である．各ペアのアルファベットを消すために，どのアルファベットが消されている必要があるかを考える．特に依存関係が無ければそのタイルを消し，他のアルファベットの依存関係になっている箇所があればそこも消す．これを繰り返す．<br/>
縦，横，斜めのパターンに分けて依存関係を調べた．自分の実装では斜めのパターンが結構面倒だった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int m, n;
    cin &gt;&gt; m &gt;&gt; n;

    vector&lt;string&gt; v(m);
    rep(i, m) cin &gt;&gt; v[i];

    map&lt;char, vector&lt;int&gt; &gt; x, y;
    rep(i, m) {
        rep(j, n) {
            if('A' &lt;= v[i][j] &amp;&amp; v[i][j] &lt;= 'Z') {
                y[v[i][j]].push_back(i);
                x[v[i][j]].push_back(j);
            }
        }
    }

    set&lt;char&gt; st[30][2];
    bool used[30][2];
    memset(used, 0, sizeof(used));

    rep(i, 26) {
        char c = 'A' + i;
        if(x[c].size() == 0) continue;

        if(x[c][0] == x[c][1]) {
            if(abs(y[c][0] - y[c][1]) == 1) continue;
            used[i][0] = true;
            int x1 = x[c][0];
            int y1 = y[c][0], y2 = y[c][1];

            REP(j, min(y1, y2) + 1, max(y1, y2)) {
                if(v[j][x1] == '.') continue;
                st[i][0].insert(v[j][x1]);
            }
        } else if(y[c][0] == y[c][1]) {
            if(abs(x[c][0] - x[c][1]) == 1) continue;
            used[i][0] = true;
            int y1 = y[c][0];
            int x1 = x[c][0], x2 = x[c][1];
            REP(j, min(x1, x2) + 1, max(x1, x2)) {
                if(v[y1][j] == '.') continue;
                st[i][0].insert(v[y1][j]);
            }
        } else {
            used[i][0] = true;
            used[i][1] = true;
            int x1 = x[c][0], x2 = x[c][1];
            int y1 = y[c][0], y2 = y[c][1];

            REP(j, min(x1, x2), max(x1, x2) + 1) {
                if(v[y1][j] == '.' || v[y1][j] == c) continue;
                st[i][0].insert(v[y1][j]);
            }

            REP(j, min(y1, y2), max(y1, y2) + 1) {
                if(v[j][x2] == '.' || v[j][x2] == c) continue;
                st[i][0].insert(v[j][x2]);
            }

            REP(j, min(y1, y2), max(y1, y2) + 1) {
                if(v[j][x1] == '.' || v[j][x1] == c) continue;
                st[i][1].insert(v[j][x1]);
            }

            REP(j, min(x1, x2), max(x1, x2) + 1) {
                if(v[y2][j] == '.' || v[y2][j] == c) continue;
                st[i][1].insert(v[y2][j]);
            }
        }
    }

    int sum = 0;
    while(true) {
        bool flag = true;
        rep(i, 26) {
            char c = 'A' + i;

            rep(j, 2) {
                if(!used[i][j]) continue;
                if(st[i][j].size() == 0) {
                    flag = false;
                    used[i][j] = false;
                    used[i][!j] = false;

                    rep(k, 26) {
                        rep(l, 2) {
                            st[k][l].erase(c);
                        }
                    }
                    sum += 2;
                }
            }
        }

        if(flag) break;
    }

    cout &lt;&lt; sum &lt;&lt; endl;


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2320 Infinity Maze]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/22/aoj2320-infinity-maze/"/>
    <updated>2016-05-22T23:54:24+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/22/aoj2320-infinity-maze</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2320">Infinity Maze</a></h4><p>Dr. Fukuoka has placed a simple robot in a two-dimensional maze. It moves within the maze and never goes out of the maze as there is no exit. The maze is made up of H × W grid cells as depicted below. The upper side of the maze faces north.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>向いてる方向に一歩進む．進めない場合は進めるまで<script type="math/tex"> 90 </script>度回転して進む．この行動を<script type="math/tex"> L </script>( <script type="math/tex"> 1 \leq L \leq 10 ^{18}) </script>)回行った時に最終的にはどこにどの向きでいるか．<br/>
行動回数<script type="math/tex"> L </script>が非常に大きいが盤面は <script type="math/tex"> 100 \times 100 </script>なので，行動回数が多い場合は，どこかを周回</p>

<p><img src="/images/AOJ/2320.png"><br/>
(赤い所をグルグル周る)感じになるので，周回する所を見つけて，後は行動回数をその周期で割り，最終的にいる場所を出す．メモするのが<script type="math/tex"> (y, x, 次に向かう方向) </script>で答えるのが<script type="math/tex"> (y, x, 現在向いてる方向) </script>で違うので混乱していた．周回する場所を見つけるために，次に向かう方向を持っていたので，その場所が見つかる前に行動が終わった場合は，その <script type="math/tex"> 1 </script>個前の方向を答えなければならずWAを生やした．<br/>
時間をめちゃくちゃかけてしまったので，もう少し早く解けるようになりたい&hellip;</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int h, w;
int sy, sx, dir;
int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};
char dd[4] = {'E', 'S', 'W', 'N'};

bool can(int y, int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}

int main() {
    ll l;
    while(cin &gt;&gt; h &gt;&gt; w &gt;&gt; l) {
        if(h == 0 &amp;&amp; w == 0 &amp;&amp; l == 0) break;

        vector&lt;string&gt; v(h);
        rep(i, h) cin &gt;&gt; v[i];

        rep(i, h) {
            rep(j, w) {
                if(v[i][j] == 'E') {
                    sy = i; sx = j;
                    dir = 0;
                    v[i][j] = '.';
                }
                else if(v[i][j] == 'S') {
                    sy = i; sx = j;
                    dir = 1;
                    v[i][j] = '.';
                }
                else if(v[i][j] == 'W') {
                    sy = i; sx = j;
                    dir = 2;
                    v[i][j] = '.';
                }
                else if(v[i][j] == 'N') {
                    sy = i; sx = j;
                    dir = 3;
                    v[i][j] = '.';
                }
            }
        }

        ll d[105][105][4];
        memset(d, -1, sizeof(d));

        vector&lt;int&gt; X, Y, D;
        int y = sy, x = sx, cnt = 0;

        rep(i, 4) {
            int ny = y + dy[(dir + i) % 4];
            int nx = x + dx[(dir + i) % 4];

            if(can(ny, nx) &amp;&amp; v[ny][nx] == '.') {
                dir = (dir + i) % 4;
                break;
            }
        }

        int pdir = dir;
        d[y][x][dir] = cnt;
        cnt++;

        while(l) {
            y = y + dy[dir];
            x = x + dx[dir];
            pdir = dir;
            l--;

            rep(i, 4) {
                int ny = y + dy[(dir + i) % 4];
                int nx = x + dx[(dir + i) % 4];

                if(can(ny, nx) &amp;&amp; v[ny][nx] == '.') {
                    dir = (dir + i) % 4;
                    break;
                }
            }

            if(d[y][x][dir] == -1) {
                d[y][x][dir] = cnt;
                cnt++;
            } else {
                break;
            }
        }

        if(l == 0) {
            cout &lt;&lt; y + 1 &lt;&lt; " " &lt;&lt; x + 1 &lt;&lt; " " &lt;&lt; dd[pdir] &lt;&lt; endl;
            continue;
        }

        ll len = cnt - d[y][x][dir];
        l = l % len;
        dir = pdir;

        rep(i, l) {
            rep(j, 4) {
                int ny = y + dy[(dir + j) % 4];
                int nx = x + dx[(dir + j) % 4];

                if(can(ny, nx) &amp;&amp; v[ny][nx] == '.') {
                    y = ny; x = nx;
                    dir = (dir + j) % 4;
                    break;
                }
            }
        }

        cout &lt;&lt; y + 1 &lt;&lt; " " &lt;&lt; x + 1 &lt;&lt; " " &lt;&lt; dd[dir] &lt;&lt; endl;
    }


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
