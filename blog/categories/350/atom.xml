<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 350 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/350/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-05-20T23:10:21+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How can I satisfy thee? Let me count the ways...]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/20/how-can-i-satisfy-thee-let-me-count-the-ways-dot-dot-dot/"/>
    <updated>2016-05-20T22:38:10+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/20/how-can-i-satisfy-thee-let-me-count-the-ways-dot-dot-dot</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-image="http://judge.u-aizu.ac.jp/onlinejudge/IMAGE1/2008C2.png" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1155&lang=jp">How can I satisfy thee? Let me count the ways... | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>構文解析．
<script type="math/tex; mode=display">
\begin{eqnarray}
<formula>\ &amp;::=&amp;\ 0\ or\ 1\ or\ 2 \
<formula>\ &amp;::=&amp;\ -<formula> \
<formula>\ &amp;::=&amp;\ (<formula>\ +\ or\ * <formula>) \
\end{eqnarray}
</script>
の場合に分けて考える．入れ子の括弧にどう対応させるかよく分からなかったが，自分なりに理解することができた．構文解析の関数が出来たら，<script type="math/tex"> (P, Q, R) </script>の組み合わせ(<script type="math/tex"> 2 ^3 </script>通り)を全列挙して， <script type="math/tex"> 2 </script>となる個数を数える．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int formula(string&amp; s, int&amp; i) {
    if(s[i] == '(') {
        i++;
        int val = formula(s, i);

        char op = s[i];

        i++;
        int val2 = formula(s, i);

        int ret = 0;
        if(op == '+') {
            if(val == 2 || val2 == 2) ret = 2;
            else if(val == 1 || val2 == 1) ret = 1;
            else ret = 0;
        }
        if(op == '*') {
            if(val == 2 &amp;&amp; val2 == 2) ret = 2;
            else if((val == 1 || val == 2) &amp;&amp; (val2 == 1 || val2 == 2)) ret = 1;
            else ret = 0;
        }

        i++;
        return ret;
    } else if(isdigit(s[i])) {
        int ret = (s[i] - '0');
        i++;
        return ret;
    } else if(s[i] == '-') {
        i++;
        int val = formula(s, i);

        int ret = 0;
        if(val == 0) ret = 2;
        if(val == 1) ret = 1;
        if(val == 2) ret = 0;

        return ret;
    }
}


int main() {
    string s;
    while(cin &gt;&gt; s) {
        if(s == ".") break;

        int ans = 0;
        rep(i, 3) {
            rep(j, 3) {
                rep(k, 3) {
                    string t = s;
                    rep(l, s.size()) {
                        if(t[l] == 'P') t[l] = ('0' + i);
                        else if(t[l] == 'Q') t[l] = ('0' + j);
                        else if(t[l] == 'R') t[l] = ('0' + k);
                    }

                    int p = 0;
                    if(formula(t, p) == 2) {
                        ans++;
                    }
                }
            }
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1174 Identically Colored Panels Connection]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/18/aoj1174-identically-colored-panels-connection/"/>
    <updated>2016-04-18T23:00:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/18/aoj1174-identically-colored-panels-connection</id>
    <content type="html"><![CDATA[<p><a class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article" href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1174">Identically Colored Panels Connection</a></p>

<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>塗る色を決めて順番に塗っていく． それぞれ</p>

<ul>
<li><script type="math/tex"> rec </script> : 始点から探索して<script type="math/tex"> c </script>と同じパネルが何色あるか</li>
<li><script type="math/tex"> dfs </script> : 始点から探索して<script type="math/tex"> target </script>の色を <script type="math/tex"> change </script>にする．</li>
<li><script type="math/tex"> func </script> : <script type="math/tex"> i </script>回塗った状態． 最終的に<script type="math/tex"> 5 </script>回塗った回数を答えるが，最後に <script type="math/tex"> c </script>に塗り替えた場合なので，<script type="math/tex"> 4 </script>回塗った後に <script type="math/tex"> c </script>に塗って <script type="math/tex"> rec </script>を呼ぶ．</li>
</ul>


<blockquote><p>ただし，電極は左上角のパネルに固定されていることとする．</p></blockquote>

<p>の文を見逃していて，塗り始める場所を全探索していてSampleがずっと合わなかった&hellip;<br/>
全体的に辛い</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int h, w, c;
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1};

bool can(int y,int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}

int cnt = 0, sy = 0, sx = 0;
bool used[10][10];
vector&lt; vector&lt;int&gt; &gt; v;

void rec(int y, int x) {
    used[y][x] = true;
    cnt++;

    rep(i, 4) {
        int ny = y + dy[i];
        int nx = x + dx[i];

        if(can(ny, nx) &amp;&amp; !used[ny][nx] &amp;&amp; v[ny][nx] == c) {
            rec(ny, nx);
        }
    }
}

int target, change;

void dfs(int y, int x) {
    v[y][x] = change;
    rep(i, 4) {
        int ny = y + dy[i];
        int nx = x + dx[i];

        if(can(ny, nx) &amp;&amp; v[ny][nx] == target) {
            dfs(ny, nx);
        }
    }
}

int ans = 0;
void func(vector&lt; vector&lt;int&gt; &gt; t, int id) {
    // cout &lt;&lt; " ------ func ---- :" &lt;&lt; id &lt;&lt; endl;
    // rep(i, h) {
    //  rep(j, w) cout &lt;&lt; t[i][j] &lt;&lt; " ";
    //  cout &lt;&lt; endl;
    // }
    if(id == 4) {
        v = t;
        target = t[sy][sx];

        if(target == c) return;
        change = c;
        dfs(sy, sx);

        cnt = 0;
        memset(used, 0, sizeof(used));
        rec(sy, sx);
        ans = max(ans, cnt);
        return;
    }

    REP(i, 1, 7) {
        if(i == t[sy][sx]) continue;
        v = t;
        target = t[sy][sx]; change = i;
        dfs(sy, sx);
        func(v, id + 1);
    }
}

int main() {
    while(cin &gt;&gt; h &gt;&gt; w &gt;&gt; c) {
        if(h == 0 &amp;&amp; w == 0 &amp;&amp; c == 0) break;

        v.resize(h);
        rep(i, h) {
            v[i].resize(w);
            rep(j, w) cin &gt;&gt; v[i][j];
        }

        ans = 0;
        func(v, 0);

        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
