<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 350 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/350/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-05-26T10:35:08+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ2320 Infinity Maze]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/22/aoj2320-infinity-maze/"/>
    <updated>2016-05-22T23:54:24+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/22/aoj2320-infinity-maze</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2320">Infinity Maze</a></h4><p>Dr. Fukuoka has placed a simple robot in a two-dimensional maze. It moves within the maze and never goes out of the maze as there is no exit. The maze is made up of H × W grid cells as depicted below. The upper side of the maze faces north.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>向いてる方向に一歩進む．進めない場合は進めるまで<script type="math/tex"> 90 </script>度回転して進む．この行動を<script type="math/tex"> L </script>( <script type="math/tex"> 1 \leq L \leq 10 ^18) </script>)回行った時に最終的にはどこにどの向きでいるか．<br/>
行動回数<script type="math/tex"> L </script>が非常に大きいが盤面は <script type="math/tex"> 100 \times 100 </script>なので，行動回数が多い場合は，どこかを周回</p>

<p><img src="/images/AOJ/2320.png"><br/>
(赤い所をグルグル周る)感じになるので，周回する所を見つけて，後は行動回数をその周期で割り，最終的にいる場所を出す．メモするのが<script type="math/tex"> (y, x, 次に向かう方向) </script>で答えるのが<script type="math/tex"> (y, x, 現在向いてる方向) </script>で違うので混乱していた．周回する場所を見つけるために，次に向かう方向を持っていたので，その場所が見つかる前に行動が終わった場合は，その <script type="math/tex"> 1 </script>個前の方向を答えなければならずWAを生やした．<br/>
時間をめちゃくちゃかけてしまったので，もう少し早く解けるようになりたい&hellip;</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int h, w;
int sy, sx, dir;
int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};
char dd[4] = {'E', 'S', 'W', 'N'};

bool can(int y, int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}

int main() {
    ll l;
    while(cin &gt;&gt; h &gt;&gt; w &gt;&gt; l) {
        if(h == 0 &amp;&amp; w == 0 &amp;&amp; l == 0) break;

        vector&lt;string&gt; v(h);
        rep(i, h) cin &gt;&gt; v[i];

        rep(i, h) {
            rep(j, w) {
                if(v[i][j] == 'E') {
                    sy = i; sx = j;
                    dir = 0;
                    v[i][j] = '.';
                }
                else if(v[i][j] == 'S') {
                    sy = i; sx = j;
                    dir = 1;
                    v[i][j] = '.';
                }
                else if(v[i][j] == 'W') {
                    sy = i; sx = j;
                    dir = 2;
                    v[i][j] = '.';
                }
                else if(v[i][j] == 'N') {
                    sy = i; sx = j;
                    dir = 3;
                    v[i][j] = '.';
                }
            }
        }

        ll d[105][105][4];
        memset(d, -1, sizeof(d));

        vector&lt;int&gt; X, Y, D;
        int y = sy, x = sx, cnt = 0;

        rep(i, 4) {
            int ny = y + dy[(dir + i) % 4];
            int nx = x + dx[(dir + i) % 4];

            if(can(ny, nx) &amp;&amp; v[ny][nx] == '.') {
                dir = (dir + i) % 4;
                break;
            }
        }

        int pdir = dir;
        d[y][x][dir] = cnt;
        cnt++;

        while(l) {
            y = y + dy[dir];
            x = x + dx[dir];
            pdir = dir;
            l--;

            rep(i, 4) {
                int ny = y + dy[(dir + i) % 4];
                int nx = x + dx[(dir + i) % 4];

                if(can(ny, nx) &amp;&amp; v[ny][nx] == '.') {
                    dir = (dir + i) % 4;
                    break;
                }
            }

            if(d[y][x][dir] == -1) {
                d[y][x][dir] = cnt;
                cnt++;
            } else {
                break;
            }
        }

        if(l == 0) {
            cout &lt;&lt; y + 1 &lt;&lt; " " &lt;&lt; x + 1 &lt;&lt; " " &lt;&lt; dd[pdir] &lt;&lt; endl;
            continue;
        }

        ll len = cnt - d[y][x][dir];
        l = l % len;
        dir = pdir;

        rep(i, l) {
            rep(j, 4) {
                int ny = y + dy[(dir + j) % 4];
                int nx = x + dx[(dir + j) % 4];

                if(can(ny, nx) &amp;&amp; v[ny][nx] == '.') {
                    y = ny; x = nx;
                    dir = (dir + j) % 4;
                    break;
                }
            }
        }

        cout &lt;&lt; y + 1 &lt;&lt; " " &lt;&lt; x + 1 &lt;&lt; " " &lt;&lt; dd[dir] &lt;&lt; endl;
    }


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2301 Sleeping Time]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/21/aoj2301-sleeping-time/"/>
    <updated>2016-05-21T03:02:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/21/aoj2301-sleeping-time</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2301">Sleeping Time | Aizu Online Judge</a></h4><p>Miki is a high school student. She has a part time job, so she cannot take enough sleep on weekdays. She wants to take good sleep on holidays, but she doesn't know the best length of sleeping time for her.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>愚直に <script type="math/tex"> k </script>回のシュミレーションに対して，間違う/間違わないをすると <script type="math/tex"> 2 ^{30} </script>となる．ここで枝刈りを行う．シュミレーションが2分探索みたいな感じなので，一度解区間 <script type="math/tex"> [T-E, T+E] </script>を外れたら，再度解区間に入ることは無いので切って良い．この枝刈りだけで <script type="math/tex"> 04.91s </script>でACが取れた．</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int k;
double p, e, t;

double ans = 0;

void dfs(double l, double r, int cnt, double x) {
    if(r &lt; t - e) return;
    if(l &gt; t + e) return;

    double h = (l + r) / 2;

    if(cnt == k) {
        if(t - e &lt;= h &amp;&amp; h &lt;= t + e) ans += x;
        return;
    }

    if(h &gt;= t) {
        dfs(l, h, cnt + 1, (1.0 - p) * x);
        dfs(h, r, cnt + 1, p * x);
    } else {
        dfs(h, r, cnt + 1, (1.0 - p) * x);
        dfs(l, h, cnt + 1, p * x);
    }
}

int main() {
    double l, r;
    cin &gt;&gt; k &gt;&gt; l &gt;&gt; r;
    cin &gt;&gt; p &gt;&gt; e &gt;&gt; t;

    dfs(l, r, 0, 1.0);

    cout &lt;&lt; fixed;
    cout.precision(20);
    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>しかし，他の人の解答を見てみると<script type="math/tex"> 0.0s </script>ばかりだった．自分の解法は <script type="math/tex"> E </script>が十分小さい時に有効な枝刈りで， <script type="math/tex"> E </script>が大きい場合を考えていなかった． この時は解区間が探索区間を内包しているので，この先解区間を出ることはない．よってその枝刈りを追加すると <script type="math/tex"> 0.0s </script>とめちゃくちゃ早くなった．</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int k;
double p, e, t;

double ans = 0;

void dfs(double l, double r, int cnt, double x) {
    if(r &lt; t - e) return;
    if(l &gt; t + e) return;
    if(t - e &lt;= l &amp;&amp; r &lt;= t + e) {
        ans += x;
        return;
    }

    double h = (l + r) / 2;

    if(cnt == k) {
        if(t - e &lt;= h &amp;&amp; h &lt;= t + e) ans += x;
        return;
    }

    if(h &gt;= t) {
        dfs(l, h, cnt + 1, (1.0 - p) * x);
        dfs(h, r, cnt + 1, p * x);
    } else {
        dfs(h, r, cnt + 1, (1.0 - p) * x);
        dfs(l, h, cnt + 1, p * x);
    }
}

int main() {
    double l, r;
    cin &gt;&gt; k &gt;&gt; l &gt;&gt; r;
    cin &gt;&gt; p &gt;&gt; e &gt;&gt; t;

    dfs(l, r, 0, 1.0);

    cout &lt;&lt; fixed;
    cout.precision(20);
    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>まとめると，</p>

<ul>
<li><script type="math/tex"> E </script>が十分小さい時に，解区間から外れた場合の枝刈りが有効</li>
<li><script type="math/tex"> E </script>が十分大きい時に，解区間が内包する場合の枝刈りが有効</li>
</ul>


<p>となって， <script type="math/tex"> 2 ^{30} </script>にはならないで間に合う．(どのくらい減るのかよく分かっていない)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1280 Slim Span]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/21/aoj1280-slim-span/"/>
    <updated>2016-05-21T02:41:52+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/21/aoj1280-slim-span</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1280">Slim Span</a></h4><p>Given an undirected weighted graph G, you should find one of spanning trees specified as follows. A spanning tree T is a tree (a connected subgraph without cycles) which connects all the n vertices with n - 1 edges.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>The <script type="math/tex"> slimness </script> of a spanning tree Tは全域木を構成する辺の最大値 <script type="math/tex"> - </script>最小値と定義される．この値の最小値を求める．<br/>
出来るだけコストが近いものを使った方が良いので，まず使うコストの一番小さいものを決めて，それからコストを増やしていく．全域木が構成出来た時点でのコストのminを取る． <script type="math/tex"> O(nm) </script>．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct UnionFind {
    vector&lt;int&gt; par,rank;
    int N;

    UnionFind(int n) {
        N = n;
        par.resize(n);
        rank.resize(n);

        rep(i,n) {
            par[i] = i;
            rank[i] = 0;
        }
    }

    int find(int x) {
        if(par[x] == x) return x;
        else return par[x] = find(par[x]);
    }

    void unite(int x,int y) {
        x = find(x);
        y = find(y);

        if(x == y) return;

        if(rank[x] &lt; rank[y]) {
            par[x] = y;
        }
        else {
            par[y] = x;
            if(rank[x] == rank[y]) rank[x]++;
        }
    }

    bool same(int x,int y) {
        return find(x) == find(y);
    }

    int size() {
        int cnt = 0;
        rep(i,N) if(find(i) == i) cnt++;
        return cnt;
    }
};

int main() {
    int n, m;

    while(cin &gt;&gt; n &gt;&gt; m) {
        if(n == 0 &amp;&amp; m == 0) break;

        vector&lt;int&gt; a(m), b(m), c(m);
        map&lt;int, vector&lt;P&gt; &gt; es;
        rep(i, m) {
            cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];
            a[i]--; b[i]--;

            es[c[i]].push_back(P(a[i], b[i]));
        }

        int ans = INF;

        REP(i, 1, 10001) {
            if(es[i].size() == 0) continue;
            UnionFind uf(n);
            REP(j, i, 10001) {
                if(es[j].size() == 0) continue;
                rep(k, es[j].size()) {
                    int a = es[j][k].first;
                    int b = es[j][k].second;

                    if(uf.same(a, b)) continue;
                    uf.unite(a, b);
                }

                if(uf.size() == 1) {
                    ans = min(ans, j - i);
                    break;
                }
            }
        }

        if(ans == INF) cout &lt;&lt; -1 &lt;&lt; endl;
        else cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2153 Mirror Cave]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/21/aoj2153-mirror-cave/"/>
    <updated>2016-05-21T02:18:25+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/21/aoj2153-mirror-cave</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2153">Mirror Cave | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>状態を<script type="math/tex">(ay, ax, by, bx)</script>として幅優先探索．このようにすれば，片方が移動して片方が壁で立ち止まる場合も表現出来る．左右を逆にするのが面倒だったので，まず最初にLenの方の部屋を反転して，同じ <script type="math/tex"> (dy, dx) </script>を使った．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int h, w;
int sax, say, sbx, sby, gax, gay, gbx, gby;
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1};
bool used[55][55][55][55];

bool can(int y, int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}

int main() {
    while(cin &gt;&gt; w &gt;&gt; h) {
        if(w == 0 &amp;&amp; h == 0) break;

        string A[h], B[h];
        rep(i, h) cin &gt;&gt; A[i] &gt;&gt; B[i];
        rep(i, h) reverse(B[i].begin(), B[i].end());

        rep(i, h) {
            rep(j, w) {
                if(A[i][j] == 'L') {
                    say = i;
                    sax = j;
                    A[i][j] = '.';
                }

                if(B[i][j] == 'R') {
                    sby = i;
                    sbx = j;
                    B[i][j] = '.';
                }

                if(A[i][j] == '%') {
                    gay = i;
                    gax = j;
                    A[i][j] = '.';
                }

                if(B[i][j] == '%') {
                    gby = i;
                    gbx = j;
                    B[i][j] = '.';
                }
            }
        }

        queue&lt;pair&lt; P, P &gt; &gt; que;
        que.push(mp( mp(say, sax), mp(sby, sbx) ));

        memset(used, 0, sizeof(used));
        used[say][sax][sby][sbx] = true;

        bool flag = false;

        while(que.size()) {
            pair&lt;P, P&gt; p = que.front(); que.pop();

            int ay = p.first.first, ax = p.first.second;
            int by = p.second.first, bx = p.second.second;

            if(ay == gay &amp;&amp; ax == gax &amp;&amp; by == gby &amp;&amp; bx == gbx) {
                flag = true;
                break;
            }

            if((ay == gay &amp;&amp; ax == gax) || (by == gby &amp;&amp; bx == gbx)) {
                continue;
            }

            rep(i, 4) {
                int nay = ay + dy[i];
                int nax = ax + dx[i];

                int nby = by + dy[i];
                int nbx = bx + dx[i];

                if(!can(nay, nax) || A[nay][nax] == '#') {
                    nay -= dy[i];
                    nax -= dx[i];
                }

                if(!can(nby, nbx) || B[nby][nbx] == '#') {
                    nby -= dy[i];
                    nbx -= dx[i];
                }

                if(!used[nay][nax][nby][nbx]) {
                    que.push(mp( mp(nay, nax), mp(nby, nbx) ));
                    used[nay][nax][nby][nbx] = true;
                }
            }
        }

        if(flag) {
            cout &lt;&lt; "Yes" &lt;&lt; endl;
        } else {
            cout &lt;&lt; "No" &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1175 And Then. How Many Any There?]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/21/and-then-how-many-any-there/"/>
    <updated>2016-05-21T01:35:44+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/21/and-then-how-many-any-there</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1175&lang=jp">And Then. How Many Are There? | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>別の円盤が上に無い状態の円盤は同じ色が偶数の場合は全部消し，奇数の場合は <script type="math/tex"> 1 </script>個消さないのを選ぶ，というやり方でやっていたが，消す順番によりそれより多く消せるパターンというのがありこれは間違いだった．<br/>
選ぶ順番によって消せる枚数が違ってくるので，各状態毎に <script type="math/tex"> (i, j) </script>を列挙して消せるかどうかを調べる． <script type="math/tex"> n </script>は最大で <script type="math/tex"> 4 * 6 = 24 </script>なので，状態数は <script type="math/tex"> 2 ^{24} </script>．intのbitでどの円盤を使ったかを管理した． <script type="math/tex"> O(2 ^n n ^2)  </script>．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;

struct P {
    int x, y, r, c;

    P() : x(0), y(0), r(0), c(0) {}
    P(int x, int y, int r, int c) : x(x), y(y), r(r), c(c) {}
};

int n, ans;
vector&lt;P&gt; v;
set&lt;int&gt; memo;

void dfs(int S) {
    if(memo.find(S) != memo.end()) return;
    memo.insert(S);

    ans = max(ans, __builtin_popcount(S));
    if(ans == n) return;

    bool up[50];
    memset(up, 0, sizeof(up));
    for(int i = n-1; i &gt;= 0; i--) {
        if(S &amp; (1&lt;&lt;i)) continue;

        bool flag = true;
        for(int j = i-1; j &gt;= 0; j--) {
            if(S &amp; (1&lt;&lt;j)) continue;
            int dist = (v[j].x - v[i].x) * (v[j].x - v[i].x) + (v[j].y - v[i].y) * (v[j].y - v[i].y);
            int len = (v[i].r + v[j].r) * (v[i].r + v[j].r);

            if(dist &lt; len) {
                flag = false;
            }
        }

        if(!flag) up[i] = true;
    }

    set&lt;int&gt; st[5];
    for(int i = n-1; i &gt;= 0; i--) {
        if((S &amp; (1&lt;&lt;i)) || up[i]) continue;

        bool flag = true;

        for(int j = i-1; j &gt;= 0; j--) {
            if((S &amp; (1&lt;&lt;j)) || up[j]) continue;

            int dist = (v[j].x - v[i].x) * (v[j].x - v[i].x) + (v[j].y - v[i].y) * (v[j].y - v[i].y);
            int len = (v[i].r + v[j].r) * (v[i].r + v[j].r);

            if(dist &gt;= len &amp;&amp; v[i].c == v[j].c) {
                dfs(S + (1&lt;&lt;i) + (1&lt;&lt;j));
            }
        }
    }
}

int main() {
    while(cin &gt;&gt; n &amp;&amp; n) {

        v.clear();
        memo.clear();

        rep(i, n) {
            int x, y, r, c;
            cin &gt;&gt; x &gt;&gt; y &gt;&gt; r &gt;&gt; c;
            v.push_back(P(x, y, r, c));
        }

        vector&lt;bool&gt; used(n);
        rep(i, n) used[i] = false;

        ans = 0;
        int S = 0;
        dfs(S);

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
