<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 数列 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/shu-lie/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-10T01:42:35+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM332 D1E CreatePairs]]></title>
    <link href="http://ry0u.github.io/blog/2016/12/04/srm332-d1e-createpairs/"/>
    <updated>2016-12-04T00:41:09+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/12/04/srm332-d1e-createpairs</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7309&rd=10012">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

数列が与えられる．各要素の中で$2$つ選びペアを作っても良い．ペアの場合は要素同士の積を取った後に，すべての(ペアを作っていないものも足して)和を最大化したい．

---

全てが正の数だった場合，大きいものから順番にペアを作っていけばよい．負の数がある場合，絶対値が大きいものから負の数同士でペアを作っていくのがよい．後はペアを作れない負の数があった場合，そのまま足してしまうと和の合計は下がってしまうので，もし$0$があれば，それで消す．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

class CreatePairs {
	public:
	int maximalSum(vector <int> data) {
		int cnt = 0;
		ll sum = 0;
		priority_queue<int> up;
		priority_queue<int, vector<int>, greater<int> > down;
		rep(i, data.size()) {
			if(data[i] == 0) cnt++;
			if(data[i] == 1) {
				sum++;
				continue;
			}

			if(data[i] < 0) down.push(data[i]);
			if(0 < data[i]) up.push(data[i]);
		}

		while(up.size()) {
			if(up.size() >= 2) {
				int a = up.top(); up.pop();
				int b = up.top(); up.pop();

				sum += a * b;
			} else {
				sum += up.top(); up.pop();
			}
		}

		while(down.size()) {
			if(down.size() >= 2) {
				int a = down.top(); down.pop();
				int b = down.top(); down.pop();

				sum += a * b;
			} else {
				int a = down.top(); down.pop();
				if(cnt) cnt--;
				else sum += a;
			}
		}

		return sum;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM327 D2M IQTest]]></title>
    <link href="http://ry0u.github.io/blog/2016/11/18/srm327-d2m-iqtest/"/>
    <updated>2016-11-18T23:41:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/11/18/srm327-d2m-iqtest</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6600&rd=10007">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

数列が与えられる．必ず$a \times x[i] + b = x[i+1]$となっている．この$a, b$が複数ある場合は$AMBIGUITY$，一つもない場合は$BUG$，唯一ある場合はその数列の次の値を返す．$a$を決め打ちすると，最初の二つから$b$が決まる．後はこの法則通りに並んでいるかを確かめる．要素が1個の場合のみ，この方法では出来ないので先にはじいておいた．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

class IQTest {

    public:

    string nextNumber(vector <int> previous) {

		vector<ll> v(previous.begin(), previous.end());

		if(v.size() == 1) return "AMBIGUITY";

		set<ll> st;

		REP(a, -100000, 100000) {
			ll b = v[1] - (v[0] * a);
			bool ch = true;

			rep(i, v.size()-1) {
				if(v[i] * a + b == v[i+1]) continue;
				ch = false;
			}

			if(ch) {
				st.insert(v[v.size()-1] * a + b);
			}
		}

		if(st.size() == 0) return "BUG";

		if(st.size() == 1) {
			stringstream ss;
			ss << *(st.begin());
			return ss.str();
		}

		return "AMBIGUITY";
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM321 D1M WeirdSort]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/27/srm321-d1m-weirdsort/"/>
    <updated>2016-10-27T10:56:46+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/27/srm321-d1m-weirdsort</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6755&rd=10001">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

与えられた数列$data$を全ての$i$に対して$data[i] + 1$$!=$$data[i+1]$が成り立つようにした場合の辞書順最小を答える．  
特に制限が無ければsortされたものが最小なので，その状態から制限を満たすように変形していく．最後に答えの数列に追加したものを$last$とする．新たに追加するものは$last+1$でない必要がある．またこの要素を追加してしまったために，最後に矛盾が起きるのを避けられない場合でない必要もある．矛盾が起きる場合とは，まだ答えの数列に追加していない中で，追加しようとしているものが最小値であり，最長値$+1$$==$最大値の関係にある場合である．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

class WeirdSort {
	public:
	vector <int> sortArray(vector <int> data) {
		int n = data.size();
		sort(data.begin(), data.end());

		int last = -100;
		vector<int> ans;
		bool used[55];
		memset(used, 0, sizeof(used));

		rep(t, n) {
			int front = -1, back = -1;
			rep(i, n) {
				if(used[i]) continue;
				front = data[i];
				break;
			}

			for(int i = n-1; i >= 0; i--) {
				if(used[i]) continue;
				back = data[i];
				break;
			}

			rep(i, n) {
				if(used[i]) continue;
				if(last + 1 == data[i]) continue;
				if(data[i] == front && front + 1 == back) continue;

				last = data[i];
				used[i] = true;
				ans.push_back(data[i]);
				break;
			}
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM314 D1E-D2M StandInLine]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/05/srm314-d1e-d2m-standinline/"/>
    <updated>2016-10-05T23:49:43+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/05/srm314-d1e-d2m-standinline</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6631&rd=9994">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$left[i]$は$i$より背の高い人の数である．これを満たす列を返す．小さい順に埋めていくと場所が一意に定まる．左から何番目($0-indexed$)の空いている場所に埋めるか，と考えた．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

class StandInLine {
	public:
	vector <int> reconstruct(vector <int> left) {
		int n = left.size();
		vector<int> ans(n, -1);

		rep(i, n) {
			int j = 0, cnt = 0;
			while(cnt != left[i]) {
				if(ans[j] == -1) {
					j++;
					cnt++;
				} else {
					j++;
				}
			}

			while(ans[j] != -1) {
				j++;
			}

			ans[j] = i + 1;
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces374-div2D Maxim and Array]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/04/codeforces374-div2d-maxim-and-array/"/>
    <updated>2016-10-04T01:10:44+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/04/codeforces374-div2d-maxim-and-array</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/problemset/problem/721/D">Problem - 721D - Codeforces</a></h4><p>Codeforces. Programming competitions and contests, programming community</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$i$番目の要素が$a_i$の数列が与えられる．$k$回, 要素に$+x$か$-x$することが出来る．$\prod a_i$を最小化する．マイナス要素が奇数個の時，要素の掛け算は符号がマイナスになるので，要素が$-$なら$-x$, 要素が$+$なら$+x$を小さい順にしていく．偶数個の時は，絶対値が最小の要素を異符号にして後は同じ．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<ll, ll> P;

struct abs_sort {
	bool operator()(P a, P b) const {
		if(abs(a.first) != abs(b.first)) return abs(a.first) > abs(b.first);
		if(a.first != b.first) return a.first > b.first;
		return a.second > b.second;
	}
};


int main() {
	int n, k; ll x;

	cin >> n >> k >> x;

	ll vmin = INF, vcnt = 0;
	vector<ll> v(n);
	rep(i, n) {
		cin >> v[i];
		vmin = min(vmin, v[i]);

		if(v[i] < 0) vcnt++;
	}

	priority_queue<P, vector<P>, abs_sort> Q;
	rep(i, n) {
		Q.push(mp(v[i], i));
	}

	if(vcnt % 2 == 0) {
		P top = Q.top(); Q.pop();

		ll cnt = (abs(top.first) + 1) / x;
		if((abs(top.first) + 1) % x != 0) cnt++;

		if(cnt <= k) {
			k -= cnt;
		} else {
			cnt = k;
			k = 0;
		}

		if(top.first >= 0) {
			top.first -= cnt * x;
		} else {
			top.first += cnt * x;
		}

		Q.push(top);
	}

	rep(i, k) {
		P p = Q.top(); Q.pop();
		if(p.first >= 0) {
			Q.push(mp(p.first + x, p.second));
		} else {
			Q.push(mp(p.first - x, p.second));
		}
	}

	vector<P> ans;
	while(Q.size()) {
		P p = Q.top(); Q.pop();
		ans.push_back(mp(p.second, p.first));
	}

	sort(ans.begin(), ans.end());
	rep(i, n) {
		if(i) cout << " ";
		cout << ans[i].second;
	}
	cout << endl;
	
	return 0;
}
```
]]></content>
  </entry>
  
</feed>
