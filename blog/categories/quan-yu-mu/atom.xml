<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 全域木 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/quan-yu-mu/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-05-31T15:00:25+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ1280 Slim Span]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/21/aoj1280-slim-span/"/>
    <updated>2016-05-21T02:41:52+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/21/aoj1280-slim-span</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1280">Slim Span</a></h4><p>Given an undirected weighted graph G, you should find one of spanning trees specified as follows. A spanning tree T is a tree (a connected subgraph without cycles) which connects all the n vertices with n - 1 edges.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>The <script type="math/tex"> slimness </script> of a spanning tree Tは全域木を構成する辺の最大値 <script type="math/tex"> - </script>最小値と定義される．この値の最小値を求める．<br/>
出来るだけコストが近いものを使った方が良いので，まず使うコストの一番小さいものを決めて，それからコストを増やしていく．全域木が構成出来た時点でのコストのminを取る． <script type="math/tex"> O(nm) </script>．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct UnionFind {
    vector&lt;int&gt; par,rank;
    int N;

    UnionFind(int n) {
        N = n;
        par.resize(n);
        rank.resize(n);

        rep(i,n) {
            par[i] = i;
            rank[i] = 0;
        }
    }

    int find(int x) {
        if(par[x] == x) return x;
        else return par[x] = find(par[x]);
    }

    void unite(int x,int y) {
        x = find(x);
        y = find(y);

        if(x == y) return;

        if(rank[x] &lt; rank[y]) {
            par[x] = y;
        }
        else {
            par[y] = x;
            if(rank[x] == rank[y]) rank[x]++;
        }
    }

    bool same(int x,int y) {
        return find(x) == find(y);
    }

    int size() {
        int cnt = 0;
        rep(i,N) if(find(i) == i) cnt++;
        return cnt;
    }
};

int main() {
    int n, m;

    while(cin &gt;&gt; n &gt;&gt; m) {
        if(n == 0 &amp;&amp; m == 0) break;

        vector&lt;int&gt; a(m), b(m), c(m);
        map&lt;int, vector&lt;P&gt; &gt; es;
        rep(i, m) {
            cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];
            a[i]--; b[i]--;

            es[c[i]].push_back(P(a[i], b[i]));
        }

        int ans = INF;

        REP(i, 1, 10001) {
            if(es[i].size() == 0) continue;
            UnionFind uf(n);
            REP(j, i, 10001) {
                if(es[j].size() == 0) continue;
                rep(k, es[j].size()) {
                    int a = es[j][k].first;
                    int b = es[j][k].second;

                    if(uf.same(a, b)) continue;
                    uf.unite(a, b);
                }

                if(uf.size() == 1) {
                    ans = min(ans, j - i);
                    break;
                }
            }
        }

        if(ans == INF) cout &lt;&lt; -1 &lt;&lt; endl;
        else cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
