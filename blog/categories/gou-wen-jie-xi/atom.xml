<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 構文解析 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/gou-wen-jie-xi/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-05-29T23:44:23+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ2401 Equation]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/20/aoj2401-equation/"/>
    <updated>2016-05-20T23:12:19+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/20/aoj2401-equation</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2401">Equation | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>最初に与えられる文を <script type="math/tex"> = </script>で分けて構文解析して最終的な値を比較する．前回の，構文解析と問題と同様にやる．新しい演算子"->&ldquo;があるが，今見ている文字と次に見る文字を見て，この演算子かどうかをチェックした．<br/>
等式が恒等式であるかどうか，は <script type="math/tex"> a \sim k </script>までの <script type="math/tex"> T/F </script>の状態を全列挙( <script type="math/tex"> 2 ^11通り </script>)し，それらの場合の値が全て一致しているかどうか，で判断した．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

vector&lt;string&gt; split(const string &amp;str, char delim) {
    vector&lt;string&gt; res;
    size_t current = 0, found;
    while((found = str.find_first_of(delim, current)) != string::npos) {
        res.push_back(string(str, current, found - current));
        current = found + 1;
    }
    res.push_back(string(str, current, str.size() - current));
    return res;
}

int formula(string&amp; s, int&amp; i) {
    if(s[i] == '(') {
        i++;
        int val = formula(s, i);

        char op = s[i];
        if(s[i] == '-' &amp;&amp; s[i+1] == '&gt;') {
            i++;
            op = s[i];
        }

        i++;
        int val2 = formula(s, i);

        int ret = 0;
        if(op == '+') {
            if(val || val2) ret = 1;
            else ret = 0;
        } else if(op == '*') {
            if(val &amp;&amp; val2) ret = 1;
            else ret = 0;
        } else if(op == '&gt;') {
            if(!val) ret = 1;
            else if(val2) ret = 1;
            else ret = 0;
        }

        i++;
        return ret;
    } else if(isdigit(s[i])) {
        int ret = s[i] - '0';
        i++;
        return ret;
    } else if(s[i] == '-') {
        i++;
        int ret = formula(s, i);

        if(ret == 0) return 1;
        else return 0;
    }
}

bool used[30];

int main() {
    string s;

    while(cin &gt;&gt; s) {
        if(s == "#") break;

        vector&lt;string&gt; ret = split(s, '=');
        string s1 = ret[0];
        string s2 = ret[1];

        bool flag = true;

        rep(i, 1&lt;&lt;11) {
            memset(used, 0, sizeof(used));
            rep(j, 11) {
                if(i &amp; (1&lt;&lt;j)) used[j] = true;
            }

            string t1 = s1, t2 = s2;
            rep(j, t1.size()) {
                if('a' &lt;= t1[j] &amp;&amp; t1[j] &lt;= 'k') {
                    if(used[t1[j] - 'a']) t1[j] = 'T';
                    else t1[j] = 'F';
                }

                if(t1[j] == 'T') t1[j] = '1';
                if(t1[j] == 'F') t1[j] = '0';
            }

            rep(j, t2.size()) {
                if('a' &lt;= t2[j] &amp;&amp; t2[j] &lt;= 'k') {
                    if(used[t2[j] - 'a']) t2[j] = 'T';
                    else t2[j] = 'F';
                }

                if(t2[j] == 'T') t2[j] = '1';
                if(t2[j] == 'F') t2[j] = '0';
            }

            int j = 0, k = 0;
            int f1 = formula(t1, j);
            int f2 = formula(t2, k);

            if(f1 == f2) continue;

            flag = false;
            break;
        }

        if(flag) cout &lt;&lt; "YES" &lt;&lt; endl;
        else cout &lt;&lt; "NO" &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1155 How can I satisfy thee? Let me count the ways...]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/20/how-can-i-satisfy-thee-let-me-count-the-ways-dot-dot-dot/"/>
    <updated>2016-05-20T22:38:10+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/20/how-can-i-satisfy-thee-let-me-count-the-ways-dot-dot-dot</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-image="http://judge.u-aizu.ac.jp/onlinejudge/IMAGE1/2008C2.png" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1155&lang=jp">How can I satisfy thee? Let me count the ways... | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>構文解析．
<script type="math/tex; mode=display">
\begin{eqnarray}
<formula>\ &amp;::=&amp;\ 0\ or\ 1\ or\ 2 \
<formula>\ &amp;::=&amp;\ -<formula> \
<formula>\ &amp;::=&amp;\ (<formula>\ +\ or\ * <formula>) \
\end{eqnarray}
</script>
の場合に分けて考える．入れ子の括弧にどう対応させるかよく分からなかったが，自分なりに理解することができた．構文解析の関数が出来たら，<script type="math/tex"> (P, Q, R) </script>の組み合わせ(<script type="math/tex"> 2 ^3 </script>通り)を全列挙して， <script type="math/tex"> 2 </script>となる個数を数える．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int formula(string&amp; s, int&amp; i) {
    if(s[i] == '(') {
        i++;
        int val = formula(s, i);

        char op = s[i];

        i++;
        int val2 = formula(s, i);

        int ret = 0;
        if(op == '+') {
            if(val == 2 || val2 == 2) ret = 2;
            else if(val == 1 || val2 == 1) ret = 1;
            else ret = 0;
        }
        if(op == '*') {
            if(val == 2 &amp;&amp; val2 == 2) ret = 2;
            else if((val == 1 || val == 2) &amp;&amp; (val2 == 1 || val2 == 2)) ret = 1;
            else ret = 0;
        }

        i++;
        return ret;
    } else if(isdigit(s[i])) {
        int ret = (s[i] - '0');
        i++;
        return ret;
    } else if(s[i] == '-') {
        i++;
        int val = formula(s, i);

        int ret = 0;
        if(val == 0) ret = 2;
        if(val == 1) ret = 1;
        if(val == 2) ret = 0;

        return ret;
    }
}


int main() {
    string s;
    while(cin &gt;&gt; s) {
        if(s == ".") break;

        int ans = 0;
        rep(i, 3) {
            rep(j, 3) {
                rep(k, 3) {
                    string t = s;
                    rep(l, s.size()) {
                        if(t[l] == 'P') t[l] = ('0' + i);
                        else if(t[l] == 'Q') t[l] = ('0' + j);
                        else if(t[l] == 'R') t[l] = ('0' + k);
                    }

                    int p = 0;
                    if(formula(t, p) == 2) {
                        ans++;
                    }
                }
            }
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
