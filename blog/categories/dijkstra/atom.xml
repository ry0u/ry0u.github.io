<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dijkstra | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/dijkstra/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-09-03T02:19:57+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM308 CornersGame]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/31/srm308-cornersgame/"/>
    <updated>2016-08-31T02:51:14+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/31/srm308-cornersgame</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6475&rd=9988">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$6 \times 6$の盤面が与えられて，右下の$2 \times 2$にはコインが置いてある．最終的に左上$2 \times 2$に移動させたい．コインの移動は$2$種類ある．

* 隣接したマスに障害物がなければ移動できる
* 隣接したマスが石かコインでそれをジャンプした先に障害物がなければ移動できる

もし移動出来なければ$-1$，そうでなければ最小の移動回数を返す．

---

読み飛ばしていて死んでいた．ジャンプできるのは石だけだと思っていて，最初のサンプルが$16$になる理由が全くわからなかった．問題文を読みなおすと$top\ left$かつ正方形ならなんでも良いのかと思って，それを全探索したりしていた．  
コインもジャンプ可能なので，順番に飛ばし飛ばしで行くとコストが少なくいける．(移動回数, 盤面)を状態として，移動回数が少ない順に見ていった．  
Sample0
{% img /images/SRM/308.gif %}

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;
typedef pair<int, vector<string> > IS;

int dy[4] = {1, 0, -1, 0};
int dx[4] = {0, 1, 0, -1};

bool can(int y, int x) {
	if(0 <= y && y < 6 && 0 <= x && x < 6) return true;
	return false;
}


class CornersGame {
	public:
	int countMoves(vector <string> board) {
		int n = 6;
		vector<string> s = board;
		s[n-2][n-2] = 'X';
		s[n-2][n-1] = 'X';
		s[n-1][n-2] = 'X';
		s[n-1][n-1] = 'X';

		set<vector<string> > st;
		priority_queue<IS, vector<IS>, greater<IS> > que;
		que.push(mp(0, s));

		while(que.size()) {
			IS is = que.top(); que.pop();
			int cnt = is.first;
			s = is.second;

			if(s[0][0] == 'X' && s[0][1] == 'X' && s[1][0] == 'X' && s[1][1] == 'X') {
				return cnt;
			}

			rep(i, n) {
				rep(j, 6) {
					if(s[i][j] != 'X') continue;

					rep(k, 4) {
						int y = i + dy[k];
						int x = j + dx[k];

						if(can(y, x) && s[y][x] == '.') {
							vector<string> t = s;
							swap(t[i][j], t[y][x]);
							if(st.find(t) == st.end()) {
								st.insert(t);
								que.push(mp(cnt + 1, t));
							}
						}

						int ny = y + dy[k];
						int nx = x + dx[k];

						if(can(y, x) && (s[y][x] == 's' || s[y][x] == 'X') && can(ny, nx) && s[ny][nx] == '.') {
							vector<string> t = s;
							swap(t[i][j], t[ny][nx]);
							if(st.find(t) == st.end()) {
								st.insert(t);
								que.push(mp(cnt + 1, t));
							}
						}
					}
				}
			}
		}

		return -1;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM305 D2H Cannibals]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/25/srm305-d2h-cannibals/"/>
    <updated>2016-08-25T13:22:20+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/25/srm305-d2h-cannibals</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6410&rd=9826">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

川渡り問題．宣教師と先住民の問題で，sample0がよく出るやつ．
http://www.umechando.com/playroom/04.htm
このページでsample0をやった．

---

状態を考えると，(本土の宣教師の人数, 本土の先住民の人数, 対岸の宣教師の人数, 対岸の先住民の人数, ボートがどっちにあるか)で，これを$memo[105][105][105][105][2]$で取るとMLE．宣教師は本土$+$対岸は必ず$M$，先住民も本土$+$対岸は必ず$C$となるので，本土だけをメモすれば対岸の人数も分かる．よって$memo[105][105][2]$で良い．後は各状態から船に乗って移動するのを遷移を全探索するdijkstraをした．宣教師より先住民の方が多い場合は遷移できないが，宣教師が$0$人の場合は出来ることに注意する(なかなかこれを書いていないことに気づかなかった)．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;
typedef pair<P, P> PP;

int memo[105][105][2];

struct State {
	int a, b, c, d, cost;
	bool flag;

	State(int a, int b, int c, int d, int cost, bool flag) : a(a), b(b), c(c), d(d), cost(cost), flag(flag) {}

	bool operator<(const State& s) const {
		return cost < s.cost;
    }
	bool operator>(const State& s) const {
		return cost > s.cost;
    }
};

ostream& operator << (ostream& os, const State& s) {
	os << "(" << s.a << ", " << s.b << " | " << s.c << ", " << s.d << ") : " << s.cost << " flag:" << s.flag;
	return os;
}

bool ok(State s) {
	int a = s.a, b = s.b, c = s.c, d = s.d;
	bool f1 = false;
	if(a == 0 || b == 0) f1 = true;
	if(a >= b) f1 = true;

	bool f2 = false;
	if(c == 0 || d == 0) f2 = true;
	if(c >= d) f2 = true;

	return (f1 && f2);
}

class Cannibals {
	public:
	int minCrossings(int M, int C, int R) {
		memset(memo, -1, sizeof(memo));


		priority_queue<State, vector<State>, greater<State> > que;
		que.push(State(M, C, 0, 0, 0, 0));
		memo[M][C][0] = 0;

		while(que.size()) {
			State s = que.top(); que.pop();

			if(s.flag == 0) {
				rep(i, s.a + 1) {
					rep(j, s.b + 1) {
						if(i == 0 && j == 0) continue;
						if(i + j > R) continue;
						if(i != 0 && j != 0 && i < j) continue;

						int a = s.a - i;
						int b = s.b - j;


						State nc(a, b, s.c + i, s.d + j, s.cost + 1, 1);

						if(ok(nc) && memo[nc.a][nc.b][nc.flag] == -1) {
							memo[nc.a][nc.b][nc.flag] = nc.cost;
							que.push(nc);
						}
					}
				}
			} else {
				rep(i, s.c + 1) {
					rep(j, s.d + 1) {
						if(i == 0 && j == 0) continue;
						if(i + j > R) continue;
						if(i != 0 && j != 0 && i < j) continue;

						int c = s.c - i;
						int d = s.d - j;

						State nc(s.a + i, s.b + j, c, d, s.cost + 1, 0);

						if(ok(nc) && memo[nc.a][nc.b][nc.flag] == -1) {
							memo[nc.a][nc.b][nc.flag] = nc.cost;
							que.push(nc);
						}
					}
				}
			}
		}

		return memo[0][0][1];
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2151 Brave Princess Revisited]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/09/aoj2151-brave-princess-revisited/"/>
    <updated>2016-06-09T13:59:08+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/09/aoj2151-brave-princess-revisited</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151">Brave Princess Revisited | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

状態を(襲われる盗賊や刺客の人数, お金, 頂点番号)としてdijkstra．現在の状態から次の状態への遷移は，護衛を雇わないで盗賊に襲われる，護衛を雇い守ってもらう，の$2$つである．お金が辺の長さより少ない場合は護衛を雇えないことに注意する．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;
typedef pair<P, int> PI;

struct edge {
	int from,to;
	int cost, res;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int t,int c,int r) : to(t), cost(c), res(r) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

vector<edge> G[105];
int d[105][105];

void dijkstra(int s, int l) {
	rep(i, 105) rep(j, 105) d[i][j] = INF;
	d[s][l] = 0;

	priority_queue<PI, vector<PI>, greater<PI> > que;
	que.push(mp(mp(0, -l), s));

	while(que.size()) {
		PI p = que.top(); que.pop();
		int cost = p.first.first;
		int coin = p.first.second;
		int v = p.second;
		coin *= -1;

		if(d[v][coin] < cost) continue;
		
		rep(i, G[v].size()) {
			edge e = G[v][i];

			if(d[e.to][coin] > d[v][coin] + e.res) {
				d[e.to][coin] = d[v][coin] + e.res;
				que.push(mp(mp(d[e.to][coin], -coin), e.to));
			}

			int nc = coin - e.cost;
			if(nc >= 0 && d[e.to][nc] > d[v][coin]) {
				d[e.to][nc] = d[v][coin];
				que.push(mp(mp(d[e.to][nc], -nc), e.to));
			}
		}

	}
}

int main() {
	int n, m, l;
	while(cin >> n >> m >> l)  {
		if(n == 0 && m == 0 && l == 0) break;

		rep(i, 105) G[i].clear();

		rep(i, m) {
			int a, b, c, d;
			cin >> a >> b >> c >> d;

			a--; b--;

			G[a].push_back(edge(b, c, d));
			G[b].push_back(edge(a, c, d));
		}

		dijkstra(0, l);

		int ans = INF;
		rep(i, l+1) {
			ans = min(ans, d[n-1][i]);
		}

		cout << ans << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2608 Minus One]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/06/aoj2608-minus-one/"/>
    <updated>2016-06-06T23:24:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/06/aoj2608-minus-one</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2608">Minus One | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$G$に$e$を付け加えて無向グラフにおける$s$から$t$への最短路の長さより$1$だけ大きいものの個数を答える．これはつまり，パスを貼った時に最短経路長が$1$小さくなるものである．  
  
$s$からの最短経路長を$d[i]$，$t$からの最短経路長を$d2[i]$とする．点$a$と点$b$を結んだ場合，$s \to a \to b \to t$という経路を行くとすると，コストは$d[a] + 1 + d2[b]$となる．この時$s \to t$の最短経路長$+1$となる経路は，
$$
\begin{eqnarray}
	d[t] - 1 &=& d[a] + 1 + d2[b] \\\\
	d2[b] &=& d[t] - 2 - d[a]
\end{eqnarray}
$$
が条件となる．愚直に$a, b$のペアを列挙して確認すると$O(n ^2)$で間に合わないが，点$a$を決めた時に，経路長$1$少なくなる$b$の選び方は$d[t] - 2 - d[a]$となる$d2[i]$の個数と決まるので，先に$d2[i]$をカウントしておくと$O(n)$で求められる．最短経路を求めるのが一番時間がかかるので全体で$O(n logn)$．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

struct edge {
	int from,to;
	int cost;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int f,int t,int c) : from(f),to(t),cost(c) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

vector<edge> G[100005];
int d[100005], d2[100005], cnt[100005];

void dijkstra(int s) {
	priority_queue<P, vector<P>, greater<P> > que;
	rep(i, 100005) d[i] = INF;
	
	que.push(mp(0, s));
	d[s] = 0;

	while(que.size()) {
		P p = que.top(); que.pop();
		int cost = p.first;
		int v = p.second;

		if(d[v] < cost) continue;

		rep(i, G[v].size()) {
			edge e = G[v][i];
			if(d[e.to] > d[v] + e.cost) {
				d[e.to] = d[v] + e.cost;
				que.push(mp(d[e.to], e.to));
			}
		}
	}
}

int main() {
	int n, m;
	cin >> n >> m;

	int s, t;
	cin >> s >> t;
	s--; t--;

	rep(i, m) {
		int a, b;
		cin >> a >> b;
		a--; b--;

		G[a].push_back(edge(b, 1));
		G[b].push_back(edge(a, 1));
	}

	dijkstra(s);
	rep(i, n) d2[i] = d[i];

	dijkstra(t);
	rep(i, n) swap(d[i], d2[i]);

	memset(cnt, 0, sizeof(cnt));
	rep(i, n) {
		if(d2[i] == INF) continue;
		cnt[d2[i]]++;
	}

	ll ans = 0;
	rep(i, n) {
		if(d[i] == INF || d2[i] == INF) continue;
		int x = d[t] - 2 - d[i];

		if(x >= 0) {
			ans += cnt[x];
		}
	}

	cout << ans << endl;

	return 0;
}
```

経路復元とか色々していて，色々考えた後に書き直したら非常にスッキリして面白いと思った．但し解くのに時間がかかりすぎている...
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1505 Dungeon]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/21/aoj1505-dungeon/"/>
    <updated>2016-04-21T14:26:13+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/21/aoj1505-dungeon</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1505">Dungeon | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

まず最初dijkstraの始点を {% m %} 0, n-1 {% em %}としてスタート地点からの最短経路と，ゴール地点からの最短経路を出しておく．これで各クエリに対して{% m %} O(n) {% em %}で答えられるようになったが， {% m %}1 \leq n \leq 10 ^5, 1 \leq q \leq 10 ^5{% em %}なので間に合わない．  
(スタート地点からの最短コスト, 頂点番号)のpairで，(ゴール地点からの最短コスト, 頂点番号)のpairでsortする．また頂点番号がsort後の配列のどこのindexかを持っておく．  

スタート地点からのコスト  

|index|0|1|2|3|
|:-:|:-:|:-:|:-:|:-:|
|cost|0|2|3|3|
|頂点|0|2|1|3|

ゴール地点からのコスト  

|index|0|1|2|3|
|:-:|:-:|:-:|:-:|:-:|
|cost|0|1|3|4|
|頂点|3|2|0|1|

スタート地点に関して頂点番号 {% m %} _i {% em %}のsort後の配列のindexの変換テーブル  

|頂点|0|1|2|3|
|:-:|:-:|:-:|:-:|:-:|
|index|0|2|1|3|

次にクエリ {% m %} q_i {% em %}の {% m %} (fg, fs, クエリ番号) {% em %}でsortする． 少なくとも{% m %} fg {% em %}かかる，という制限なので{% m %} fg {% em %}を優先してsortすれば，それ以前のものは候補に上がらないので，省いて良い．この省くというのを表現するのにBITを用いた．{% m %} fg {% em %}より小さい所は変換テーブルを用いてそのindexに {% m %} +1 {% em %}する．次に {% m %} fs {% em %}以下を満たす最大のindex持ってきてBITを用いてその区間和を引く．  

説明が全く出来ている気がしない．後で見直し

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1LL<<61
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

struct edge {
	int from,to;
	ll cost;

	edge(int t,ll c) : to(t),cost(c) {}
	edge(int f,int t,ll c) : from(f),to(t),cost(c) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

vector<edge> G[100005];
ll d[100005], d2[100005];

void dijkstra(int s, int n) {
	priority_queue<pair<ll, ll> , vector<pair<ll, ll> >, greater<pair<ll, ll> > > que;
	fill(d, d+n, INF);

	d[s] = 0;
	que.push(P(0,s));

	while(que.size()) {
		P p = que.top();
		que.pop();

		int v = p.second;
		if(d[v] < p.first) continue;

		rep(i, G[v].size()) {
			edge e = G[v][i];
			if(d[e.to] > d[v] + e.cost) {
				d[e.to] = d[v] + e.cost;
				que.push(P(d[e.to],e.to));
			}
		}
	}
}

struct BIT {
	vector<int> bit;

	BIT(int n) : bit(n+1) {}

	int sum(int i) {
		int s = 0;
		while(i > 0) {
			s += bit[i];
			i -= i & -i;
		}
		return s;
	}

	void add(int i,int x) {
		while(i <= bit.size()) {
			bit[i] += x;
			i += i & -i;
		}
	}
};

int main() {
	int n, m;
	cin >> n >> m;

	rep(i, m) {
		ll a, b, c;
		cin >> a >> b >> c;

		G[a].push_back(edge(b, c));
		G[b].push_back(edge(a, c));
	}

	dijkstra(n-1, n);
	memset(d2, 0, sizeof(d2));
	rep(i, n) {
		d2[i] = d[i];
	}

	dijkstra(0, n);

	vector<ll> d3(n);
	vector<pair<ll, int> > D, D2;
	rep(i, n) {
		d3[i] = d[i];
		D.push_back(mp(d[i], i));
		D2.push_back(mp(d2[i], i));
	}

	sort(d3.begin(), d3.end());
	sort(D.begin(), D.end());
	sort(D2.begin(), D2.end());

	map<int, int> ma;
	rep(i, n) {
		ma[ D[i].second ] = i;
	}

	int q;
	cin >> q;

	vector<pair<pair<ll, ll> , int> > query(q);

	rep(i, q) {
		ll s, g;
		cin >> s >> g;

		query[i] = mp(mp(g, s), i);
	}

	sort(query.begin(), query.end());

	BIT bit(n + 5);
	vector<P> ans;
	int start = 0;
	rep(i, q) {
		ll s = query[i].first.second;
		ll g = query[i].first.first;
		int id = query[i].second;

		for(; start < n; start++) {
			if(g > D2[start].first) {
				int k = ma[ D2[start].second ];
				bit.add(k + 1, 1);
				continue;
			} else break;
		}

		vector<ll>::iterator ite = upper_bound(d3.begin(), d3.end(), s);
		int k = ite - d3.begin() - 1;
		if(k < 0) {
			ans.push_back(mp( id, 0));
		} else {
			int res = k + 1;
			res -= bit.sum(k + 1);
			ans.push_back(mp( id, res));
		}
	}

	sort(ans.begin(), ans.end());

	rep(i, ans.size()) {
		cout << ans[i].second << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
</feed>
