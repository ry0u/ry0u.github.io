<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dijkstra | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/dijkstra/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-05-26T10:36:09+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ1505 Dungeon]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/21/aoj1505-dungeon/"/>
    <updated>2016-04-21T14:26:13+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/21/aoj1505-dungeon</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1505">Dungeon | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>まず最初dijkstraの始点を {% m %} 0, n-1 {% em %}としてスタート地点からの最短経路と，ゴール地点からの最短経路を出しておく．これで各クエリに対して{% m %} O(n) {% em %}で答えられるようになったが， {% m %}1 \leq n \leq 10 ^5, 1 \leq q \leq 10 ^5{% em %}なので間に合わない．<br/>
(スタート地点からの最短コスト, 頂点番号)のpairで，(ゴール地点からの最短コスト, 頂点番号)のpairでsortする．また頂点番号がsort後の配列のどこのindexかを持っておく．</p>

<p>スタート地点からのコスト</p>

<table>
<thead>
<tr>
<th style="text-align:center;">index</th>
<th style="text-align:center;">0</th>
<th style="text-align:center;">1</th>
<th style="text-align:center;">2</th>
<th style="text-align:center;">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">cost</td>
<td style="text-align:center;">0</td>
<td style="text-align:center;">2</td>
<td style="text-align:center;">3</td>
<td style="text-align:center;">3</td>
</tr>
<tr>
<td style="text-align:center;">頂点</td>
<td style="text-align:center;">0</td>
<td style="text-align:center;">2</td>
<td style="text-align:center;">1</td>
<td style="text-align:center;">3</td>
</tr>
</tbody>
</table>


<p>ゴール地点からのコスト</p>

<table>
<thead>
<tr>
<th style="text-align:center;">index</th>
<th style="text-align:center;">0</th>
<th style="text-align:center;">1</th>
<th style="text-align:center;">2</th>
<th style="text-align:center;">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">cost</td>
<td style="text-align:center;">0</td>
<td style="text-align:center;">1</td>
<td style="text-align:center;">3</td>
<td style="text-align:center;">4</td>
</tr>
<tr>
<td style="text-align:center;">頂点</td>
<td style="text-align:center;">3</td>
<td style="text-align:center;">2</td>
<td style="text-align:center;">0</td>
<td style="text-align:center;">1</td>
</tr>
</tbody>
</table>


<p>スタート地点に関して頂点番号 {% m %} _i {% em %}のsort後の配列のindexの変換テーブル</p>

<table>
<thead>
<tr>
<th style="text-align:center;">頂点</th>
<th style="text-align:center;">0</th>
<th style="text-align:center;">1</th>
<th style="text-align:center;">2</th>
<th style="text-align:center;">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">index</td>
<td style="text-align:center;">0</td>
<td style="text-align:center;">2</td>
<td style="text-align:center;">1</td>
<td style="text-align:center;">3</td>
</tr>
</tbody>
</table>


<p>次にクエリ {% m %} q_i {% em %}の {% m %} (fg, fs, クエリ番号) {% em %}でsortする． 少なくとも{% m %} fg {% em %}かかる，という制限なので{% m %} fg {% em %}を優先してsortすれば，それ以前のものは候補に上がらないので，省いて良い．この省くというのを表現するのにBITを用いた．{% m %} fg {% em %}より小さい所は変換テーブルを用いてそのindexに {% m %} +1 {% em %}する．次に {% m %} fs {% em %}以下を満たす最大のindex持ってきてBITを用いてその区間和を引く．</p>

<p>説明が全く出来ている気がしない．後で見直し</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1LL&lt;&lt;61
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct edge {
    int from,to;
    ll cost;

    edge(int t,ll c) : to(t),cost(c) {}
    edge(int f,int t,ll c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[100005];
ll d[100005], d2[100005];

void dijkstra(int s, int n) {
    priority_queue&lt;pair&lt;ll, ll&gt; , vector&lt;pair&lt;ll, ll&gt; &gt;, greater&lt;pair&lt;ll, ll&gt; &gt; &gt; que;
    fill(d, d+n, INF);

    d[s] = 0;
    que.push(P(0,s));

    while(que.size()) {
        P p = que.top();
        que.pop();

        int v = p.second;
        if(d[v] &lt; p.first) continue;

        rep(i, G[v].size()) {
            edge e = G[v][i];
            if(d[e.to] &gt; d[v] + e.cost) {
                d[e.to] = d[v] + e.cost;
                que.push(P(d[e.to],e.to));
            }
        }
    }
}

struct BIT {
    vector&lt;int&gt; bit;

    BIT(int n) : bit(n+1) {}

    int sum(int i) {
        int s = 0;
        while(i &gt; 0) {
            s += bit[i];
            i -= i &amp; -i;
        }
        return s;
    }

    void add(int i,int x) {
        while(i &lt;= bit.size()) {
            bit[i] += x;
            i += i &amp; -i;
        }
    }
};

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    rep(i, m) {
        ll a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;

        G[a].push_back(edge(b, c));
        G[b].push_back(edge(a, c));
    }

    dijkstra(n-1, n);
    memset(d2, 0, sizeof(d2));
    rep(i, n) {
        d2[i] = d[i];
    }

    dijkstra(0, n);

    vector&lt;ll&gt; d3(n);
    vector&lt;pair&lt;ll, int&gt; &gt; D, D2;
    rep(i, n) {
        d3[i] = d[i];
        D.push_back(mp(d[i], i));
        D2.push_back(mp(d2[i], i));
    }

    sort(d3.begin(), d3.end());
    sort(D.begin(), D.end());
    sort(D2.begin(), D2.end());

    map&lt;int, int&gt; ma;
    rep(i, n) {
        ma[ D[i].second ] = i;
    }

    int q;
    cin &gt;&gt; q;

    vector&lt;pair&lt;pair&lt;ll, ll&gt; , int&gt; &gt; query(q);

    rep(i, q) {
        ll s, g;
        cin &gt;&gt; s &gt;&gt; g;

        query[i] = mp(mp(g, s), i);
    }

    sort(query.begin(), query.end());

    BIT bit(n + 5);
    vector&lt;P&gt; ans;
    int start = 0;
    rep(i, q) {
        ll s = query[i].first.second;
        ll g = query[i].first.first;
        int id = query[i].second;

        for(; start &lt; n; start++) {
            if(g &gt; D2[start].first) {
                int k = ma[ D2[start].second ];
                bit.add(k + 1, 1);
                continue;
            } else break;
        }

        vector&lt;ll&gt;::iterator ite = upper_bound(d3.begin(), d3.end(), s);
        int k = ite - d3.begin() - 1;
        if(k &lt; 0) {
            ans.push_back(mp( id, 0));
        } else {
            int res = k + 1;
            res -= bit.sum(k + 1);
            ans.push_back(mp( id, res));
        }
    }

    sort(ans.begin(), ans.end());

    rep(i, ans.size()) {
        cout &lt;&lt; ans[i].second &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC012D バスと割けられない運命]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/03/abc012d-basutoge-kerarenaiyun-ming/"/>
    <updated>2016-04-03T17:27:51+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/03/abc012d-basutoge-kerarenaiyun-ming</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://abc012.contest.atcoder.jp/tasks/abc012_4">D: バスと避けられない運命 - AtCoder Beginner Contest 012 | AtCoder</a></h4><p>(null)</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>バス停の数{% m %} N {% em %}が {% m %} 1 \leq N \leq 300 {% em %}と小さいので，愚直にそこを始点とした最短経路を求め，最大値の最小値を取った． {% m %} O(N ^2) {% em %}．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1LL&lt;&lt;60
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct edge {
    int from,to;
    ll cost;

    edge(int t, ll c) : to(t),cost(c) {}
    edge(int f, int t, ll c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[305];
ll d[305];

void dijkstra(int s, int n) {
    priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que;
    fill(d, d+n, INF);

    d[s] = 0;
    que.push(P(0,s));

    while(que.size()) {
        P p = que.top();
        que.pop();

        int v = p.second;
        if(d[v] &lt; p.first) continue;

        rep(i, G[v].size()) {
            edge e = G[v][i];
            if(d[e.to] &gt; d[v] + e.cost) {
                d[e.to] = d[v] + e.cost;
                que.push(P(d[e.to],e.to));
            }
        }
    }
}


int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    rep(i, m) {
        ll s, t, c;
        cin &gt;&gt; s &gt;&gt; t &gt;&gt; c;
        s--; t--;

        G[s].push_back(edge(t, c));
        G[t].push_back(edge(s, c));
    }

    ll ans = INF;
    rep(i, n) {
        dijkstra(i, n);
        ll res = 0;
        rep(j, n) {
            res = max(res, d[j]);
        }

        ans = min(ans, res);
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2021 Princess in Danger]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/23/aoj2021-princess-in-danger/"/>
    <updated>2016-03-23T19:48:34+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/23/aoj2021-princess-in-danger</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2021">Princess in Danger | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>状態を {% m %} (cost, 残り時間, 番号) {% em %}としてdijkstra．現在の状態の残り時間のほうが辺のコストより大きい時に，次の町に行くことが可能．冷凍施設にいるときは， 現在の残り時間から{% m %} M {% em %}まで回復出来るので {% m %} 1 {% em %}分ずつ試す．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;
typedef pair&lt;P, int&gt; PI;
typedef pair&lt;P, P &gt; PP;

struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

int n, m, l, k, a, h;
vector&lt;edge&gt; G[105];
int d[105][105];
bool L[105];

void dijkstra(int s) {
    priority_queue&lt;PI, vector&lt;PI&gt;, greater&lt;PI&gt; &gt; que;
    rep(i, 105) {
        rep(j, 105) {
            d[i][j] = INF;
        }
    }

    d[s][m] = 0;
    que.push(PI(P(0, m), s));

    while(que.size()) {
        PI p = que.top();
        que.pop();

        int cost = p.first.first;
        int t = p.first.second;
        int v = p.second;
        if(d[v][t] &lt; cost) continue;

        if(L[v]) {
            REP(i, t+1, m+1) {
                if(d[v][i] &gt; d[v][t] + (i - t)) {
                    d[v][i] = d[v][t] + (i - t);
                    que.push(PI(P(d[v][i], i), v) );
                }
            }
        }

        rep(i, G[v].size()) {
            edge e = G[v][i];
            int nt = t - e.cost;
            if(nt &gt;= 0 &amp;&amp; d[e.to][nt] &gt; d[v][t] + e.cost) {
                d[e.to][nt] = d[v][t] + e.cost;
                que.push(PI(P(d[e.to][nt], nt), e.to));
            }
        }
    }
}


int main() {
    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; k &gt;&gt; a &gt;&gt; h) {
        if(n == 0 &amp;&amp; m == 0 &amp;&amp; l == 0 &amp;&amp; k == 0 &amp;&amp; a == 0 &amp;&amp; h == 0) break;

        rep(i, 105) G[i].clear();
        memset(L, 0, sizeof(L));

        rep(i, l) {
            int x;
            cin &gt;&gt; x;
            L[x] = true;
        }

        rep(i, k) {
            int s, t, c;
            cin &gt;&gt; s &gt;&gt; t &gt;&gt; c;
            G[s].push_back(edge(t, c));
            G[t].push_back(edge(s, c));
        }

        dijkstra(a);

        int ans = INF;
        rep(i, m + 1) {
            ans = min(ans, d[h][i]);
        }

        if(ans == INF) cout &lt;&lt; "Help!" &lt;&lt; endl;
        else cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2620 Trodden Cable]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj2620-trodden-cable/"/>
    <updated>2016-03-22T21:52:44+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj2620-trodden-cable</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2620">Trodden Cable</a></h4><p>Nathan O. Davis is running a company. His company owns a web service which has a lot of users. So his office is full of servers, routers and messy LAN cables. He is now very puzzling over the messy cables, because they are causing many kinds of problems. For example, staff working at the company often trip over a cable.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>全く分からずに調べた．</p>

<p><a href="http://acm-icpc.aitea.net/index.php?plugin=attach&amp;refer=2013%2FPractice%2F%E5%A4%8F%E5%90%88%E5%AE%BF%2F%E8%AC%9B%E8%A9%95&amp;openfile=trodden_cable.pdf:image=http://acm-icpc.aitea.net/index.php?plugin=attach&amp;refer=2013%2FPractice%2F%E5%A4%8F%E5%90%88%E5%AE%BF%2F%E8%AC%9B%E8%A9%95&amp;openfile=trodden_cable.pdf">http://acm-icpc.aitea.net/index.php?plugin=attach&amp;refer=2013%2FPractice%2F%E5%A4%8F%E5%90%88%E5%AE%BF%2F%E8%AC%9B%E8%A9%95&amp;openfile=trodden_cable.pdf:image=http://acm-icpc.aitea.net/index.php?plugin=attach&amp;refer=2013%2FPractice%2F%E5%A4%8F%E5%90%88%E5%AE%BF%2F%E8%AC%9B%E8%A9%95&amp;openfile=trodden_cable.pdf</a></p>

<p>この画像が非常に分かりやすい．移動する時にまたがる線のコストを{% m %} +1 {% em %}して，移動が終わったグリッドグラフでdijkstra．</p>

<p>現在位置を(y, x)と置くと</p>

<ul>
<li>{% m %} R {% em %}の時， {% m %} (y, x+1) \to (y+1, x+1) {% em %}</li>
<li>{% m %} L {% em %}の時， {% m %} (y, x) \to (y+1, x) {% em %}</li>
<li>{% m %} U {% em %}の時， {% m %} (y, x) \to (y, x+1) {% em %}</li>
<li>{% m %} D {% em %}の時， {% m %} (y+1, x) \to (y+1, x+1) {% em %}</li>
</ul>


<p>に {% m %} +1 {% em %}した．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int w, h, n;
int sx,sy,gx,gy;
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1};

bool can(int y, int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}

struct edge {
    int from,to;
    ll cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[505*505 + 5];
ll d[505 * 505 + 5];

void dijkstra(int s, int n) {
    priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que;
    fill(d, d+n, INF);

    d[s] = 0;
    que.push(P(0,s));

    while(que.size()) {
        P p = que.top();
        que.pop();

        int v = p.second;
        if(d[v] &lt; p.first) continue;

        rep(i, G[v].size()) {
            edge e = G[v][i];
            if(d[e.to] &gt; d[v] + e.cost) {
                d[e.to] = d[v] + e.cost;
                que.push(P(d[e.to],e.to));
            }
        }
    }
}

int main() {
    cin &gt;&gt; w &gt;&gt; h &gt;&gt; n;

    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; gx &gt;&gt; gy;

    rep(i, h * w) {
        G[i].clear();
    }

    w++;
    h++;

    rep(i, h) {
        rep(j, w) {
            rep(k, 4) {
                int y = i + dy[k];
                int x = j + dx[k];

                if(can(y, x)) {
                    G[i*w + j].push_back(edge(y*w + x, 0));
                }
            }
        }
    }

    rep(i, n) {
        int y, x, t;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; t;

        string s;
        cin &gt;&gt; s;

        rep(k, t) {
            rep(j, s.size()) {
                int from = -1, to = -1;
                if(s[j] == 'R' &amp;&amp; x + 1 &lt; w - 1) {
                    from = y * w + (x + 1);
                    to = (y + 1) * w + (x + 1);
                    x++;
                } else if(s[j] == 'L' &amp;&amp; 0 &lt;= x - 1) {
                    from = y * w + x;
                    to = (y + 1) * w + x;
                    x--;
                } else if(s[j] == 'U' &amp;&amp; 0 &lt;= y - 1) {
                    from = y * w + x;
                    to = y * w + (x + 1);
                    y--;
                } else if(s[j] == 'D' &amp;&amp; y + 1 &lt; h - 1) {
                    from = (y + 1) * w + x;
                    to = (y + 1) * w + (x + 1);
                    y++;
                }

                if(from == -1 &amp;&amp; to == -1) continue;
                rep(k, G[from].size()) {
                    if(G[from][k].to == to) {
                        G[from][k].cost++;
                    }
                }
                rep(k, G[to].size()) {
                    if(G[to][k].to == from) {
                        G[to][k].cost++;
                    }
                }
            }
        }
    }

    // rep(i, h) {
    //  rep(j, w) {
    //      cout &lt;&lt; " --------- " &lt;&lt; i &lt;&lt; ", " &lt;&lt; j &lt;&lt; " :" &lt;&lt; i * w + j &lt;&lt; " |";
    //      rep(k, G[i*w + j].size()) {
    //          cout &lt;&lt; "(" &lt;&lt; G[i*w + j][k].to &lt;&lt; ", " &lt;&lt; G[i*w + j][k].cost &lt;&lt; ") ";
    //      }
    //      cout &lt;&lt; endl;
    //  }
    // }

    dijkstra(sy * w + sx, h * w);

    // rep(i, h) {
    //  rep(j, w) {
    //      cout &lt;&lt; d[i*w + j] &lt;&lt; " ";
    //  }
    //  cout &lt;&lt; endl;
    // }

    cout &lt;&lt; d[gy * w + gx] &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0616 JOI Park]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj0616-joi-park/"/>
    <updated>2016-03-18T16:24:27+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj0616-joi-park</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0616">JOI Park | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>まず，{% m %} 広場0 {% em %}からの各広場までの最短経路を求める．次に，コストが小さい順にソートし，その場所への到達コストを仮の{% m %} X {% em %}と置き，整備する場所とする．整備される場所同士は，地下道を通して行き来できるためそのコストを全体から引く．始点を到達コスト{% m %} 0 {% em %}の広場と見れば整備しない場合も考慮される．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1LL&lt;&lt;60
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[100005];
ll d[100005];
bool used[100005];

void dijkstra(int s,int n) {
    priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; que;
    fill(d,d+n,INF);

    d[s] = 0;
    que.push(P(0,s));

    while(que.size()) {
        P p = que.top();
        que.pop();

        int v = p.second;
        if(d[v] &lt; p.first) continue;

        rep(i,G[v].size()) {
            edge e = G[v][i];
            if(d[e.to] &gt; d[v] + e.cost) {
                d[e.to] = d[v] + e.cost;
                que.push(P(d[e.to],e.to));
            }
        }
    }
}

int main() {
    int n, m, c;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;

    ll sum = 0;
    rep(i, m) {
        int a, b, d;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;

        a--;
        b--;
        sum += d;

        G[a].push_back(edge(b, d));
        G[b].push_back(edge(a, d));
    }

    dijkstra(0, n);

    vector&lt;pair&lt;ll, int&gt; &gt; v(n);
    rep(i, n) {
        v[i].first = d[i];
        v[i].second = i;
    }

    sort(v.begin(), v.end());
    memset(used, 0, sizeof(used));

    ll ans = INF;
    rep(i, v.size()) {
        int j = v[i].second;
        used[j] = true;

        rep(k, G[j].size()) {
            if(used[G[j][k].to]) {
                sum -= G[j][k].cost;
            }
        }

        ans = min(ans, d[j] * c + sum);
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
