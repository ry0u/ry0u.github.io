<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dijkstra | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/dijkstra/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-12-01T23:52:11+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[codeforces374-div2C Journey]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/03/codeforces374-div2c-journey/"/>
    <updated>2016-10-03T01:06:37+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/03/codeforces374-div2c-journey</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/721/problem/C">Problem - C - Codeforces</a></h4><p>Codeforces. Programming competitions and contests, programming community</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

町$u$から町$v$に行くには$t$かかる．$T$までに最大でいくつの町を回ることが出来るか．状態を($i$番目の町, $j$個既に町を訪れた)としてdijkstra．最短時間を求めているので，既に訪れた町が重複することはない．costが$T$を超える場合は遷移させない．後は経路復元して出力した．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;
typedef pair<ll, P> IP;

struct edge {
	int from,to;
	int cost;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int f,int t,int c) : from(f),to(t),cost(c) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

int n, m;
vector<edge> G[5005];
ll t;
int d[5005][5005], prev[5005][5005];

void dijkstra(int s, int n) {
	priority_queue<IP, vector<IP>, greater<IP> > que;

	rep(i, 5005) rep(j, 5005) {
		d[i][j] = INF;
		prev[i][j] = -1;
	}
	
	d[s][1] = 0;

	que.push(mp(0, mp(s, 1)));
	
	while(que.size()) {
		IP p = que.top(); que.pop();

		int cos = p.first;
		int v = p.second.first;
		int cnt = p.second.second;
		if(d[v][cnt] < cos) continue;
	
		rep(i, G[v].size()) {
			edge e = G[v][i];
			ll nc = ll(d[v][cnt]) + ll(e.cost);
			if(nc > t) continue;

			if(d[e.to][cnt+1] > nc) {
				d[e.to][cnt+1] = nc;
				prev[e.to][cnt+1] = v;
				que.push(mp(d[e.to][cnt+1], mp(e.to, cnt+1)));
			}
		}
	}
}

vector<int> get_path(int t, int cnt) {
	vector<int> path;
	for(;t!=-1;t=prev[t][cnt], cnt--) path.push_back(t);
	reverse(path.begin(),path.end());
	return path;
}

int main() {
	cin >> n >> m >> t;

	rep(i, m) {
		int a, b;
		ll c;
		cin >> a >> b >> c;

		a--; b--;
		G[a].push_back(edge(b, c));
		// G[b].push_back(edge(a, c));
	}

	dijkstra(0, n * n);

	for(int i = n; i > 0; i--) {
		if(d[n-1][i] == INF) continue;
		cout << i << endl;

		vector<int> ret = get_path(n-1, i);
		rep(j, ret.size()) {
			if(j) cout << " ";
			cout << ret[j] + 1;
		}
		cout << endl;
		break;
	}

	return 0;
}
```

最初に$WA$を出したのでlong longに全て直して提出したが$[5000][5000]$なのでメモリが無理．遷移の比較の時にllにして上げれば良いので要らないことに気づく．間違っている理由が全く分からずずっと考えていたが，有向グラフなことを見落としていて，逆の辺を消したら通った(完)．
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM308 CornersGame]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/31/srm308-cornersgame/"/>
    <updated>2016-08-31T02:51:14+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/31/srm308-cornersgame</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6475&rd=9988">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$6 \times 6$の盤面が与えられて，右下の$2 \times 2$にはコインが置いてある．最終的に左上$2 \times 2$に移動させたい．コインの移動は$2$種類ある．

* 隣接したマスに障害物がなければ移動できる
* 隣接したマスが石かコインでそれをジャンプした先に障害物がなければ移動できる

もし移動出来なければ$-1$，そうでなければ最小の移動回数を返す．

---

読み飛ばしていて死んでいた．ジャンプできるのは石だけだと思っていて，最初のサンプルが$16$になる理由が全くわからなかった．問題文を読みなおすと$top\ left$かつ正方形ならなんでも良いのかと思って，それを全探索したりしていた．  
コインもジャンプ可能なので，順番に飛ばし飛ばしで行くとコストが少なくいける．(移動回数, 盤面)を状態として，移動回数が少ない順に見ていった．  
Sample0
{% img /images/SRM/308.gif %}

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;
typedef pair<int, vector<string> > IS;

int dy[4] = {1, 0, -1, 0};
int dx[4] = {0, 1, 0, -1};

bool can(int y, int x) {
	if(0 <= y && y < 6 && 0 <= x && x < 6) return true;
	return false;
}


class CornersGame {
	public:
	int countMoves(vector <string> board) {
		int n = 6;
		vector<string> s = board;
		s[n-2][n-2] = 'X';
		s[n-2][n-1] = 'X';
		s[n-1][n-2] = 'X';
		s[n-1][n-1] = 'X';

		set<vector<string> > st;
		priority_queue<IS, vector<IS>, greater<IS> > que;
		que.push(mp(0, s));

		while(que.size()) {
			IS is = que.top(); que.pop();
			int cnt = is.first;
			s = is.second;

			if(s[0][0] == 'X' && s[0][1] == 'X' && s[1][0] == 'X' && s[1][1] == 'X') {
				return cnt;
			}

			rep(i, n) {
				rep(j, 6) {
					if(s[i][j] != 'X') continue;

					rep(k, 4) {
						int y = i + dy[k];
						int x = j + dx[k];

						if(can(y, x) && s[y][x] == '.') {
							vector<string> t = s;
							swap(t[i][j], t[y][x]);
							if(st.find(t) == st.end()) {
								st.insert(t);
								que.push(mp(cnt + 1, t));
							}
						}

						int ny = y + dy[k];
						int nx = x + dx[k];

						if(can(y, x) && (s[y][x] == 's' || s[y][x] == 'X') && can(ny, nx) && s[ny][nx] == '.') {
							vector<string> t = s;
							swap(t[i][j], t[ny][nx]);
							if(st.find(t) == st.end()) {
								st.insert(t);
								que.push(mp(cnt + 1, t));
							}
						}
					}
				}
			}
		}

		return -1;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM305 D2H Cannibals]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/25/srm305-d2h-cannibals/"/>
    <updated>2016-08-25T13:22:20+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/25/srm305-d2h-cannibals</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6410&rd=9826">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

川渡り問題．宣教師と先住民の問題で，sample0がよく出るやつ．
http://www.umechando.com/playroom/04.htm
このページでsample0をやった．

---

状態を考えると，(本土の宣教師の人数, 本土の先住民の人数, 対岸の宣教師の人数, 対岸の先住民の人数, ボートがどっちにあるか)で，これを$memo[105][105][105][105][2]$で取るとMLE．宣教師は本土$+$対岸は必ず$M$，先住民も本土$+$対岸は必ず$C$となるので，本土だけをメモすれば対岸の人数も分かる．よって$memo[105][105][2]$で良い．後は各状態から船に乗って移動するのを遷移を全探索するdijkstraをした．宣教師より先住民の方が多い場合は遷移できないが，宣教師が$0$人の場合は出来ることに注意する(なかなかこれを書いていないことに気づかなかった)．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;
typedef pair<P, P> PP;

int memo[105][105][2];

struct State {
	int a, b, c, d, cost;
	bool flag;

	State(int a, int b, int c, int d, int cost, bool flag) : a(a), b(b), c(c), d(d), cost(cost), flag(flag) {}

	bool operator<(const State& s) const {
		return cost < s.cost;
    }
	bool operator>(const State& s) const {
		return cost > s.cost;
    }
};

ostream& operator << (ostream& os, const State& s) {
	os << "(" << s.a << ", " << s.b << " | " << s.c << ", " << s.d << ") : " << s.cost << " flag:" << s.flag;
	return os;
}

bool ok(State s) {
	int a = s.a, b = s.b, c = s.c, d = s.d;
	bool f1 = false;
	if(a == 0 || b == 0) f1 = true;
	if(a >= b) f1 = true;

	bool f2 = false;
	if(c == 0 || d == 0) f2 = true;
	if(c >= d) f2 = true;

	return (f1 && f2);
}

class Cannibals {
	public:
	int minCrossings(int M, int C, int R) {
		memset(memo, -1, sizeof(memo));


		priority_queue<State, vector<State>, greater<State> > que;
		que.push(State(M, C, 0, 0, 0, 0));
		memo[M][C][0] = 0;

		while(que.size()) {
			State s = que.top(); que.pop();

			if(s.flag == 0) {
				rep(i, s.a + 1) {
					rep(j, s.b + 1) {
						if(i == 0 && j == 0) continue;
						if(i + j > R) continue;
						if(i != 0 && j != 0 && i < j) continue;

						int a = s.a - i;
						int b = s.b - j;


						State nc(a, b, s.c + i, s.d + j, s.cost + 1, 1);

						if(ok(nc) && memo[nc.a][nc.b][nc.flag] == -1) {
							memo[nc.a][nc.b][nc.flag] = nc.cost;
							que.push(nc);
						}
					}
				}
			} else {
				rep(i, s.c + 1) {
					rep(j, s.d + 1) {
						if(i == 0 && j == 0) continue;
						if(i + j > R) continue;
						if(i != 0 && j != 0 && i < j) continue;

						int c = s.c - i;
						int d = s.d - j;

						State nc(s.a + i, s.b + j, c, d, s.cost + 1, 0);

						if(ok(nc) && memo[nc.a][nc.b][nc.flag] == -1) {
							memo[nc.a][nc.b][nc.flag] = nc.cost;
							que.push(nc);
						}
					}
				}
			}
		}

		return memo[0][0][1];
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2151 Brave Princess Revisited]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/09/aoj2151-brave-princess-revisited/"/>
    <updated>2016-06-09T13:59:08+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/09/aoj2151-brave-princess-revisited</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151">Brave Princess Revisited | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

状態を(襲われる盗賊や刺客の人数, お金, 頂点番号)としてdijkstra．現在の状態から次の状態への遷移は，護衛を雇わないで盗賊に襲われる，護衛を雇い守ってもらう，の$2$つである．お金が辺の長さより少ない場合は護衛を雇えないことに注意する．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;
typedef pair<P, int> PI;

struct edge {
	int from,to;
	int cost, res;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int t,int c,int r) : to(t), cost(c), res(r) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

vector<edge> G[105];
int d[105][105];

void dijkstra(int s, int l) {
	rep(i, 105) rep(j, 105) d[i][j] = INF;
	d[s][l] = 0;

	priority_queue<PI, vector<PI>, greater<PI> > que;
	que.push(mp(mp(0, -l), s));

	while(que.size()) {
		PI p = que.top(); que.pop();
		int cost = p.first.first;
		int coin = p.first.second;
		int v = p.second;
		coin *= -1;

		if(d[v][coin] < cost) continue;
		
		rep(i, G[v].size()) {
			edge e = G[v][i];

			if(d[e.to][coin] > d[v][coin] + e.res) {
				d[e.to][coin] = d[v][coin] + e.res;
				que.push(mp(mp(d[e.to][coin], -coin), e.to));
			}

			int nc = coin - e.cost;
			if(nc >= 0 && d[e.to][nc] > d[v][coin]) {
				d[e.to][nc] = d[v][coin];
				que.push(mp(mp(d[e.to][nc], -nc), e.to));
			}
		}

	}
}

int main() {
	int n, m, l;
	while(cin >> n >> m >> l)  {
		if(n == 0 && m == 0 && l == 0) break;

		rep(i, 105) G[i].clear();

		rep(i, m) {
			int a, b, c, d;
			cin >> a >> b >> c >> d;

			a--; b--;

			G[a].push_back(edge(b, c, d));
			G[b].push_back(edge(a, c, d));
		}

		dijkstra(0, l);

		int ans = INF;
		rep(i, l+1) {
			ans = min(ans, d[n-1][i]);
		}

		cout << ans << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2608 Minus One]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/06/aoj2608-minus-one/"/>
    <updated>2016-06-06T23:24:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/06/aoj2608-minus-one</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2608">Minus One | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$G$に$e$を付け加えて無向グラフにおける$s$から$t$への最短路の長さより$1$だけ大きいものの個数を答える．これはつまり，パスを貼った時に最短経路長が$1$小さくなるものである．  
  
$s$からの最短経路長を$d[i]$，$t$からの最短経路長を$d2[i]$とする．点$a$と点$b$を結んだ場合，$s \to a \to b \to t$という経路を行くとすると，コストは$d[a] + 1 + d2[b]$となる．この時$s \to t$の最短経路長$+1$となる経路は，
$$
\begin{eqnarray}
	d[t] - 1 &=& d[a] + 1 + d2[b] \\\\
	d2[b] &=& d[t] - 2 - d[a]
\end{eqnarray}
$$
が条件となる．愚直に$a, b$のペアを列挙して確認すると$O(n ^2)$で間に合わないが，点$a$を決めた時に，経路長$1$少なくなる$b$の選び方は$d[t] - 2 - d[a]$となる$d2[i]$の個数と決まるので，先に$d2[i]$をカウントしておくと$O(n)$で求められる．最短経路を求めるのが一番時間がかかるので全体で$O(n logn)$．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

struct edge {
	int from,to;
	int cost;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int f,int t,int c) : from(f),to(t),cost(c) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

vector<edge> G[100005];
int d[100005], d2[100005], cnt[100005];

void dijkstra(int s) {
	priority_queue<P, vector<P>, greater<P> > que;
	rep(i, 100005) d[i] = INF;
	
	que.push(mp(0, s));
	d[s] = 0;

	while(que.size()) {
		P p = que.top(); que.pop();
		int cost = p.first;
		int v = p.second;

		if(d[v] < cost) continue;

		rep(i, G[v].size()) {
			edge e = G[v][i];
			if(d[e.to] > d[v] + e.cost) {
				d[e.to] = d[v] + e.cost;
				que.push(mp(d[e.to], e.to));
			}
		}
	}
}

int main() {
	int n, m;
	cin >> n >> m;

	int s, t;
	cin >> s >> t;
	s--; t--;

	rep(i, m) {
		int a, b;
		cin >> a >> b;
		a--; b--;

		G[a].push_back(edge(b, 1));
		G[b].push_back(edge(a, 1));
	}

	dijkstra(s);
	rep(i, n) d2[i] = d[i];

	dijkstra(t);
	rep(i, n) swap(d[i], d2[i]);

	memset(cnt, 0, sizeof(cnt));
	rep(i, n) {
		if(d2[i] == INF) continue;
		cnt[d2[i]]++;
	}

	ll ans = 0;
	rep(i, n) {
		if(d[i] == INF || d2[i] == INF) continue;
		int x = d[t] - 2 - d[i];

		if(x >= 0) {
			ans += cnt[x];
		}
	}

	cout << ans << endl;

	return 0;
}
```

経路復元とか色々していて，色々考えた後に書き直したら非常にスッキリして面白いと思った．但し解くのに時間がかかりすぎている...
]]></content>
  </entry>
  
</feed>
