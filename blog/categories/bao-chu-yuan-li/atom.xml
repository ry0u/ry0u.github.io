<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 包除原理 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/bao-chu-yuan-li/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-06-09T14:11:03+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ1076 Time Manipulation]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/16/aoj1076-time-manipulation/"/>
    <updated>2016-05-16T08:03:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/16/aoj1076-time-manipulation</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1076">Time Manipulation | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>　<script type="math/tex">1〜n</script>の中で <script type="math/tex"> p_i </script>の倍数で無い数の <script type="math/tex"> \frac{和}{個数} </script>を求める．包除原理を用いて， <script type="math/tex"> p_i </script>の倍数である数の個数，和をそれぞれ求めて引いて計算するようにした．<br/>
包除原理は，まずbitで状態を全列挙し，立っているbitの個数が偶数の時に減算，奇数の時に加算する．和は等比数列の和の公式を用いた．(初項<script type="math/tex"> p_i </script>，公差 <script type="math/tex"> p_i </script>，項数 <script type="math/tex"> \frac{n}{p_i} </script>の等差数列の和)．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;bitset&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll n, m;
ll c;

ll lcm(ll m, ll n) {
    if(m == 0 || n == 0) return 0;
    return ((m / __gcd(m,n)) * n);
}

ll f(vector&lt;ll&gt; v) {
    int k = v.size();
    c = 0;
    ll ret = 0;
    rep(i, 1&lt;&lt;k) {
        ll x = 1;
        int cnt = 0;
        bool ch = false;
        rep(j, k) {
            if(i &amp; (1&lt;&lt;j)) {
                x = lcm(x, v[j]);
                cnt++;
            }

            if(x &gt; n) {
                ch = true;
                break;
            }
        }

        if(x == 1LL) continue;
        if(ch) continue;

        ll o = n / x, s;

        if(o % 2 == 0) {
            s = (o / 2) * (2 * x + (o - 1) * x);
        } else {
            s = o * (x + (o - 1) * x / 2);
        }

        if(cnt % 2 == 0) {
            ret -= s;
            c -= o;
        } else {
            ret += s;
            c += o;
        }
    }

    return ret;
}

int main() {
    while(cin &gt;&gt; n &gt;&gt; m) {
        if(n == 0 &amp;&amp; m == 0) break;

        bool flag = false;
        vector&lt;ll&gt; v(m);
        rep(i, m) {
            cin &gt;&gt; v[i];
            if(v[i] == 1) {
                flag = true;
            }
        }

        if(flag) {
            cout &lt;&lt; fixed;
            cout.precision(20);
            cout &lt;&lt; 0.0 &lt;&lt; endl;
            continue;
        }

        ll sum = n * (n + 1) / 2;
        ll ret = f(v);
        ll res = sum - ret;
        double cnt = n - c;

        cout &lt;&lt; fixed;
        cout.precision(20);
        cout &lt;&lt; res / cnt &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
