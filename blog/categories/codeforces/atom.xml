<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: codeforces | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/codeforces/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-05-17T18:34:34+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Codeforces353-div2C Money Transfers]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/17/codeforces353-div2c-money-transfers/"/>
    <updated>2016-05-17T18:20:16+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/17/codeforces353-div2c-money-transfers</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/675/problem/C">Problem - C - Codeforces</a></h4><p>There are n banks in the city where Vasya lives, they are located in a circle, such that any two banks are neighbouring if their indices differ by no more than . Also, bank 1 and bank n are neighbours if n  > 1. No bank is a neighbour of itself.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>隣接した場所の値を自由に交換出来る時，数列を全部<script type="math/tex"> 0 </script>にするには最小何回で出来るか．<br/>
円環なので，切って <script type="math/tex"> 2 </script>つ繋げて表現した．最初は累積和を取って， <script type="math/tex"> [0, 0] </script>となる区間で移動させるようにしていた．これはそれぞれの <script type="math/tex"> (区間数-1) </script>の和が答えで，つまり <script type="math/tex"> (n - 累積和が0の個数) </script>となる．<br/>
累積和が <script type="math/tex"> 0 </script>となる場所の個数は，累積和を開始する地点による．</p>

<p><img src="/images/Codeforces/353/c.png"></p>

<p>上の図(適当)は，累積和をカウントしたものとする．開始地点をずらすというのは，赤の線をどこに引くか( <script type="math/tex"> 0 </script>となる基準をどこにするか)ということになる．よって，最初の累積和の数の個数を数えて，そのmaxを <script type="math/tex"> n </script>から引く．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;ll&gt; v(n);
    rep(i, n) cin &gt;&gt; v[i];


    ll imos[100005];
    memset(imos, 0, sizeof(imos));
    imos[0] = v[0];

    REP(i, 1, n) {
        imos[i] += imos[i-1] + v[i];
    }

    map&lt;ll, int&gt; m;
    int x = 0;

    rep(i, n) {
        m[imos[i]]++;
        x = max(x, m[imos[i]]);
    }

    cout &lt;&lt; n - x &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces353-div2B Restoring Painting]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/17/codeforces353-div2b-restoring-painting/"/>
    <updated>2016-05-17T17:43:57+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/17/codeforces353-div2b-restoring-painting</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/675/problem/B">Problem - B - Codeforces</a></h4><p>Vasya works as a watchman in the gallery. Unfortunately, one of the most expensive paintings was stolen while he was on duty. He doesn't want to be fired, so he has to quickly restore the painting. He remembers some facts about it.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>　<script type="math/tex"> 3 \times 3 </script>のマスで <script type="math/tex"> a, b, c, d </script>が与えられる． <script type="math/tex"> 2 \times 2 </script>の マスの和が全て等しくなるような ?を埋める <script type="math/tex"> 1 \sim n </script>数字の組はいくつあるか？<br/>
<img src="/images/Codeforces/353/b.png"></p>

<p>　?のマスをそれぞれ <script type="math/tex"> x, y, z, h, m </script> と置くと，それぞれ <script type="math/tex"> 4 </script>つの正方形の和は<br/>
<img src="/images/Codeforces/353/b2.png"></p>

<ol>
<li><script type="math/tex"> a + b + x + m </script></li>
<li><script type="math/tex"> a + c + y + m </script></li>
<li><script type="math/tex"> b + d + z + m </script></li>
<li><script type="math/tex"> c + d + h + m </script></li>
</ol>


<p>となり，全て <script type="math/tex"> m </script>が入っていて，<script type="math/tex"> m </script>の値は関係ないことがわかる．なので<script type="math/tex"> x, y, z, h </script>の組の<script type="math/tex"> n </script>倍でいい．<br/>
まず， <script type="math/tex"> x </script>の値を全探索する． <script type="math/tex"> x = i </script>と置くと， <script type="math/tex"> y, z, h </script>が</p>

<ul>
<li><script type="math/tex"> y = b + x - c </script></li>
<li><script type="math/tex"> z = a + x - d </script></li>
<li><script type="math/tex"> h = a + y - d </script></li>
</ul>


<p>と決まるので，その値が <script type="math/tex"> 1 \sim n </script>の間に収まっていれば，正しい組となる．その組の場合に <script type="math/tex"> n </script>を足していった(<script type="math/tex"> m </script>は何でも良い)．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    ll n, a, b, c, d;
    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;

    ll ans = 0;

    REP(i, 1, n + 1) {
        ll x = i;
        ll y = b + x - c;
        ll z = a + x - d;
        ll h = a + y - d;

        if(1 &lt;= y &amp;&amp; y &lt;= n &amp;&amp; 1 &lt;= z &amp;&amp; z &lt;= n &amp;&amp; 1 &lt;= h &amp;&amp; h &lt;= n) {
            ans += n;
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces352-div2D Robin Hood]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/12/codeforces352-div2-robin-hood/"/>
    <updated>2016-05-12T15:14:01+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/12/codeforces352-div2-robin-hood</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/672/problem/D">Problem - D - Codeforces</a></h4><p>We all know the impressive story of Robin Hood. Robin Hood uses his archery skills and his wits to steal the money from rich, and return it to the poor. There are n citizens in Kekoland, each person has coins.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>　<script type="math/tex"> N </script>人いて，コインを <script type="math/tex"> c_i </script>枚持っている． <script type="math/tex"> k </script>回，ある人からコインを取って，ある人に挙げれる時，商人のコインの最大値と最小値の差を最小化する．</p>

<hr />

<p>全員が持つコインの枚数を<script type="math/tex"> 2 </script>分探索．最大値と最小値の差を最大化したいので，最大値の最小化と，最小値の最大化を取って差を取る．コインの枚数を <script type="math/tex"> mid </script>と決めた時に， <script type="math/tex"> mid </script>より(多い / 少ない)コインの枚数が <script type="math/tex"> k </script>枚以下かどうかが条件となる．<br/>
全てのコインの合計が<script type="math/tex"> N </script>人で割り切れない時は，必ず余りが出るので，その差 <script type="math/tex"> +1 </script>が答えになる．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);

    int n, k;
    cin &gt;&gt; n &gt;&gt; k;

    vector&lt;ll&gt; v(n);
    ll lv = INF, rv = 0;
    ll sum = 0;
    rep(i, n) {
        cin &gt;&gt; v[i];
        sum += v[i];
        lv = min(lv, v[i] - 1);
        rv = max(rv, v[i] + 1);
    }

    sort(v.begin(), v.end());

    ll l = lv, r = rv;
    ll vmax = 0, vmin = INF;
    while(r - l &gt; 1) {
        ll mid = (l + r) / 2;
        ll cnt = 0;
        rep(i, n) {
            if(v[i] &gt; mid) {
                cnt += v[i] - mid;
            }
        }

        if(cnt &lt;= k) {
            vmin = min(vmin, mid);
            r = mid;
        } else {
            l = mid;
        }
    }

    l = lv, r = rv;
    while(r - l &gt; 1) {
        ll mid = (l + r) / 2;
        ll cnt = 0;
        rep(i, n) {
            if(v[i] &lt; mid) {
                cnt += mid - v[i];
            }
        }

        if(cnt &lt;= k) {
            vmax = max(vmax, mid);
            l = mid;
        } else {
            r = mid;
        }
    }

    if(sum % n == 0) {
        cout &lt;&lt; max(0LL, vmin - vmax) &lt;&lt; endl;
    } else {
        cout &lt;&lt; max(1LL, vmin - vmax) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces352-div2C Recycling Bottles]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/12/codeforces352-div2-recycling-bottles/"/>
    <updated>2016-05-12T14:55:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/12/codeforces352-div2-recycling-bottles</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/672/problem/C">Problem - C - Codeforces</a></h4><p>It was recycling day in Kekoland. To celebrate it Adil and Bera went to Central Perk where they can take bottles from the ground and put them into a recycling bin. We can think Central Perk as coordinate plane. There are n bottles on the ground, the i-th bottle is located at position .</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>荷物は一個しか持てないので，毎回拾って戻して，拾って戻してを繰り返す．なので，まずそれぞれから <script type="math/tex"> (tx, ty) </script>から行く道と帰る道を両方張る．それから <script type="math/tex"> a </script>が最初に拾った方が良いものがあれば拾う． <script type="math/tex"> b </script>が最初に拾った方が良いものがあれば拾う．とする<br/>
また，<script type="math/tex"> a </script>が動かず <script type="math/tex"> b </script>が全部拾う場合や， <script type="math/tex"> a </script>が動かず <script type="math/tex"> b </script>が拾う場合がある．最初に拾う点を選んでむしろ距離が増えてしまった場合は，その場に立ち止まるようにする．<br/>
また距離の初期値のINFがオーバーフローした．制約に気を付けたい．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1LL&lt;&lt;60
#define pb push_back
#define mp make_pair
#define EPS 1e-8

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct Point {
    double x, y;

    Point(double x=0, double y=0) : x(x), y(y) {}

    Point operator+(const Point &amp;o) const { return Point(x+o.x, y+o.y); }

    Point operator-(const Point &amp;o) const { return Point(x-o.x, y-o.y); }

    Point operator*(const double m) const { return Point(x*m, y*m); }

    Point operator/(const double d) const { return Point(x/d, y/d); }

    bool operator&lt;(const Point &amp;o) const { return x != o.x ? x &lt; o.x : y &lt; o.y; }

    bool operator==(const Point &amp;o) const { return fabs(x-o.x) &lt; EPS &amp;&amp; fabs(y-o.y) &lt; EPS; }
};

ostream&amp; operator &lt;&lt; (ostream&amp; os, const Point&amp; p) {
    os &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ")";
    return os;
}

double dot(Point a, Point b) { return a.x * b.x + a.y * b.y; }
double cross(Point a, Point b) { return a.x * b.y - a.y * b.x; }
double atan(Point p) { return atan2(p.y, p.x); }
double norm(Point p) { return p.x * p.x + p.y * p.y; }
double abs(Point p) { return sqrt(norm(p)); }
double distancePP(Point p, Point o) { return sqrt(norm(o - p)); }

int main() {
    Point a, b, t;
    cin &gt;&gt; a.x &gt;&gt; a.y &gt;&gt; b.x &gt;&gt; b.y &gt;&gt; t.x &gt;&gt; t.y;

    int n;
    cin &gt;&gt; n;

    vector&lt;Point&gt; v(n);
    rep(i, n) cin &gt;&gt; v[i].x &gt;&gt; v[i].y;

    double sum = 0;
    rep(i, n) {
        sum += distancePP(t, v[i]) * 2;
    }

    double A = sum, B = sum;
    {
        double len = -INF;
        int id = -1;
        rep(i, n) {
            double p = distancePP(t, v[i]);
            double q = distancePP(a, v[i]);

            if(p - q &gt; len) {
                len = p - q;
                id = i;
            }
        }

        double len2 = 0;
        int id2 = -1;
        rep(i, n) {
            if(i == id) continue;

            double p = distancePP(t, v[i]);
            double q = distancePP(b, v[i]);

            if(p - q &gt; len2) {
                len2 = p - q;
                id2 = i;
            }
        }

        // cout &lt;&lt;  " A -&gt; B" &lt;&lt; endl;
        // cout &lt;&lt; id &lt;&lt; " " &lt;&lt; id2 &lt;&lt; endl;
        // cout &lt;&lt; "sum:" &lt;&lt; sum &lt;&lt; endl;
        // cout &lt;&lt; distancePP(t, v[id]) &lt;&lt; " " &lt;&lt; distancePP(a, v[id]) &lt;&lt; " " &lt;&lt; len &lt;&lt; endl;
        // cout &lt;&lt; distancePP(t, v[id2]) &lt;&lt; " " &lt;&lt; distancePP(b, v[id2]) &lt;&lt; " " &lt;&lt; len2 &lt;&lt; endl;

        if(id != -1) A -= len;
        if(id2 != -1) A -= len2;
    }
    {
        double len = -INF;
        int id = -1;

        rep(i, n) {
            double p = distancePP(t, v[i]);
            double q = distancePP(b, v[i]);

            if(p - q &gt; len) {
                len = p - q;
                id = i;
            }
        }

        double len2 = 0;
        int id2 = -1;
        rep(i, n) {
            if(i == id) continue;

            double p = distancePP(t, v[i]);
            double q = distancePP(a, v[i]);

            if(p - q &gt; len2) {
                len2 = p - q;
                id2 = i;
            }
        }

        // cout &lt;&lt;  " B -&gt; A" &lt;&lt; endl;
        // cout &lt;&lt; id &lt;&lt; " " &lt;&lt; id2 &lt;&lt; endl;
        // cout &lt;&lt; "sum:" &lt;&lt; sum &lt;&lt; endl;
        // cout &lt;&lt; distancePP(t, v[id]) &lt;&lt; " " &lt;&lt; distancePP(b, v[id]) &lt;&lt; " " &lt;&lt; len &lt;&lt; endl;
        // cout &lt;&lt; distancePP(t, v[id2]) &lt;&lt; " " &lt;&lt; distancePP(a, v[id2]) &lt;&lt; " " &lt;&lt; len2 &lt;&lt; endl;

        if(id != -1) B -= len;
        if(id2 != -1) B -= len2;
    }

    cout &lt;&lt; fixed;
    cout.precision(20);
    cout &lt;&lt; min(A, B) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manthan, Codefest 16D Fibonacci-ish]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16d-fibonacci-ish/"/>
    <updated>2016-02-29T15:59:40+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16d-fibonacci-ish</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-chrome="0" data-card-controls="0"><h4><a href="http://codeforces.com/contest/633/problem/D">Problem - D - Codeforces</a></h4><p>Yash has recently learnt about the Fibonacci sequence and is very excited about it. He calls a sequence Fibonacci-ish if You are given some sequence of integers . Your task is rearrange elements of this sequence in such a way that its longest possible prefix is Fibonacci-ish sequence.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>やることは， <script type="math/tex"> f_0とf_1 </script>選び，シュミレーションする．本番中はpretest 3でTLEを出して，これじゃあ間に合わないと考えていたが，単純に<script type="math/tex"> 0 </script>を考慮していないためだった．<br/>
最初に <script type="math/tex"> 0 </script>をはじいて，全て<script type="math/tex"> 0 </script>のみのパターンか最初に<script type="math/tex"> 0 </script>をつけるパターンのみでいいと思っていたが，途中で<script type="math/tex"> 0 </script>を経由するパターンも普通にあってそこに気づかなかった．<br/>
またsetに突っ込んでその数があるかを確認していたけど，同じ数が出てくるパターンがあるので最初にどの数が何個あるかをmapで持たなければいけなかった．<br/>
stackに積んでおけば後に続く項の個数が分かるので
<script type="math/tex; mode=display">
    memo[mp(a, b)] := (a, b)の時の後に続く項の個数
</script>
とかやるのかな思ったけど，(a, b)にいたるまでに使ってきた数が違えば後に続く項も違いダメだった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;stack&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;ll&gt; v(n);
    map&lt;ll, int&gt; m;
    set&lt;int&gt; st;

    rep(i, n) {
        cin &gt;&gt; v[i];
        m[v[i]]++;
        st.insert(v[i]);
    }

    int ans = m[0];
    rep(i, n) {
        rep(j, n) {
            ll a = v[i], b = v[j], c;

            if(i == j) continue;
            if(a == 0 &amp;&amp; b == 0) continue;

            m[a]--;
            m[b]--;

            stack&lt;ll&gt; S;
            S.push(a);
            S.push(b);

            while(st.find(a + b) != st.end() &amp;&amp; m[a + b] &gt; 0) {
                    c = a + b;
                    a = b;
                    b = c;

                    m[c]--;
                    S.push(c);
            }

            ans = max(ans, (int)S.size());

            while(S.size()) {
                m[S.top()]++;
                S.pop();
            }
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
