<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: codeforces | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/codeforces/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-05-26T10:36:09+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Codeforces354-div2D Theseus and labyrinth]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/26/codeforces354-div2d-theseus-and-labyrinth/"/>
    <updated>2016-05-26T10:19:44+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/26/codeforces354-div2d-theseus-and-labyrinth</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/676/problem/D">Problem - D - Codeforces</a></h4><p>Theseus has just arrived to Crete to fight Minotaur. He found a labyrinth that has a form of a rectangular field of size and consists of blocks of size 1 × 1. Each block of the labyrinth has a button that rotates all blocks 90 degrees clockwise.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>サイズが {% m %} 1 \times 1 {% em %}のブロックで構成される {% m %} n \times m {% em %}の {% m %} field {% em %}がある． {% m %} 1 {% em %}回の行動で隣接するマスに移動するか，全てのブロックを {% m %} 90 {% em %}度時計回りに回転するかが出来る．隣接するマスには移動するためには，現在のマスから隣接するマスの方向にドアがあり，隣接するマスから現在のマスの方向にドアがあるのが条件となる． {% m %} (x_t, y_t) {% em %}から {% m %} (x_mm, y_m) {% em %}には最小何回でいけるか．</p>

<p>盤面と状態を{% m %} (y, x, rot) {% em %}で持って，幅優先探索．当たられる座標が {% m %} xとy {% em %}で逆なので注意する．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;
typedef pair&lt;int, P&gt; IP;
typedef pair&lt;P, P&gt; PP;

int d[1001][1001][4];
char v[1001][1001][4];
map&lt;char, vector&lt;char&gt; &gt; ma;

// (y, x)にdirのドアがあるか
bool ch(int y, int x, int rot, int i) {
    char c = v[y][x][rot];
    if(c == '+') return true;
    if(c == '*') return false;

    if(i == 0) {
        if(c == '-' || c == '&gt;' || c == 'D' || c == 'L' || c == 'U') return true;
        return false;
    } else if(i == 1) {
        if(c == '|' || c == 'v' || c == 'L' || c == 'U' || c == 'R') return true;
        return false;
    } else if(i == 2) {
        if(c == '-' || c == '&lt;' || c == 'U' || c == 'R' || c == 'D') return true;
        return false;
    } else if(i == 3) {
        if(c == '|' || c == '^' || c == 'R' || c == 'D' || c == 'L') return true;
        return false;
    }
}

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    ma['+'].push_back('+');
    ma['+'].push_back('+');
    ma['+'].push_back('+');
    ma['+'].push_back('+');

    ma['-'].push_back('-');
    ma['-'].push_back('|');
    ma['-'].push_back('-');
    ma['-'].push_back('|');

    ma['|'].push_back('|');
    ma['|'].push_back('-');
    ma['|'].push_back('|');
    ma['|'].push_back('-');

    ma['^'].push_back('^');
    ma['^'].push_back('&gt;');
    ma['^'].push_back('v');
    ma['^'].push_back('&lt;');

    ma['&gt;'].push_back('&gt;');
    ma['&gt;'].push_back('v');
    ma['&gt;'].push_back('&lt;');
    ma['&gt;'].push_back('^');

    ma['v'].push_back('v');
    ma['v'].push_back('&lt;');
    ma['v'].push_back('^');
    ma['v'].push_back('&gt;');

    ma['&lt;'].push_back('&lt;');
    ma['&lt;'].push_back('^');
    ma['&lt;'].push_back('&gt;');
    ma['&lt;'].push_back('v');

    ma['L'].push_back('L');
    ma['L'].push_back('U');
    ma['L'].push_back('R');
    ma['L'].push_back('D');

    ma['U'].push_back('U');
    ma['U'].push_back('R');
    ma['U'].push_back('D');
    ma['U'].push_back('L');

    ma['R'].push_back('R');
    ma['R'].push_back('D');
    ma['R'].push_back('L');
    ma['R'].push_back('U');

    ma['D'].push_back('D');
    ma['D'].push_back('L');
    ma['D'].push_back('U');
    ma['D'].push_back('R');

    ma['*'].push_back('*');
    ma['*'].push_back('*');
    ma['*'].push_back('*');
    ma['*'].push_back('*');

    vector&lt;string&gt; s(n);
    rep(i, n) cin &gt;&gt; s[i];

    rep(i, n) {
        rep(j, m) {
            rep(k, 4) {
                v[i][j][k] = ma[s[i][j]][k];
            }
        }
    }

    int sy, sx;
    cin &gt;&gt; sy &gt;&gt; sx;

    sy--; sx--;

    int gy, gx;
    cin &gt;&gt; gy &gt;&gt; gx;

    gy--; gx--;

    rep(i, n) {
        rep(j, m) {
            rep(k, 4) d[i][j][k] = INF;
        }
    }

    queue&lt;IP&gt; que;
    que.push(mp(0, mp(sy, sx)));
    d[sy][sx][0] = 0;

    int dx[4] = {1, 0, -1, 0};
    int dy[4] = {0, 1, 0, -1};
    int nd[4] = {2, 3, 0, 1};

    while(que.size()) {
        IP p = que.front(); que.pop();
        int rot = p.first;
        int y = p.second.first;
        int x = p.second.second;

        rep(i, 4) {
            int ny = y + dy[i];
            int nx = x + dx[i];

            if(0 &lt;= ny &amp;&amp; ny &lt; n &amp;&amp; 0 &lt;= nx &amp;&amp; nx &lt; m &amp;&amp; ch(y, x, rot, i) &amp;&amp; ch(ny, nx, rot, nd[i])) {
                if(d[ny][nx][rot] &gt; d[y][x][rot] + 1) {
                   d[ny][nx][rot] = d[y][x][rot] + 1;
                    que.push(mp(rot, mp(ny, nx)));
                }
            }
        }

        int nr = (rot + 1) % 4;
        if(d[y][x][nr] &gt; d[y][x][rot] + 1) {
            d[y][x][nr] = d[y][x][rot] + 1;
            que.push(mp(nr, mp(y, x)));
        }
    }

    // rep(k, 4) {
    //  cout  &lt;&lt; "-------- " &lt;&lt; endl;
    //  rep(i, n) {
    //      rep(j, m) {
    //          if(d[i][j][k] == INF) cout &lt;&lt; "X ";
    //          else cout &lt;&lt; d[i][j][k] &lt;&lt; " ";
    //      }
    //      cout &lt;&lt; endl;
    //  }
    // }

    int ans = INF;
    rep(i, 4) {
        ans = min(ans, d[gy][gx][i]);
    }

    if(ans == INF) cout &lt;&lt; -1 &lt;&lt; endl;
    else cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>実装がひどい．各方向に行けるかいけないかをboolで持っておけば， {% m %} ch {% em %}の中で全て列挙する形にならないので良いと思った．実装の方針がミスのしやすさ，実装時間に影響すると思うのでなるべく考えてから書きたい．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces354-div2C Vasya and String]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/26/codeforces354-div2c-vasya-and-string/"/>
    <updated>2016-05-26T09:38:50+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/26/codeforces354-div2c-vasya-and-string</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/676/problem/C">Problem - C - Codeforces</a></h4><p>High school student Vasya got a string of length n as a birthday present. This string consists of letters 'a' and '' only. Vasya denotes beauty of the string as the maximum length of a substring (consecutive subsequence) consisting of equal letters. Vasya can change no more than k characters of the original string.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>長さ{% m %} n {% em %}の文字{% m %} a, b {% em %}で構成された文字列が与えられる．{% m %} k {% em %}回変更可能な時に，同じ文字で構成される部分文字列の最大長を答える．</p>

<p>文字 {% m %} a {% em %}だけで構成される部分文字列を考える．区間{% m %} [l, r]{% em %}の中に文字{% m %} b {% em %}が {% m %} k {% em %}個以下ならば，その区間では全て {% m %} a {% em %}にすることができる．これをずらしながらやっていく．文字{% m %} b {% em %}で構成される部分文字列も同様にやり，最大値を取った． {% m %} O(n) {% em %}．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;

    string s;
    cin &gt;&gt; s;

    int ans = 0;

    int l = 0, r = 0, cnt = 0;
    rep(i, n) {
        r = i;
        if(s[i] == 'b') cnt++;

        if(cnt &lt;= k) {
            ans = max(ans, r - l + 1);
        }

        while(cnt &gt; k) {
            if(s[l] == 'b') cnt--;
            l++;
        }
    }

    l = 0, r = 0, cnt = 0;
    rep(i, n) {
        r = i;
        if(s[i] == 'a') cnt++;

        if(cnt &lt;= k) {
            ans = max(ans, r - l + 1);
        }

        while(cnt &gt; k) {
            if(s[l] == 'a') cnt--;
            l++;
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;


    return 0;
}
</code></pre>

<p>本番では落ちた．区間 {% m %} [l, r] {% em %}の中の{% m %} b {% em %}が{% m %} k {% em %}を超えた時，というのは今見ている文字が{% m %} b {% em %}でその文字を {% m %} a {% em %}に変えて， {% m %} l {% em %}をずらす，ということなので {% m %} r {% em %}は必ず今見ている場所 {% m %} i {% em %}となる．ということがよく整理できていなかった．反省．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces354-div2B Pyramid of Glasses]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/26/codeforces354-div2b-pyramid-of-glasses/"/>
    <updated>2016-05-26T09:11:14+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/26/codeforces354-div2b-pyramid-of-glasses</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/676/problem/B">Problem - B - Codeforces</a></h4><p>Mary has just graduated from one well-known University and is now attending celebration party. Students like to dream of a beautiful life, so they used champagne glasses to construct a small pyramid. The height of the pyramid is n.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>グラスがピラミッドのように並んでいる．上から{% m %} n {% em %}段目には{% m %} n {% em %}個のグラスがある．そのグラスがいっぱいになった時は{% m %} 1 {% em %}段下のグラスに均等に注がれる．{% m %} t {% em %}秒後にいっぱいになっているグラスはいくつあるか？</p>

<p>実際にグラフを作って，グラス{% m %} 0 {% em %}から {% m %} 1 {% em %}秒ずつ流していく．グラフは， {% m %} i {% em %}段目の頂点は(自分の番号 {% m %} + i {% em %}), (自分の番号{% m %} + i + 1 {% em %})と繋がるようにした．</p>

<p>{% img /images/Codeforces/354/b.png %}</p>

<p>流す量を {% m %} 1.0 {% em %}から初めて，いっぱいになっている場合は，その半分を繋がっている頂点に流す．流れる量は必ず {% m %} \frac{1}{2 ^x} {% em %}という形になり， {% m %} n {% em %}は最大で {% m %} 10 {% em %}段なので誤差無く保持出来る(はず)．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

vector&lt;int&gt; g[105];
double v[105];

void dfs(int cur, double x) {
    if(v[cur] == 1.0) {
        rep(i, g[cur].size()) {
            dfs(g[cur][i], x / 2.0);
        }
    } else {
        v[cur] += x;
        return;
    }
}

int main() {
    int n, t;
    cin &gt;&gt; n &gt;&gt; t;

    int m = (n * (n+1) ) / 2;

    memset(v, 0, sizeof(v));
    int id = 0, len = 1;
    rep(i, n-1) {
        rep(j, i+1) {
            g[id].push_back(id + len);
            g[id].push_back(id + len+1);
            id++;
        }
        len++;
    }

    rep(i, t) {
        dfs(0, 1.0);
    }

    int cnt = 0;
    rep(i, m) {
        if(v[i] &gt;= 1.0) cnt++;
    }

    cout &lt;&lt; cnt &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces353-div2D Tree Construction]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/17/codeforces353-div2d-tree-construction/"/>
    <updated>2016-05-17T18:36:48+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/17/codeforces353-div2d-tree-construction</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/675/problem/D">Problem - D - Codeforces</a></h4><p>During the programming classes Vasya was assigned a difficult problem. However, he doesn't know how to code and was unable to find the solution in the Internet, so he asks you to help. You are given a sequence a, consisting of n distinct integers, that is used to construct the binary search tree.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>　{% m %} 2 {% em %}分木の挿入する順番が与えられる．挿入した時の親の番号を答える．<br/>
愚直に木を構成すると線のような木の場合に {% m %} O(n ^2) {% em %}となるので間に合わない．区間をsetで管理すると次に挿入する場所が {% m %} logn {% em %}で持ってこれるので，全体で {% m %} O(n logn) {% em %}となる．map({% m %}l, r {% em %})に区間 {% m %} [l, r] {% em %}の親を持っておくようにした．</p>

<p>sample2でどのように動くかをメモしておく．(書いておかないと絶対忘れる．．．)</p>

<h1>Sample 2</h1>

<blockquote><p>{% m %} 5 {% em %}<br/>
{% m %} 4\ 2\ 3\ 1\ 6\ {% em %}</p></blockquote>

<p>手順，挿入する数，挿入する区間 {% m %} \to {% em %} 挿入した結果と書いてみた．</p>

<p>{% math %}
\begin{eqnarray}
insert \ \ (4) \ \ [-\infty, \infty] \ \ &amp;\to&amp; \ \ [-\infty, 4], [4, \infty] \
insert \ \ (2) \ \ [-\infty,\ \ 4] \ \ &amp;\to&amp; \ \ [-\infty, 2], [2, 4], [4, \infty]  \
insert \ \ (3) \ \ [\,\ \ \ \ 2,\ \ 4] \ \ &amp;\to&amp; \ \ [-\infty, 2], [2, 3], [3, 4], [4, \infty] \
insert \ \ (1) \ \ [-\infty,\ \ 2] \ \ &amp;\to&amp; \ \ [-\infty, 1], [1, 2], [2, 3], [3, 4], [4, \infty] \
insert \ \ (6) \ \ [\,\ \ \ \ 4,\infty] \ \ &amp;\to&amp; \ \ [-\infty, 1], [1, 2], [2, 3], [3, 4], [4, 6], [6, \infty] \
\end{eqnarray}
{% endmath %}</p>

<p>後は区間{% m %} [l, r] {% em %}のmapに入っている値を答えて， {% m %} [l, v[i]], [v[i], r] {% em %}に {% m %} v[i] {% em %}を入れておく．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

map&lt;P, int&gt; m;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; v(n);
    rep(i, n) cin &gt;&gt; v[i];

    vector&lt;int&gt; ans;

    set&lt;int&gt; st;
    st.insert(INF);
    st.insert(-INF);
    st.insert(v[0]);

    m[mp(-INF, v[0])] = v[0];
    m[mp(v[0], INF)] = v[0];

    REP(i, 1, n) {
        set&lt;int&gt;::iterator ite = st.upper_bound(v[i]);
        int r = *ite;
        ite--;
        int l = *ite;

        ans.push_back(m[mp(l, r)]);

        m[mp(l, v[i])] = v[i];
        m[mp(v[i], r)] = v[i];
        st.insert(v[i]);
    }

    rep(i, ans.size()) {
        cout &lt;&lt; ans[i];

        if(i == ans.size()-1) cout &lt;&lt; endl;
        else cout &lt;&lt; " ";
    }


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces353-div2C Money Transfers]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/17/codeforces353-div2c-money-transfers/"/>
    <updated>2016-05-17T18:20:16+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/17/codeforces353-div2c-money-transfers</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/675/problem/C">Problem - C - Codeforces</a></h4><p>There are n banks in the city where Vasya lives, they are located in a circle, such that any two banks are neighbouring if their indices differ by no more than . Also, bank 1 and bank n are neighbours if n  > 1. No bank is a neighbour of itself.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>隣接した場所の値を自由に交換出来る時，数列を全部{% m %} 0 {% em %}にするには最小何回で出来るか．<br/>
円環なので，切って {% m %} 2 {% em %}つ繋げて表現した．最初は累積和を取って， {% m %} [0, 0] {% em %}となる区間で移動させるようにしていた．これはそれぞれの {% m %} (区間数-1) {% em %}の和が答えで，つまり {% m %} (n - 累積和が0の個数) {% em %}となる．<br/>
累積和が {% m %} 0 {% em %}となる場所の個数は，累積和を開始する地点による．</p>

<p>{% img /images/Codeforces/353/c.png %}</p>

<p>上の図(適当)は，累積和をカウントしたものとする．開始地点をずらすというのは，赤の線をどこに引くか( {% m %} 0 {% em %}となる基準をどこにするか)ということになる．よって，最初の累積和の数の個数を数えて，そのmaxを {% m %} n {% em %}から引く．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;ll&gt; v(n);
    rep(i, n) cin &gt;&gt; v[i];


    ll imos[100005];
    memset(imos, 0, sizeof(imos));
    imos[0] = v[0];

    REP(i, 1, n) {
        imos[i] += imos[i-1] + v[i];
    }

    map&lt;ll, int&gt; m;
    int x = 0;

    rep(i, n) {
        m[imos[i]]++;
        x = max(x, m[imos[i]]);
    }

    cout &lt;&lt; n - x &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
