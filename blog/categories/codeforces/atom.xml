<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: codeforces | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/codeforces/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-05-13T16:11:21+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Codeforces352-div2D Robin Hood]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/12/codeforces352-div2-robin-hood/"/>
    <updated>2016-05-12T15:14:01+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/12/codeforces352-div2-robin-hood</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/672/problem/D">Problem - D - Codeforces</a></h4><p>We all know the impressive story of Robin Hood. Robin Hood uses his archery skills and his wits to steal the money from rich, and return it to the poor. There are n citizens in Kekoland, each person has coins.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>　<script type="math/tex"> N </script>人いて，コインを <script type="math/tex"> c_i </script>枚持っている． <script type="math/tex"> k </script>回，ある人からコインを取って，ある人に挙げれる時，商人のコインの最大値と最小値の差を最小化する．</p>

<hr />

<p>全員が持つコインの枚数を<script type="math/tex"> 2 </script>分探索．最大値と最小値の差を最大化したいので，最大値の最小化と，最小値の最大化を取って差を取る．コインの枚数を <script type="math/tex"> mid </script>と決めた時に， <script type="math/tex"> mid </script>より(多い / 少ない)コインの枚数が <script type="math/tex"> k </script>枚以下かどうかが条件となる．<br/>
全てのコインの合計が<script type="math/tex"> N </script>人で割り切れない時は，必ず余りが出るので，その差 <script type="math/tex"> +1 </script>が答えになる．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);

    int n, k;
    cin &gt;&gt; n &gt;&gt; k;

    vector&lt;ll&gt; v(n);
    ll lv = INF, rv = 0;
    ll sum = 0;
    rep(i, n) {
        cin &gt;&gt; v[i];
        sum += v[i];
        lv = min(lv, v[i] - 1);
        rv = max(rv, v[i] + 1);
    }

    sort(v.begin(), v.end());

    ll l = lv, r = rv;
    ll vmax = 0, vmin = INF;
    while(r - l &gt; 1) {
        ll mid = (l + r) / 2;
        ll cnt = 0;
        rep(i, n) {
            if(v[i] &gt; mid) {
                cnt += v[i] - mid;
            }
        }

        if(cnt &lt;= k) {
            vmin = min(vmin, mid);
            r = mid;
        } else {
            l = mid;
        }
    }

    l = lv, r = rv;
    while(r - l &gt; 1) {
        ll mid = (l + r) / 2;
        ll cnt = 0;
        rep(i, n) {
            if(v[i] &lt; mid) {
                cnt += mid - v[i];
            }
        }

        if(cnt &lt;= k) {
            vmax = max(vmax, mid);
            l = mid;
        } else {
            r = mid;
        }
    }

    if(sum % n == 0) {
        cout &lt;&lt; max(0LL, vmin - vmax) &lt;&lt; endl;
    } else {
        cout &lt;&lt; max(1LL, vmin - vmax) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces352-div2C Recycling Bottles]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/12/codeforces352-div2-recycling-bottles/"/>
    <updated>2016-05-12T14:55:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/12/codeforces352-div2-recycling-bottles</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/672/problem/C">Problem - C - Codeforces</a></h4><p>It was recycling day in Kekoland. To celebrate it Adil and Bera went to Central Perk where they can take bottles from the ground and put them into a recycling bin. We can think Central Perk as coordinate plane. There are n bottles on the ground, the i-th bottle is located at position .</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>荷物は一個しか持てないので，毎回拾って戻して，拾って戻してを繰り返す．なので，まずそれぞれから <script type="math/tex"> (tx, ty) </script>から行く道と帰る道を両方張る．それから <script type="math/tex"> a </script>が最初に拾った方が良いものがあれば拾う． <script type="math/tex"> b </script>が最初に拾った方が良いものがあれば拾う．とする<br/>
また，<script type="math/tex"> a </script>が動かず <script type="math/tex"> b </script>が全部拾う場合や， <script type="math/tex"> a </script>が動かず <script type="math/tex"> b </script>が拾う場合がある．最初に拾う点を選んでむしろ距離が増えてしまった場合は，その場に立ち止まるようにする．<br/>
また距離の初期値のINFがオーバーフローした．制約に気を付けたい．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1LL&lt;&lt;60
#define pb push_back
#define mp make_pair
#define EPS 1e-8

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct Point {
    double x, y;

    Point(double x=0, double y=0) : x(x), y(y) {}

    Point operator+(const Point &amp;o) const { return Point(x+o.x, y+o.y); }

    Point operator-(const Point &amp;o) const { return Point(x-o.x, y-o.y); }

    Point operator*(const double m) const { return Point(x*m, y*m); }

    Point operator/(const double d) const { return Point(x/d, y/d); }

    bool operator&lt;(const Point &amp;o) const { return x != o.x ? x &lt; o.x : y &lt; o.y; }

    bool operator==(const Point &amp;o) const { return fabs(x-o.x) &lt; EPS &amp;&amp; fabs(y-o.y) &lt; EPS; }
};

ostream&amp; operator &lt;&lt; (ostream&amp; os, const Point&amp; p) {
    os &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ")";
    return os;
}

double dot(Point a, Point b) { return a.x * b.x + a.y * b.y; }
double cross(Point a, Point b) { return a.x * b.y - a.y * b.x; }
double atan(Point p) { return atan2(p.y, p.x); }
double norm(Point p) { return p.x * p.x + p.y * p.y; }
double abs(Point p) { return sqrt(norm(p)); }
double distancePP(Point p, Point o) { return sqrt(norm(o - p)); }

int main() {
    Point a, b, t;
    cin &gt;&gt; a.x &gt;&gt; a.y &gt;&gt; b.x &gt;&gt; b.y &gt;&gt; t.x &gt;&gt; t.y;

    int n;
    cin &gt;&gt; n;

    vector&lt;Point&gt; v(n);
    rep(i, n) cin &gt;&gt; v[i].x &gt;&gt; v[i].y;

    double sum = 0;
    rep(i, n) {
        sum += distancePP(t, v[i]) * 2;
    }

    double A = sum, B = sum;
    {
        double len = -INF;
        int id = -1;
        rep(i, n) {
            double p = distancePP(t, v[i]);
            double q = distancePP(a, v[i]);

            if(p - q &gt; len) {
                len = p - q;
                id = i;
            }
        }

        double len2 = 0;
        int id2 = -1;
        rep(i, n) {
            if(i == id) continue;

            double p = distancePP(t, v[i]);
            double q = distancePP(b, v[i]);

            if(p - q &gt; len2) {
                len2 = p - q;
                id2 = i;
            }
        }

        // cout &lt;&lt;  " A -&gt; B" &lt;&lt; endl;
        // cout &lt;&lt; id &lt;&lt; " " &lt;&lt; id2 &lt;&lt; endl;
        // cout &lt;&lt; "sum:" &lt;&lt; sum &lt;&lt; endl;
        // cout &lt;&lt; distancePP(t, v[id]) &lt;&lt; " " &lt;&lt; distancePP(a, v[id]) &lt;&lt; " " &lt;&lt; len &lt;&lt; endl;
        // cout &lt;&lt; distancePP(t, v[id2]) &lt;&lt; " " &lt;&lt; distancePP(b, v[id2]) &lt;&lt; " " &lt;&lt; len2 &lt;&lt; endl;

        if(id != -1) A -= len;
        if(id2 != -1) A -= len2;
    }
    {
        double len = -INF;
        int id = -1;

        rep(i, n) {
            double p = distancePP(t, v[i]);
            double q = distancePP(b, v[i]);

            if(p - q &gt; len) {
                len = p - q;
                id = i;
            }
        }

        double len2 = 0;
        int id2 = -1;
        rep(i, n) {
            if(i == id) continue;

            double p = distancePP(t, v[i]);
            double q = distancePP(a, v[i]);

            if(p - q &gt; len2) {
                len2 = p - q;
                id2 = i;
            }
        }

        // cout &lt;&lt;  " B -&gt; A" &lt;&lt; endl;
        // cout &lt;&lt; id &lt;&lt; " " &lt;&lt; id2 &lt;&lt; endl;
        // cout &lt;&lt; "sum:" &lt;&lt; sum &lt;&lt; endl;
        // cout &lt;&lt; distancePP(t, v[id]) &lt;&lt; " " &lt;&lt; distancePP(b, v[id]) &lt;&lt; " " &lt;&lt; len &lt;&lt; endl;
        // cout &lt;&lt; distancePP(t, v[id2]) &lt;&lt; " " &lt;&lt; distancePP(a, v[id2]) &lt;&lt; " " &lt;&lt; len2 &lt;&lt; endl;

        if(id != -1) B -= len;
        if(id2 != -1) B -= len2;
    }

    cout &lt;&lt; fixed;
    cout.precision(20);
    cout &lt;&lt; min(A, B) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manthan, Codefest 16D Fibonacci-ish]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16d-fibonacci-ish/"/>
    <updated>2016-02-29T15:59:40+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16d-fibonacci-ish</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-chrome="0" data-card-controls="0"><h4><a href="http://codeforces.com/contest/633/problem/D">Problem - D - Codeforces</a></h4><p>Yash has recently learnt about the Fibonacci sequence and is very excited about it. He calls a sequence Fibonacci-ish if You are given some sequence of integers . Your task is rearrange elements of this sequence in such a way that its longest possible prefix is Fibonacci-ish sequence.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>やることは， <script type="math/tex"> f_0とf_1 </script>選び，シュミレーションする．本番中はpretest 3でTLEを出して，これじゃあ間に合わないと考えていたが，単純に<script type="math/tex"> 0 </script>を考慮していないためだった．<br/>
最初に <script type="math/tex"> 0 </script>をはじいて，全て<script type="math/tex"> 0 </script>のみのパターンか最初に<script type="math/tex"> 0 </script>をつけるパターンのみでいいと思っていたが，途中で<script type="math/tex"> 0 </script>を経由するパターンも普通にあってそこに気づかなかった．<br/>
またsetに突っ込んでその数があるかを確認していたけど，同じ数が出てくるパターンがあるので最初にどの数が何個あるかをmapで持たなければいけなかった．<br/>
stackに積んでおけば後に続く項の個数が分かるので
<script type="math/tex; mode=display">
    memo[mp(a, b)] := (a, b)の時の後に続く項の個数
</script>
とかやるのかな思ったけど，(a, b)にいたるまでに使ってきた数が違えば後に続く項も違いダメだった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;stack&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;ll&gt; v(n);
    map&lt;ll, int&gt; m;
    set&lt;int&gt; st;

    rep(i, n) {
        cin &gt;&gt; v[i];
        m[v[i]]++;
        st.insert(v[i]);
    }

    int ans = m[0];
    rep(i, n) {
        rep(j, n) {
            ll a = v[i], b = v[j], c;

            if(i == j) continue;
            if(a == 0 &amp;&amp; b == 0) continue;

            m[a]--;
            m[b]--;

            stack&lt;ll&gt; S;
            S.push(a);
            S.push(b);

            while(st.find(a + b) != st.end() &amp;&amp; m[a + b] &gt; 0) {
                    c = a + b;
                    a = b;
                    b = c;

                    m[c]--;
                    S.push(c);
            }

            ans = max(ans, (int)S.size());

            while(S.size()) {
                m[S.top()]++;
                S.pop();
            }
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manthan, Codefest 16C Spy Syndrome 2]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16c-spy-syndrome-2/"/>
    <updated>2016-02-29T15:32:14+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16c-spy-syndrome-2</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-chrome="0" data-card-controls="0"><h4><a href="http://codeforces.com/contest/633/problem/C">Problem - C - Codeforces</a></h4><p>After observing the results of Spy Syndrome, Yash realised the errors of his ways. He now believes that a super spy such as Siddhant can't use a cipher as basic and ancient as Caesar cipher. After many weeks of observation of Siddhant's sentences, Yash determined a new cipher technique.</p></blockquote>




<!-- more -->


<p>原文を全て小文字にしてreverseして，接合した文を復元する．<br/>
まずTrie木を作って文字列が単語リストにあるかを判定出来るようにする．<br/>
次に，
<script type="math/tex; mode=display">
    dp[i] := i番目の文字まで復元可能
</script>
とする．Trieのfind関数にその単語そのものがあればTrue, また現在のノードがendであり，その場所の<script type="math/tex"> dp[i] </script>をみて復元可能な時にTrueを返す．その文字列を<script type="math/tex"> S[i] </script>にとっておく．<br/>
後は末尾から帰ってくれば原文の単語の逆順がわかるのでreverseする．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

string S[10005], ret = "", res = "";
bool dp[10005];

struct Trie {
    Trie *next[26];
    bool end;

    Trie() {
        fill(next,next+26,(Trie *)0);
        end = false;
    }

    void insert(string &amp;s,int i) {
        if(i == s.size()) {
            this-&gt;end = true;
            return;
        }

        if(this-&gt;next[s[i]-'a'] == NULL) {
            this-&gt;next[s[i]-'a'] = new Trie();
        }

        this-&gt;next[s[i]-'a']-&gt;insert(s,i+1);
    }

    bool find(int s, int i) {
        if(s - i &gt;= 0 &amp;&amp; dp[s - i] &amp;&amp; this-&gt;end) {
            string t = "";
            rep(j, i) {
                t += ret[s-j];
            }
            res = t;
            return true;
        }

        if((s + 1) - i == 0) {
            if(this-&gt;end) {
                string t = "";
                rep(j, i) {
                    t += ret[s-j];
                }
                res = t;
                return true;
            }
            else return false;
        }

        if(this-&gt;next[ret[s-i]-'a'] != NULL) {
            if(this-&gt;next[ret[s-i]-'a']-&gt;find(s, i+1)) return true;
        }

        return false;
    }
};


int main() {
    int n;
    cin &gt;&gt; n;

    string s;
    cin &gt;&gt; s;

    int m;
    cin &gt;&gt; m;

    vector&lt;string&gt; v(m);
    map&lt;string, string&gt; f;
    Trie *trie = new Trie();

    rep(i, m) {
        cin &gt;&gt; v[i];

        string t = v[i];
        rep(j, t.size()) {
            t[j] = tolower(t[j]);
        }

        f[t] = v[i];
        trie-&gt;insert(t, 0);
    }

    memset(dp, 0, sizeof(dp));

    rep(i, n) {
        ret = ret + s[i];

        if(trie-&gt;find(i, 0)) {
            S[i] = f[res];
            dp[i] = true;
        }
    }

    vector&lt;string&gt; ans;
    int cur = n-1;
    while(dp[cur]) {
        string t = S[cur];
        ans.push_back(t);
        cur -= t.size();
    }

    reverse(ans.begin(), ans.end());

    rep(i, ans.size()) {
        cout &lt;&lt; ans[i];
        if(i == ans.size()-1) cout &lt;&lt; endl;
        else cout &lt;&lt; " ";
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manthan, Codefest 16B A Trivial Problem]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16b-a-trivial-problem/"/>
    <updated>2016-02-29T14:23:55+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16b-a-trivial-problem</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-chrome="0" data-card-controls="0"><h4><a href="http://codeforces.com/contest/633/problem/B">Problem - B - Codeforces</a></h4><p>Mr. Santa asks all the great programmers of the world to solve a trivial problem. He gives them an integer m and asks for the number of positive integers n, such that the factorial of n ends with exactly m zeroes. Are you among those great programmers who can solve this problem?</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>階乗の末尾に<script type="math/tex"> 0がm </script>個ある数は何個あるか．<br/>
末尾に<script type="math/tex"> 0 </script>が増えるのは<script type="math/tex"> 10 </script>などを通るときである．<script type="math/tex"> 10 = 2 \cdot 5 </script>で，<script type="math/tex"> 2は5 </script>の数より圧倒的に多いので<script type="math/tex"> 5 </script>を通るたびに0が増えると考える．<script type="math/tex"> cnt </script>を末尾の<script type="math/tex"> 0 </script>の個数とし，
<script type="math/tex; mode=display">
    5の時は+1 \
    25の時は+2 \
    125の時は+3
</script>
のように5を因数としてもつ分だけ増やす．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; v;
    int cnt = 0;

    rep(i, 5*100000) {
        if(i % 5 == 0) {
            int t = i;
            while(t != 0 &amp;&amp;t % 5 == 0) {
                t /= 5;
                cnt++;
            }
        }

        if(cnt == n) {
            v.push_back(i);
        } else if(cnt &gt; n) {
            break;
        }
    }

    cout &lt;&lt; v.size() &lt;&lt; endl;
    rep(i, v.size()) {
        cout &lt;&lt; v[i];
        if(i == v.size()-1) cout &lt;&lt; endl;
        else cout &lt;&lt; " ";
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
