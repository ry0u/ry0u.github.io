<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: codeforces | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/codeforces/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2015-09-30T15:38:31+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Codeforces322-div2B Luxurious Houses]]></title>
    <link href="http://ry0u.github.io/blog/2015/09/30/codeforces322-div2b-luxurious-houses/"/>
    <updated>2015-09-30T15:26:14+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/09/30/codeforces322-div2b-luxurious-houses</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/581/problem/B">http://codeforces.com/contest/581/problem/B</a></p>

<p>建物の高さが与えられる．自分から見て，右側の建物より高くなるために必要な高さを答えよ．</p>

<h1>考察</h1>

<p>CodeFestival予選練習会で<br/>
<a href="http://code-festival-2014-qualb.contest.atcoder.jp/tasks/code_festival_qualB_d">http://code-festival-2014-qualb.contest.atcoder.jp/tasks/code_festival_qualB_d</a><br/>
を解いたばかりである．これはRMQだ，と思って実装した．<br/>
しかし，そんなことをする必要は無く，右から見ていき，現在見た所までの最大の高さを持っているだけで出来た．この方法は思いつかなかった．</p>

<h1>Code</h1>

<p>RMQ</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct RMQ {
    int n;
    vector&lt;int&gt; dat;

    RMQ(int n_) {
        n = 1;
        while(n &lt; n_) n *= 2;

        dat.resize(n*4);
        rep(i,n*4) dat[i] = -INF;
    }

    void update(int k,int a) {
        int i = k+n-1;
        dat[i] = a;

        while(i &gt; 0) {
            i = (i-1) / 2;
            dat[i] = max(dat[i*2+1],dat[i*2+2]);
        }
    }

    //[a,b)
    //query(a,b,0,0,n)
    int _query(int a,int b,int k,int l,int r)
    {
        if(r &lt;= a || b &lt;= l) return -INF;

        if(a &lt;= l &amp;&amp; r &lt;= b) return dat[k];
        else { 
            int vl = _query(a,b,k*2+1,l,(l+r)/2);
            int vr = _query(a,b,k*2+2,(l+r)/2,r);
            return max(vl,vr);
        }
    }

    //[a,b)
    int query(int a,int b) {
        return _query(a,b,0,0,n);
    }

};

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; v(n);
    RMQ rmq(n);
    rep(i,n) {
        cin &gt;&gt; v[i];
        rmq.update(i,v[i]);
    }

    rep(i,n) {
        int d = rmq.query(i,n+1);
        int d2 = rmq.query(i+1,n+1);

        if(d == v[i] &amp;&amp; v[i] != d2) cout &lt;&lt; 0;
        else cout &lt;&lt; d+1 - v[i];

        if(i == n-1) cout &lt;&lt; endl;
        else cout &lt;&lt; " ";
    }

    return 0;
}
</code></pre>

<p>右から見て行く．</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; v(n);
    rep(i,n) cin &gt;&gt; v[i];

    int vmax = 0;
    vector&lt;int&gt; ans(n);
    for(int i=n-1; i&gt;=0; i--) {
        if(vmax &lt; v[i]) ans[i] = 0;
        else ans[i] = vmax+1 - v[i];

        vmax = max(vmax,v[i]);
    }

    rep(i,n) {
        cout &lt;&lt; ans[i];

        if(i ==n -1) cout &lt;&lt; endl;
        else cout &lt;&lt; " ";
    }

    return 0;
}
</code></pre>

<p>実装量がかなり違うので，出来るだけ実装が軽い方法を思いつけるようになりたい．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces315-div2C Prime or Palindromes?]]></title>
    <link href="http://ry0u.github.io/blog/2015/08/11/codeforces315-div2c-prime-or-palindromes/"/>
    <updated>2015-08-11T04:21:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/08/11/codeforces315-div2c-prime-or-palindromes</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/569/problem/C">http://codeforces.com/contest/569/problem/C</a><br/>
<script type="math/tex; mode=display">
\pi (n) := nをこえない素数の数 \
rub (n) := nをこえない回分の数
</script></p>

<p>と定義する．比<script type="math/tex">A = \frac{p}{q}</script>が与えられるので，<script type="math/tex">\pi (n) \leq A \cdot rub(n)</script>を満たす最大のnを求めたい．</p>

<h1>考察</h1>

<p>まず，<script type="math/tex">\pi (n)</script>と，<script type="math/tex">rub (n)</script>を求める．これをどこまで必要かを自分で判断しなければならない．<script type="math/tex"> A \leq 42</script>とあるので，多くでも<script type="math/tex">\pi (n)</script>が<script type="math/tex">rub (n)</script>の42倍になっているnまででよいと分かる．実際に値を試した所，n = 1500000で十分だとわかった．後は，後ろから見ていき，条件を満たす最大のnを答えた．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

bool prime[10000000];
void Eratosthenes(int n) {
    rep(i,n) prime[i] = true;
    prime[0] = false;
    prime[1] = false;

    REP(i,2,(int)sqrt(n)) {
        if(prime[i]) {
            for(int j=0;i*(j+2)&lt;n;j++) {
                prime[i*(j+2)] = 0;
            }
        }
    }
}

bool check(string s) {
    rep(i,s.size()/2) {
        if(s[i] != s[s.size()-1-i]) return false;
    }

    return true;
}

int main() {
    double p,q;
    cin &gt;&gt; p &gt;&gt; q;

    int N = 1500000;

    Eratosthenes(N);
    vector&lt;int&gt; pi(N);
    int cnt = 0;

    rep(i,N+5) {
        if(prime[i]) {
            cnt++;
        }

        pi[i] = cnt;
    }


    vector&lt;int&gt; rub(N);
    cnt = 0;
    REP(i,1,N+5) {
        stringstream ss;
        ss &lt;&lt; i;

        if(check(ss.str())) {
            cnt++;
        }

        rub[i] = cnt;
    }

    double A = p/q;
    int ans = 0;

    for(int i=N;i&gt;=1;i--) {
        ll a = pi[i];
        ll b = rub[i];

        if(a &lt;=  A * b) {
            cout &lt;&lt; i &lt;&lt; endl;
            break;
        }
        else {
            continue;
        }
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces314-div2D One-Dimensional Battle Ships]]></title>
    <link href="http://ry0u.github.io/blog/2015/08/10/codeforces314-div2d-one-dimensional-battle-ships/"/>
    <updated>2015-08-10T11:21:11+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/08/10/codeforces314-div2d-one-dimensional-battle-ships</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/567/problem/D">http://codeforces.com/contest/567/problem/D</a><br/>
1次元のマス目がある．ここに長さaの船をk個置く．Bobの質問に対して，Aliceが嘘を言った時の番号を答える．</p>

<h1>考察</h1>

<p>どの質問までかを2分探索する．この探索に対してのvectorを作り，それぞれの区間に船が何個入るかを出す．区間を見たいので，端の0のn+1を追加する．この個数がkをこえるかこえないかで判断する．計算量は，探索でlog(n)，vectorのsortにn*log(n)かかるので，全体でO(n*log(n)<sup>2</sup>)．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n,k,a;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; a;

    int m;
    cin &gt;&gt; m;

    vector&lt;int&gt; v(m);
    rep(i,m) {
        cin &gt;&gt; v[i];
    }

    int l = 0,r = m+1;
    while(r - l &gt; 1) {
        int mid = (l+r)/2;
        vector&lt;int&gt; t(v.begin(),v.begin()+mid);

        t.push_back(0);
        t.push_back(n+1);
        sort(t.begin(),t.end());

        int cnt = 0;
        rep(j,t.size()-1) {
            int d = t[j+1] - t[j];
            cnt += d/(a+1);
        }

        if(cnt &gt;= k) {
            l = mid;
        }
        else {
            r = mid;
        }
    }

    if(l == m) cout &lt;&lt; -1 &lt;&lt; endl;
    else cout &lt;&lt; l+1 &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces314-div2c Geometric Progression]]></title>
    <link href="http://ry0u.github.io/blog/2015/08/06/codeforces314-div2c-geometric-progression/"/>
    <updated>2015-08-06T09:34:01+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/08/06/codeforces314-div2c-geometric-progression</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/567/problem/C">http://codeforces.com/contest/567/problem/C</a><br/>
N個の数字と比kが与えられる．比がkである長さ3の部分数列の数を求めたい．</p>

<h1>考察</h1>

<p>3つの等比数列の真ん中の値に注目する．注目している数をxと置くと，d = x/k，x，u = x*kの数列の数を知ることが出来れば良い．自分の前にあるdの要素数，自分の後ろにあるuの要素数の乗算で，今見ているxを含む部分数列の数が分かる．これをN個に対して全てやった．Nは最大2*10<sup>5</sup>のため，オーバーフローに注意する．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {

    ll n,k;
    cin &gt;&gt; n &gt;&gt; k;

    vector&lt;ll&gt; v(n);
    rep(i,n) {
        cin &gt;&gt; v[i];
    }

    map&lt;ll,ll&gt; mup;
    rep(i,n) {
        mup[v[i]]++;
    }

    map&lt;ll,ll&gt; mdown;

    ll ans = 0;

    rep(i,n) {
        mup[v[i]]--;
        if(v[i] % k == 0) {
            ll d = v[i]/k;
            ll u = v[i]*k;

            ans += mdown[d] * mup[u];
        }
        mdown[v[i]]++;
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces313-div2 Gerald's Hexagon]]></title>
    <link href="http://ry0u.github.io/blog/2015/07/25/codeforces313-div2-geralds-hexagon/"/>
    <updated>2015-07-25T17:40:19+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/07/25/codeforces313-div2-geralds-hexagon</id>
    <content type="html"><![CDATA[<p>六角形の辺の長さが時計回りの順番で与えられる．長さ1の正三角形がいくつあるかを求めよ．</p>

<h1>考察</h1>

<p>まずSample1を見る<br/>
<img src="/images/Codeforces313-div2/image1.png"><br/>
これは正六角形であるため，この中に正三角形は6個．これのまず大きな三角形としてみる．追加した三角形を青で表すと<br/>
<img src="/images/Codeforces313-div2/image2.png"></p>

<p>大きな三角形は高さをnとすると，n段目の高さは1 + (n-1)*2で計算できる．そして同じ計算方法で追加した3つの三角形を引く．これで計算できる．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int a,b,c,d,e,f;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f;

    int len = max(a+b+c,a+e+f);
    int ans = 0;
    int t = 1;

    rep(i,len) {
        ans += t;
        t += 2;
    }

    t = 1;
    rep(i,a) {
        ans -= t;
        t += 2;
    }

    t = 1;
    rep(i,c) {
        ans -= t;
        t += 2;
    }

    t = 1;
    rep(i,e) {
        ans -= t;
        t += 2;
    }

    cout &lt;&lt; ans &lt;&lt; endl;


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
