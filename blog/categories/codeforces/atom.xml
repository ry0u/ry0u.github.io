<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: codeforces | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/codeforces/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-02-29T15:45:23+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Manthan, Codefest 16C Spy Syndrome 2]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16c-spy-syndrome-2/"/>
    <updated>2016-02-29T15:32:14+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16c-spy-syndrome-2</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544"><h4><a href="http://codeforces.com/contest/633/problem/C">Problem - C - Codeforces</a></h4><p>After observing the results of Spy Syndrome, Yash realised the errors of his ways. He now believes that a super spy such as Siddhant can't use a cipher as basic and ancient as Caesar cipher. After many weeks of observation of Siddhant's sentences, Yash determined a new cipher technique.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>原文を全て小文字にしてreverseして，接合した文を復元する．<br/>
まずTrie木を作って文字列が単語リストにあるかを判定出来るようにする．<br/>
次に，
<script type="math/tex; mode=display">
    dp[i] := i番目の文字まで復元可能
</script>
とする．Trieのfind関数にその単語そのものがあればTrue, また現在のノードがendであり，その場所の<script type="math/tex"> dp[i] </script>をみて復元可能な時にTrueを返す．その文字列を<script type="math/tex"> S[i] </script>にとっておく．<br/>
後は末尾から帰ってくれば原文の単語の逆順がわかるのでreverseする．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

string S[10005], ret = "", res = "";
bool dp[10005];

struct Trie {
    Trie *next[26];
    bool end;

    Trie() {
        fill(next,next+26,(Trie *)0);
        end = false;
    }

    void insert(string &amp;s,int i) {
        if(i == s.size()) {
            this-&gt;end = true;
            return;
        }

        if(this-&gt;next[s[i]-'a'] == NULL) {
            this-&gt;next[s[i]-'a'] = new Trie();
        }

        this-&gt;next[s[i]-'a']-&gt;insert(s,i+1);
    }

    bool find(int s, int i) {
        if(s - i &gt;= 0 &amp;&amp; dp[s - i] &amp;&amp; this-&gt;end) {
            string t = "";
            rep(j, i) {
                t += ret[s-j];
            }
            res = t;
            return true;
        }

        if((s + 1) - i == 0) {
            if(this-&gt;end) {
                string t = "";
                rep(j, i) {
                    t += ret[s-j];
                }
                res = t;
                return true;
            }
            else return false;
        }

        if(this-&gt;next[ret[s-i]-'a'] != NULL) {
            if(this-&gt;next[ret[s-i]-'a']-&gt;find(s, i+1)) return true;
        }

        return false;
    }
};


int main() {
    int n;
    cin &gt;&gt; n;

    string s;
    cin &gt;&gt; s;

    int m;
    cin &gt;&gt; m;

    vector&lt;string&gt; v(m);
    map&lt;string, string&gt; f;
    Trie *trie = new Trie();

    rep(i, m) {
        cin &gt;&gt; v[i];

        string t = v[i];
        rep(j, t.size()) {
            t[j] = tolower(t[j]);
        }

        f[t] = v[i];
        trie-&gt;insert(t, 0);
    }

    memset(dp, 0, sizeof(dp));

    rep(i, n) {
        ret = ret + s[i];

        if(trie-&gt;find(i, 0)) {
            S[i] = f[res];
            dp[i] = true;
        }
    }

    vector&lt;string&gt; ans;
    int cur = n-1;
    while(dp[cur]) {
        string t = S[cur];
        ans.push_back(t);
        cur -= t.size();
    }

    reverse(ans.begin(), ans.end());

    rep(i, ans.size()) {
        cout &lt;&lt; ans[i];
        if(i == ans.size()-1) cout &lt;&lt; endl;
        else cout &lt;&lt; " ";
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manthan, Codefest 16B A Trivial Problem]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16b-a-trivial-problem/"/>
    <updated>2016-02-29T14:23:55+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16b-a-trivial-problem</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0"><h4><a href="http://codeforces.com/contest/633/problem/B">Problem - B - Codeforces</a></h4><p>Mr. Santa asks all the great programmers of the world to solve a trivial problem. He gives them an integer m and asks for the number of positive integers n, such that the factorial of n ends with exactly m zeroes. Are you among those great programmers who can solve this problem?</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>階乗の末尾に<script type="math/tex"> 0がm </script>個ある数は何個あるか．<br/>
末尾に<script type="math/tex"> 0 </script>が増えるのは<script type="math/tex"> 10 </script>などを通るときである．<script type="math/tex"> 10 = 2 \cdot 5 </script>で，<script type="math/tex"> 2は5 </script>の数より圧倒的に多いので<script type="math/tex"> 5 </script>を通るたびに0が増えると考える．<script type="math/tex"> cnt </script>を末尾の<script type="math/tex"> 0 </script>の個数とし，
<script type="math/tex; mode=display">
    5の時は+1 \
    25の時は+2 \
    125の時は+3
</script>
のように5を因数としてもつ分だけ増やす．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; v;
    int cnt = 0;

    rep(i, 5*100000) {
        if(i % 5 == 0) {
            int t = i;
            while(t != 0 &amp;&amp;t % 5 == 0) {
                t /= 5;
                cnt++;
            }
        }

        if(cnt == n) {
            v.push_back(i);
        } else if(cnt &gt; n) {
            break;
        }
    }

    cout &lt;&lt; v.size() &lt;&lt; endl;
    rep(i, v.size()) {
        cout &lt;&lt; v[i];
        if(i == v.size()-1) cout &lt;&lt; endl;
        else cout &lt;&lt; " ";
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manthan, Codefest 16A Ebony and lvory]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16-a-ebony-and-lvory/"/>
    <updated>2016-02-29T10:27:42+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/29/manthan-codefest-16-a-ebony-and-lvory</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0"><h4><a href="http://codeforces.com/contest/633/problem/A">Problem - A - Codeforces</a></h4><p>Dante is engaged in a fight with "The Savior". Before he can fight it with his sword, he needs to break its shields. He has two guns, Ebony and Ivory, each of them is able to perform any non-negative number of shots.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>


<!-- more-->


<p><script type="math/tex; mode=display">
    a, bを用いてcを表せるか．使用回数は0でも良い．
</script></p>

<p><script type="math/tex; mode=display">
    iが表せるならi+a, i+bも表すことが出来る．O(\max&copy;)
</script></p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

bool used[10500];

int main() {
    int a, b, c;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;

    memset(used, 0, sizeof(used));
    used[0] = true;

    rep(i, c + 1) {
        if(used[i]) {
            used[i+a] = true;
        }
    }

    rep(i, c + 1) {
        if(used[i]) {
            used[i+b] = true;
        }
    }

    if(used[c]) cout &lt;&lt; "Yes" &lt;&lt; endl;
    else cout &lt;&lt; "No" &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces335-div2D Lazy Student]]></title>
    <link href="http://ry0u.github.io/blog/2015/12/15/codeforces335-div2d-lazy-student/"/>
    <updated>2015-12-15T11:04:47+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/12/15/codeforces335-div2d-lazy-student</id>
    <content type="html"><![CDATA[<p>グラフの頂点数<script type="math/tex">N</script>，辺の数<script type="math/tex">M</script>，
最小全域木を構築する辺とそれ以外の辺が与えられる．そのようなグラフが存在すればその一例を，そうでない場合は-1を出力する．</p>

<h1>考察</h1>

<p>最小全域木を構築する辺をコストの小さい順に一本につなげる．Sample 1では次のようにする．
<img src="/images/Codeforces/335/g.png"></p>

<p>後は最小全域木を壊さないように辺を追加する．2つの辺を選び，その端を結ぶことを考えるとその選び方は2乗通りある．
<img src="/images/Codeforces/335/g2.png"></p>

<p>しかし，最小全域木を壊さないということは，選んだ2つの辺のコストよりも大きい辺を追加すれば良いので，小さい順に見ていけばよい．一本の線にする時に小さい順にしているので，前から見ていくことで，追加する辺の個数回で済む．<br/>
<img src="/images/Codeforces/335/g3.png"></p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;pair&lt;pair&lt;int,int&gt;, int&gt; &gt; v;
    rep(i, m) {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        v.push_back(mp(mp(a, b), i));
    }

    sort(v.begin(), v.end());

    vector&lt;int&gt; e;
    vector&lt;P&gt; q;
    vector&lt;pair&lt;int,pair&lt;int,int&gt; &gt; &gt; ans;
    int t = 0;
    rep(i, m) {
        int cost = v[i].first.first;
        int f = v[i].first.second;
        int j = v[i].second;

        if(f == 1) {
            e.push_back(cost);
            ans.push_back(mp(j, mp(t, t+1)));
            t++;
        }
        else if(f == 0) {
            q.push_back(mp(cost, j));
        }
    }

    bool flag = true;
    int from = 0, to = 1;
    for(int i = 0; i &lt; q.size(); i++) {
        if(to == e.size()) {
            flag = false;
            break;
        }

        if(e[from] &lt;= q[i].first &amp;&amp; e[to] &lt;= q[i].first) {
            ans.push_back(mp(q[i].second, mp(from, to+1) ));
        } else {
            P p = q.back();
            if(e[from] &lt;= p.first &amp;&amp; e[to] &lt;= p.first) {
                ans.push_back(mp(p.second, mp(from, to+1)));
                q.pop_back();
            }
            i--;
        }

        if(from == to - 1) {
            from = 0;
            to++;
        } else {
            from++;
        }
    }

    if(flag) {
        sort(ans.begin(), ans.end());
        rep(i, ans.size()) {
            cout &lt;&lt; ans[i].second.first+1 &lt;&lt; " " &lt;&lt; ans[i].second.second+1 &lt;&lt; endl;
        }
    } else {
        cout &lt;&lt; -1 &lt;&lt; endl;
    }

    return 0;
}
</code></pre>

<p>選んだ辺のコストを超えないようにするということは，まず１つの辺を選んだ時に，それより小さい辺を見なければいけなかったが，大きい方の辺をずらしていくという意味の分からないことをしていてWAを連発した．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces334-div2C Alternative Thinking]]></title>
    <link href="http://ry0u.github.io/blog/2015/12/15/codeforces334-div2c-alternative-thinking/"/>
    <updated>2015-12-15T09:50:00+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/12/15/codeforces334-div2c-alternative-thinking</id>
    <content type="html"><![CDATA[<p>長さ<script type="math/tex">N</script>の'0'と'1'で構成された文字列が与えられる．ある区間を1度だけ反転して'0'と'1'が交互となる列の長さを最大化する．</p>

<h1>考察</h1>

<p>まず，文字列の交互列の長さを<script type="math/tex"> m </script>とすると，一度の反転で最大2しか増えないことが分かる．例えば，
<script type="math/tex; mode=display">
    1111(m = 1) \Rightarrow 11\color{red}01(m = 3) \
    1101(m = 3) \Rightarrow \color{red}0101(m = 4) \
    1100(m = 2) \Rightarrow 1\color{red}0\color{red}10(m = 4) \
</script>
のように出来る．また，<script type="math/tex"> m = N </script>の時以外に，区間を反転して長さが増えないケースを考えると，そのようなケースは無いと分かる．反転する区間で01を内包している場合，反転後をその部分は10で交互列になるからである．
<script type="math/tex; mode=display">
11 0101 00(m = 4) \Rightarrow 1 \color{red}0 \color{red}1\color{red}0\color{red}1\color{red}0 \color{red}1 0(m = 6) \
</script></p>

<p>よって，<script type="math/tex">N</script>を超えないように，+1，+2したらACが貰えた</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    string s;
    cin &gt;&gt; s;

    int cnt = 0;
    bool flag = true;

    if(s[0] == '1') cnt++;

    rep(i, n) {
        if(flag) {
            if(s[i] == '1') continue;
            else {
                cnt++;
                flag = false;
            }
        } else {
            if(s[i] == '1') {
                cnt++;
                flag = true;
            } else continue;
        }
    }

    if(cnt + 2 &lt;= n) cout &lt;&lt; cnt + 2 &lt;&lt; endl;
    else if(cnt + 1 &lt;= n) cout &lt;&lt; cnt + 1 &lt;&lt; endl;
    else cout &lt;&lt; cnt &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
