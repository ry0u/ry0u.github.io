<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: codeforces | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/codeforces/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-05-23T00:20:55+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Codeforces353-div2D Tree Construction]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/17/codeforces353-div2d-tree-construction/"/>
    <updated>2016-05-17T18:36:48+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/17/codeforces353-div2d-tree-construction</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/675/problem/D">Problem - D - Codeforces</a></h4><p>During the programming classes Vasya was assigned a difficult problem. However, he doesn't know how to code and was unable to find the solution in the Internet, so he asks you to help. You are given a sequence a, consisting of n distinct integers, that is used to construct the binary search tree.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>　<script type="math/tex"> 2 </script>分木の挿入する順番が与えられる．挿入した時の親の番号を答える．<br/>
愚直に木を構成すると線のような木の場合に <script type="math/tex"> O(n ^2) </script>となるので間に合わない．区間をsetで管理すると次に挿入する場所が <script type="math/tex"> logn </script>で持ってこれるので，全体で <script type="math/tex"> O(n logn) </script>となる．map(<script type="math/tex">l, r </script>)に区間 <script type="math/tex"> [l, r] </script>の親を持っておくようにした．</p>

<p>sample2でどのように動くかをメモしておく．(書いておかないと絶対忘れる．．．)</p>

<h1>Sample 2</h1>

<blockquote><p><script type="math/tex"> 5 </script><br/>
<script type="math/tex"> 4\ 2\ 3\ 1\ 6\ </script></p></blockquote>

<p>手順，挿入する数，挿入する区間 <script type="math/tex"> \to </script> 挿入した結果と書いてみた．</p>

<p><script type="math/tex; mode=display">
\begin{eqnarray}
insert \ \ (4) \ \ [-\infty, \infty] \ \ &amp;\to&amp; \ \ [-\infty, 4], [4, \infty] \
insert \ \ (2) \ \ [-\infty,\ \ 4] \ \ &amp;\to&amp; \ \ [-\infty, 2], [2, 4], [4, \infty]  \
insert \ \ (3) \ \ [\,\ \ \ \ 2,\ \ 4] \ \ &amp;\to&amp; \ \ [-\infty, 2], [2, 3], [3, 4], [4, \infty] \
insert \ \ (1) \ \ [-\infty,\ \ 2] \ \ &amp;\to&amp; \ \ [-\infty, 1], [1, 2], [2, 3], [3, 4], [4, \infty] \
insert \ \ (6) \ \ [\,\ \ \ \ 4,\infty] \ \ &amp;\to&amp; \ \ [-\infty, 1], [1, 2], [2, 3], [3, 4], [4, 6], [6, \infty] \
\end{eqnarray}
</script></p>

<p>後は区間<script type="math/tex"> [l, r] </script>のmapに入っている値を答えて， <script type="math/tex"> [l, v[i]], [v[i], r] </script>に <script type="math/tex"> v[i] </script>を入れておく．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

map&lt;P, int&gt; m;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; v(n);
    rep(i, n) cin &gt;&gt; v[i];

    vector&lt;int&gt; ans;

    set&lt;int&gt; st;
    st.insert(INF);
    st.insert(-INF);
    st.insert(v[0]);

    m[mp(-INF, v[0])] = v[0];
    m[mp(v[0], INF)] = v[0];

    REP(i, 1, n) {
        set&lt;int&gt;::iterator ite = st.upper_bound(v[i]);
        int r = *ite;
        ite--;
        int l = *ite;

        ans.push_back(m[mp(l, r)]);

        m[mp(l, v[i])] = v[i];
        m[mp(v[i], r)] = v[i];
        st.insert(v[i]);
    }

    rep(i, ans.size()) {
        cout &lt;&lt; ans[i];

        if(i == ans.size()-1) cout &lt;&lt; endl;
        else cout &lt;&lt; " ";
    }


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces353-div2C Money Transfers]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/17/codeforces353-div2c-money-transfers/"/>
    <updated>2016-05-17T18:20:16+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/17/codeforces353-div2c-money-transfers</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/675/problem/C">Problem - C - Codeforces</a></h4><p>There are n banks in the city where Vasya lives, they are located in a circle, such that any two banks are neighbouring if their indices differ by no more than . Also, bank 1 and bank n are neighbours if n  > 1. No bank is a neighbour of itself.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>隣接した場所の値を自由に交換出来る時，数列を全部<script type="math/tex"> 0 </script>にするには最小何回で出来るか．<br/>
円環なので，切って <script type="math/tex"> 2 </script>つ繋げて表現した．最初は累積和を取って， <script type="math/tex"> [0, 0] </script>となる区間で移動させるようにしていた．これはそれぞれの <script type="math/tex"> (区間数-1) </script>の和が答えで，つまり <script type="math/tex"> (n - 累積和が0の個数) </script>となる．<br/>
累積和が <script type="math/tex"> 0 </script>となる場所の個数は，累積和を開始する地点による．</p>

<p><img src="/images/Codeforces/353/c.png"></p>

<p>上の図(適当)は，累積和をカウントしたものとする．開始地点をずらすというのは，赤の線をどこに引くか( <script type="math/tex"> 0 </script>となる基準をどこにするか)ということになる．よって，最初の累積和の数の個数を数えて，そのmaxを <script type="math/tex"> n </script>から引く．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;ll&gt; v(n);
    rep(i, n) cin &gt;&gt; v[i];


    ll imos[100005];
    memset(imos, 0, sizeof(imos));
    imos[0] = v[0];

    REP(i, 1, n) {
        imos[i] += imos[i-1] + v[i];
    }

    map&lt;ll, int&gt; m;
    int x = 0;

    rep(i, n) {
        m[imos[i]]++;
        x = max(x, m[imos[i]]);
    }

    cout &lt;&lt; n - x &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces353-div2B Restoring Painting]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/17/codeforces353-div2b-restoring-painting/"/>
    <updated>2016-05-17T17:43:57+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/17/codeforces353-div2b-restoring-painting</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/675/problem/B">Problem - B - Codeforces</a></h4><p>Vasya works as a watchman in the gallery. Unfortunately, one of the most expensive paintings was stolen while he was on duty. He doesn't want to be fired, so he has to quickly restore the painting. He remembers some facts about it.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>　<script type="math/tex"> 3 \times 3 </script>のマスで <script type="math/tex"> a, b, c, d </script>が与えられる． <script type="math/tex"> 2 \times 2 </script>の マスの和が全て等しくなるような ?を埋める <script type="math/tex"> 1 \sim n </script>数字の組はいくつあるか？<br/>
<img src="/images/Codeforces/353/b.png"></p>

<p>　?のマスをそれぞれ <script type="math/tex"> x, y, z, h, m </script> と置くと，それぞれ <script type="math/tex"> 4 </script>つの正方形の和は<br/>
<img src="/images/Codeforces/353/b2.png"></p>

<ol>
<li><script type="math/tex"> a + b + x + m </script></li>
<li><script type="math/tex"> a + c + y + m </script></li>
<li><script type="math/tex"> b + d + z + m </script></li>
<li><script type="math/tex"> c + d + h + m </script></li>
</ol>


<p>となり，全て <script type="math/tex"> m </script>が入っていて，<script type="math/tex"> m </script>の値は関係ないことがわかる．なので<script type="math/tex"> x, y, z, h </script>の組の<script type="math/tex"> n </script>倍でいい．<br/>
まず， <script type="math/tex"> x </script>の値を全探索する． <script type="math/tex"> x = i </script>と置くと， <script type="math/tex"> y, z, h </script>が</p>

<ul>
<li><script type="math/tex"> y = b + x - c </script></li>
<li><script type="math/tex"> z = a + x - d </script></li>
<li><script type="math/tex"> h = a + y - d </script></li>
</ul>


<p>と決まるので，その値が <script type="math/tex"> 1 \sim n </script>の間に収まっていれば，正しい組となる．その組の場合に <script type="math/tex"> n </script>を足していった(<script type="math/tex"> m </script>は何でも良い)．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    ll n, a, b, c, d;
    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;

    ll ans = 0;

    REP(i, 1, n + 1) {
        ll x = i;
        ll y = b + x - c;
        ll z = a + x - d;
        ll h = a + y - d;

        if(1 &lt;= y &amp;&amp; y &lt;= n &amp;&amp; 1 &lt;= z &amp;&amp; z &lt;= n &amp;&amp; 1 &lt;= h &amp;&amp; h &lt;= n) {
            ans += n;
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces352-div2D Robin Hood]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/12/codeforces352-div2-robin-hood/"/>
    <updated>2016-05-12T15:14:01+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/12/codeforces352-div2-robin-hood</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/672/problem/D">Problem - D - Codeforces</a></h4><p>We all know the impressive story of Robin Hood. Robin Hood uses his archery skills and his wits to steal the money from rich, and return it to the poor. There are n citizens in Kekoland, each person has coins.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>　<script type="math/tex"> N </script>人いて，コインを <script type="math/tex"> c_i </script>枚持っている． <script type="math/tex"> k </script>回，ある人からコインを取って，ある人に挙げれる時，商人のコインの最大値と最小値の差を最小化する．</p>

<hr />

<p>全員が持つコインの枚数を<script type="math/tex"> 2 </script>分探索．最大値と最小値の差を最大化したいので，最大値の最小化と，最小値の最大化を取って差を取る．コインの枚数を <script type="math/tex"> mid </script>と決めた時に， <script type="math/tex"> mid </script>より(多い / 少ない)コインの枚数が <script type="math/tex"> k </script>枚以下かどうかが条件となる．<br/>
全てのコインの合計が<script type="math/tex"> N </script>人で割り切れない時は，必ず余りが出るので，その差 <script type="math/tex"> +1 </script>が答えになる．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);

    int n, k;
    cin &gt;&gt; n &gt;&gt; k;

    vector&lt;ll&gt; v(n);
    ll lv = INF, rv = 0;
    ll sum = 0;
    rep(i, n) {
        cin &gt;&gt; v[i];
        sum += v[i];
        lv = min(lv, v[i] - 1);
        rv = max(rv, v[i] + 1);
    }

    sort(v.begin(), v.end());

    ll l = lv, r = rv;
    ll vmax = 0, vmin = INF;
    while(r - l &gt; 1) {
        ll mid = (l + r) / 2;
        ll cnt = 0;
        rep(i, n) {
            if(v[i] &gt; mid) {
                cnt += v[i] - mid;
            }
        }

        if(cnt &lt;= k) {
            vmin = min(vmin, mid);
            r = mid;
        } else {
            l = mid;
        }
    }

    l = lv, r = rv;
    while(r - l &gt; 1) {
        ll mid = (l + r) / 2;
        ll cnt = 0;
        rep(i, n) {
            if(v[i] &lt; mid) {
                cnt += mid - v[i];
            }
        }

        if(cnt &lt;= k) {
            vmax = max(vmax, mid);
            l = mid;
        } else {
            r = mid;
        }
    }

    if(sum % n == 0) {
        cout &lt;&lt; max(0LL, vmin - vmax) &lt;&lt; endl;
    } else {
        cout &lt;&lt; max(1LL, vmin - vmax) &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces352-div2C Recycling Bottles]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/12/codeforces352-div2-recycling-bottles/"/>
    <updated>2016-05-12T14:55:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/12/codeforces352-div2-recycling-bottles</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://codeforces.com/contest/672/problem/C">Problem - C - Codeforces</a></h4><p>It was recycling day in Kekoland. To celebrate it Adil and Bera went to Central Perk where they can take bottles from the ground and put them into a recycling bin. We can think Central Perk as coordinate plane. There are n bottles on the ground, the i-th bottle is located at position .</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>荷物は一個しか持てないので，毎回拾って戻して，拾って戻してを繰り返す．なので，まずそれぞれから <script type="math/tex"> (tx, ty) </script>から行く道と帰る道を両方張る．それから <script type="math/tex"> a </script>が最初に拾った方が良いものがあれば拾う． <script type="math/tex"> b </script>が最初に拾った方が良いものがあれば拾う．とする<br/>
また，<script type="math/tex"> a </script>が動かず <script type="math/tex"> b </script>が全部拾う場合や， <script type="math/tex"> a </script>が動かず <script type="math/tex"> b </script>が拾う場合がある．最初に拾う点を選んでむしろ距離が増えてしまった場合は，その場に立ち止まるようにする．<br/>
また距離の初期値のINFがオーバーフローした．制約に気を付けたい．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1LL&lt;&lt;60
#define pb push_back
#define mp make_pair
#define EPS 1e-8

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct Point {
    double x, y;

    Point(double x=0, double y=0) : x(x), y(y) {}

    Point operator+(const Point &amp;o) const { return Point(x+o.x, y+o.y); }

    Point operator-(const Point &amp;o) const { return Point(x-o.x, y-o.y); }

    Point operator*(const double m) const { return Point(x*m, y*m); }

    Point operator/(const double d) const { return Point(x/d, y/d); }

    bool operator&lt;(const Point &amp;o) const { return x != o.x ? x &lt; o.x : y &lt; o.y; }

    bool operator==(const Point &amp;o) const { return fabs(x-o.x) &lt; EPS &amp;&amp; fabs(y-o.y) &lt; EPS; }
};

ostream&amp; operator &lt;&lt; (ostream&amp; os, const Point&amp; p) {
    os &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ")";
    return os;
}

double dot(Point a, Point b) { return a.x * b.x + a.y * b.y; }
double cross(Point a, Point b) { return a.x * b.y - a.y * b.x; }
double atan(Point p) { return atan2(p.y, p.x); }
double norm(Point p) { return p.x * p.x + p.y * p.y; }
double abs(Point p) { return sqrt(norm(p)); }
double distancePP(Point p, Point o) { return sqrt(norm(o - p)); }

int main() {
    Point a, b, t;
    cin &gt;&gt; a.x &gt;&gt; a.y &gt;&gt; b.x &gt;&gt; b.y &gt;&gt; t.x &gt;&gt; t.y;

    int n;
    cin &gt;&gt; n;

    vector&lt;Point&gt; v(n);
    rep(i, n) cin &gt;&gt; v[i].x &gt;&gt; v[i].y;

    double sum = 0;
    rep(i, n) {
        sum += distancePP(t, v[i]) * 2;
    }

    double A = sum, B = sum;
    {
        double len = -INF;
        int id = -1;
        rep(i, n) {
            double p = distancePP(t, v[i]);
            double q = distancePP(a, v[i]);

            if(p - q &gt; len) {
                len = p - q;
                id = i;
            }
        }

        double len2 = 0;
        int id2 = -1;
        rep(i, n) {
            if(i == id) continue;

            double p = distancePP(t, v[i]);
            double q = distancePP(b, v[i]);

            if(p - q &gt; len2) {
                len2 = p - q;
                id2 = i;
            }
        }

        // cout &lt;&lt;  " A -&gt; B" &lt;&lt; endl;
        // cout &lt;&lt; id &lt;&lt; " " &lt;&lt; id2 &lt;&lt; endl;
        // cout &lt;&lt; "sum:" &lt;&lt; sum &lt;&lt; endl;
        // cout &lt;&lt; distancePP(t, v[id]) &lt;&lt; " " &lt;&lt; distancePP(a, v[id]) &lt;&lt; " " &lt;&lt; len &lt;&lt; endl;
        // cout &lt;&lt; distancePP(t, v[id2]) &lt;&lt; " " &lt;&lt; distancePP(b, v[id2]) &lt;&lt; " " &lt;&lt; len2 &lt;&lt; endl;

        if(id != -1) A -= len;
        if(id2 != -1) A -= len2;
    }
    {
        double len = -INF;
        int id = -1;

        rep(i, n) {
            double p = distancePP(t, v[i]);
            double q = distancePP(b, v[i]);

            if(p - q &gt; len) {
                len = p - q;
                id = i;
            }
        }

        double len2 = 0;
        int id2 = -1;
        rep(i, n) {
            if(i == id) continue;

            double p = distancePP(t, v[i]);
            double q = distancePP(a, v[i]);

            if(p - q &gt; len2) {
                len2 = p - q;
                id2 = i;
            }
        }

        // cout &lt;&lt;  " B -&gt; A" &lt;&lt; endl;
        // cout &lt;&lt; id &lt;&lt; " " &lt;&lt; id2 &lt;&lt; endl;
        // cout &lt;&lt; "sum:" &lt;&lt; sum &lt;&lt; endl;
        // cout &lt;&lt; distancePP(t, v[id]) &lt;&lt; " " &lt;&lt; distancePP(b, v[id]) &lt;&lt; " " &lt;&lt; len &lt;&lt; endl;
        // cout &lt;&lt; distancePP(t, v[id2]) &lt;&lt; " " &lt;&lt; distancePP(a, v[id2]) &lt;&lt; " " &lt;&lt; len2 &lt;&lt; endl;

        if(id != -1) B -= len;
        if(id2 != -1) B -= len2;
    }

    cout &lt;&lt; fixed;
    cout.precision(20);
    cout &lt;&lt; min(A, B) &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
