<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: codeforces | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/codeforces/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2015-08-13T21:43:25+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Codeforces315-div2C Prime or Palindromes?]]></title>
    <link href="http://ry0u.github.io/blog/2015/08/11/codeforces315-div2c-prime-or-palindromes/"/>
    <updated>2015-08-11T04:21:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/08/11/codeforces315-div2c-prime-or-palindromes</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/569/problem/C">http://codeforces.com/contest/569/problem/C</a><br/>
<script type="math/tex; mode=display">
\pi (n) := nをこえない素数の数 \
rub (n) := nをこえない回分の数
</script></p>

<p>と定義する．比<script type="math/tex">A = \frac{p}{q}</script>が与えられるので，<script type="math/tex">\pi (n) \leq A \cdot rub(n)</script>を満たす最大のnを求めたい．</p>

<h1>考察</h1>

<p>まず，<script type="math/tex">\pi (n)</script>と，<script type="math/tex">rub (n)</script>を求める．これをどこまで必要かを自分で判断しなければならない．<script type="math/tex"> A \leq 42</script>とあるので，多くでも<script type="math/tex">\pi (n)</script>が<script type="math/tex">rub (n)</script>の42倍になっているnまででよいと分かる．実際に値を試した所，n = 1500000で十分だとわかった．後は，後ろから見ていき，条件を満たす最大のnを答えた．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

bool prime[10000000];
void Eratosthenes(int n) {
    rep(i,n) prime[i] = true;
    prime[0] = false;
    prime[1] = false;

    REP(i,2,(int)sqrt(n)) {
        if(prime[i]) {
            for(int j=0;i*(j+2)&lt;n;j++) {
                prime[i*(j+2)] = 0;
            }
        }
    }
}

bool check(string s) {
    rep(i,s.size()/2) {
        if(s[i] != s[s.size()-1-i]) return false;
    }

    return true;
}

int main() {
    double p,q;
    cin &gt;&gt; p &gt;&gt; q;

    int N = 1500000;

    Eratosthenes(N);
    vector&lt;int&gt; pi(N);
    int cnt = 0;

    rep(i,N+5) {
        if(prime[i]) {
            cnt++;
        }

        pi[i] = cnt;
    }


    vector&lt;int&gt; rub(N);
    cnt = 0;
    REP(i,1,N+5) {
        stringstream ss;
        ss &lt;&lt; i;

        if(check(ss.str())) {
            cnt++;
        }

        rub[i] = cnt;
    }

    double A = p/q;
    int ans = 0;

    for(int i=N;i&gt;=1;i--) {
        ll a = pi[i];
        ll b = rub[i];

        if(a &lt;=  A * b) {
            cout &lt;&lt; i &lt;&lt; endl;
            break;
        }
        else {
            continue;
        }
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces314-div2D One-Dimensional Battle Ships]]></title>
    <link href="http://ry0u.github.io/blog/2015/08/10/codeforces314-div2d-one-dimensional-battle-ships/"/>
    <updated>2015-08-10T11:21:11+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/08/10/codeforces314-div2d-one-dimensional-battle-ships</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/567/problem/D">http://codeforces.com/contest/567/problem/D</a><br/>
1次元のマス目がある．ここに長さaの船をk個置く．Bobの質問に対して，Aliceが嘘を言った時の番号を答える．</p>

<h1>考察</h1>

<p>どの質問までかを2分探索する．この探索に対してのvectorを作り，それぞれの区間に船が何個入るかを出す．区間を見たいので，端の0のn+1を追加する．この個数がkをこえるかこえないかで判断する．計算量は，探索でlog(n)，vectorのsortにn*log(n)かかるので，全体でO(n*log(n)<sup>2</sup>)．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n,k,a;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; a;

    int m;
    cin &gt;&gt; m;

    vector&lt;int&gt; v(m);
    rep(i,m) {
        cin &gt;&gt; v[i];
    }

    int l = 0,r = m+1;
    while(r - l &gt; 1) {
        int mid = (l+r)/2;
        vector&lt;int&gt; t(v.begin(),v.begin()+mid);

        t.push_back(0);
        t.push_back(n+1);
        sort(t.begin(),t.end());

        int cnt = 0;
        rep(j,t.size()-1) {
            int d = t[j+1] - t[j];
            cnt += d/(a+1);
        }

        if(cnt &gt;= k) {
            l = mid;
        }
        else {
            r = mid;
        }
    }

    if(l == m) cout &lt;&lt; -1 &lt;&lt; endl;
    else cout &lt;&lt; l+1 &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces314-div2c Geometric Progression]]></title>
    <link href="http://ry0u.github.io/blog/2015/08/06/codeforces314-div2c-geometric-progression/"/>
    <updated>2015-08-06T09:34:01+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/08/06/codeforces314-div2c-geometric-progression</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/567/problem/C">http://codeforces.com/contest/567/problem/C</a><br/>
N個の数字と比kが与えられる．比がkである長さ3の部分数列の数を求めたい．</p>

<h1>考察</h1>

<p>3つの等比数列の真ん中の値に注目する．注目している数をxと置くと，d = x/k，x，u = x*kの数列の数を知ることが出来れば良い．自分の前にあるdの要素数，自分の後ろにあるuの要素数の乗算で，今見ているxを含む部分数列の数が分かる．これをN個に対して全てやった．Nは最大2*10<sup>5</sup>のため，オーバーフローに注意する．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {

    ll n,k;
    cin &gt;&gt; n &gt;&gt; k;

    vector&lt;ll&gt; v(n);
    rep(i,n) {
        cin &gt;&gt; v[i];
    }

    map&lt;ll,ll&gt; mup;
    rep(i,n) {
        mup[v[i]]++;
    }

    map&lt;ll,ll&gt; mdown;

    ll ans = 0;

    rep(i,n) {
        mup[v[i]]--;
        if(v[i] % k == 0) {
            ll d = v[i]/k;
            ll u = v[i]*k;

            ans += mdown[d] * mup[u];
        }
        mdown[v[i]]++;
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces313-div2 Gerald's Hexagon]]></title>
    <link href="http://ry0u.github.io/blog/2015/07/25/codeforces313-div2-geralds-hexagon/"/>
    <updated>2015-07-25T17:40:19+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/07/25/codeforces313-div2-geralds-hexagon</id>
    <content type="html"><![CDATA[<p>六角形の辺の長さが時計回りの順番で与えられる．長さ1の正三角形がいくつあるかを求めよ．</p>

<h1>考察</h1>

<p>まずSample1を見る<br/>
<img src="/images/Codeforces313-div2/image1.png"><br/>
これは正六角形であるため，この中に正三角形は6個．これのまず大きな三角形としてみる．追加した三角形を青で表すと<br/>
<img src="/images/Codeforces313-div2/image2.png"></p>

<p>大きな三角形は高さをnとすると，n段目の高さは1 + (n-1)*2で計算できる．そして同じ計算方法で追加した3つの三角形を引く．これで計算できる．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int a,b,c,d,e,f;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f;

    int len = max(a+b+c,a+e+f);
    int ans = 0;
    int t = 1;

    rep(i,len) {
        ans += t;
        t += 2;
    }

    t = 1;
    rep(i,a) {
        ans -= t;
        t += 2;
    }

    t = 1;
    rep(i,c) {
        ans -= t;
        t += 2;
    }

    t = 1;
    rep(i,e) {
        ans -= t;
        t += 2;
    }

    cout &lt;&lt; ans &lt;&lt; endl;


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces312-div2C Amr and Chemistry]]></title>
    <link href="http://ry0u.github.io/blog/2015/07/15/codeforces312-div2c-amr-and-chemistry/"/>
    <updated>2015-07-15T03:38:42+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/07/15/codeforces312-div2c-amr-and-chemistry</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/558/problem/C">http://codeforces.com/contest/558/problem/C</a><br/>
N個のデータが与えられる．それぞれの値には*2，/2することが出来る．全ての要素を揃えるための最小手数を求めよ</p>

<h1>考察</h1>

<p>この操作による状態数はそんなに多くない(log(n)の何倍か(?))．各値を動かした時にカウントして最後にカウントがn個となっている最小値を答える．動かすのは幅で見て，コストを足していった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int d[100005];
bool used[100005];
int cnt[100005];

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; v(n);
    rep(i,n) cin &gt;&gt; v[i];

    rep(i,100005) d[i] = INF;
    memset(cnt,0,sizeof(cnt));

    rep(i,n) {
        memset(used,0,sizeof(used));
        used[v[i]] = true;
        if(d[v[i]] == INF) d[v[i]] = 0;
        cnt[v[i]]++;

        queue&lt;pair&lt;int,int&gt; &gt; que;
        que.push(mp(v[i],0));

        while(que.size()) {
            pair&lt;int,int&gt; p = que.front();
            que.pop();

            int f = p.first;
            int cost = p.second;

            int t = f/2;
            int t2 = f*2;

            if(0 &lt; t &amp;&amp; t &lt; 100005 &amp;&amp; !used[t]) {
                used[t] = true;
                cnt[t]++;
                if(d[t] == INF) d[t] = cost+1;
                else d[t] += cost+1;
                que.push(make_pair(t,cost+1));
            }

            if(0 &lt; t2 &amp;&amp; t2 &lt; 100005 &amp;&amp; !used[t2]) {
                used[t2] = true;
                cnt[t2]++;
                if(d[t2] == INF) d[t2] = cost+1;
                else d[t2] += cost+1;
                que.push(make_pair(t2,cost+1));
            }
        }

    }

    int ans = INF;
    rep(i,100005) {
        if(cnt[i] == n) ans = min(ans,d[i]);
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>コンテスト中，最後のほうでこの解法を思いついた．t，t2やその範囲でバグらせてしまい，時間内に提出できなかった．非常に悔しい(実力が足りない)．</p>
]]></content>
  </entry>
  
</feed>
