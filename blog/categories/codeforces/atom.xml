<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: codeforces | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/codeforces/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2015-07-26T13:40:59+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Codeforces313-div2 Gerald's Hexagon]]></title>
    <link href="http://ry0u.github.io/blog/2015/07/25/codeforces313-div2-geralds-hexagon/"/>
    <updated>2015-07-25T17:40:19+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/07/25/codeforces313-div2-geralds-hexagon</id>
    <content type="html"><![CDATA[<p>六角形の辺の長さが時計回りの順番で与えられる．長さ1の正三角形がいくつあるかを求めよ．</p>

<h1>考察</h1>

<p>まずSample1を見る<br/>
<img src="/images/Codeforces313-div2/image1.png"><br/>
これは正六角形であるため，この中に正三角形は6個．これのまず大きな三角形としてみる．追加した三角形を青で表すと<br/>
<img src="/images/Codeforces313-div2/image2.png"></p>

<p>大きな三角形は高さをnとすると，n段目の高さは1 + (n-1)*2で計算できる．そして同じ計算方法で追加した3つの三角形を引く．これで計算できる．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int a,b,c,d,e,f;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f;

    int len = max(a+b+c,a+e+f);
    int ans = 0;
    int t = 1;

    rep(i,len) {
        ans += t;
        t += 2;
    }

    t = 1;
    rep(i,a) {
        ans -= t;
        t += 2;
    }

    t = 1;
    rep(i,c) {
        ans -= t;
        t += 2;
    }

    t = 1;
    rep(i,e) {
        ans -= t;
        t += 2;
    }

    cout &lt;&lt; ans &lt;&lt; endl;


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces312-div2C Amr and Chemistry]]></title>
    <link href="http://ry0u.github.io/blog/2015/07/15/codeforces312-div2c-amr-and-chemistry/"/>
    <updated>2015-07-15T03:38:42+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/07/15/codeforces312-div2c-amr-and-chemistry</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/558/problem/C">http://codeforces.com/contest/558/problem/C</a><br/>
N個のデータが与えられる．それぞれの値には*2，/2することが出来る．全ての要素を揃えるための最小手数を求めよ</p>

<h1>考察</h1>

<p>この操作による状態数はそんなに多くない(log(n)の何倍か(?))．各値を動かした時にカウントして最後にカウントがn個となっている最小値を答える．動かすのは幅で見て，コストを足していった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int d[100005];
bool used[100005];
int cnt[100005];

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; v(n);
    rep(i,n) cin &gt;&gt; v[i];

    rep(i,100005) d[i] = INF;
    memset(cnt,0,sizeof(cnt));

    rep(i,n) {
        memset(used,0,sizeof(used));
        used[v[i]] = true;
        if(d[v[i]] == INF) d[v[i]] = 0;
        cnt[v[i]]++;

        queue&lt;pair&lt;int,int&gt; &gt; que;
        que.push(mp(v[i],0));

        while(que.size()) {
            pair&lt;int,int&gt; p = que.front();
            que.pop();

            int f = p.first;
            int cost = p.second;

            int t = f/2;
            int t2 = f*2;

            if(0 &lt; t &amp;&amp; t &lt; 100005 &amp;&amp; !used[t]) {
                used[t] = true;
                cnt[t]++;
                if(d[t] == INF) d[t] = cost+1;
                else d[t] += cost+1;
                que.push(make_pair(t,cost+1));
            }

            if(0 &lt; t2 &amp;&amp; t2 &lt; 100005 &amp;&amp; !used[t2]) {
                used[t2] = true;
                cnt[t2]++;
                if(d[t2] == INF) d[t2] = cost+1;
                else d[t2] += cost+1;
                que.push(make_pair(t2,cost+1));
            }
        }

    }

    int ans = INF;
    rep(i,100005) {
        if(cnt[i] == n) ans = min(ans,d[i]);
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>コンテスト中，最後のほうでこの解法を思いついた．t，t2やその範囲でバグらせてしまい，時間内に提出できなかった．非常に悔しい(実力が足りない)．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces311-div2C Arthur and Table]]></title>
    <link href="http://ry0u.github.io/blog/2015/07/12/codeforces311-div2c-arthur-and-table/"/>
    <updated>2015-07-12T23:17:25+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/07/12/codeforces311-div2c-arthur-and-table</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/557/problem/C">http://codeforces.com/contest/557/problem/C</a><br/>
<script type="math/tex">N本の足を持つテーブルがあり，各足には長さl<em>{i}と取り除くコストd</em>{i}が与えられる．</script>
足の長さがバラバラなのでこれを安定状態にしたい．安定状態になるには足の最大の長さの本数が全体の本数の半分より多ければよい．その時の最小のコストを求める．</p>

<p>Sampleを考える．長さ1を1マスとし，文字がコストを表す．取り除いた足を赤色で表現する．</p>

<p>Sample1<br/>
<img src="/images/Codeforces311-div2/image1.png"><br/>
長さ5を取り除くほうがコストが安い</p>

<p>Sample2<br/>
<img src="/images/Codeforces311-div2/image2.png"><br/>
既に安定状態である</p>

<p>Sample3<br/>
<img src="/images/Codeforces311-div2/image3.png"><br/>
長さ2に揃える．長さ3は全て取り除き，個数が半分より多くなるように長さ1を1つ取り除く．</p>

<h1>考察</h1>

<p>どの長さで揃えるかを探索する．仮に揃える長さをLと決めた場合，全体のコストの和からLを引き，後は長さLの足の個数-1個分残すようにすればよいとわかる．長さでsortし小さい順から見ていけば，その処理ができる．</p>

<p>揃える長さを緑とした時に，赤の部分は全て取り除くことになる．
<img src="/images/Codeforces311-div2/image4.png"><br/>
後は緑より小さい足を緑の個数より少なくすればよい．出来るだけコストを抑えたいのでコストが大きい棒を残すようにする．よって全体のコストの和-揃える長さ-(それより長さが短い足をコストの大きい順に個数が少なくなるまで)で求める．</p>

<h1>Code</h1>

<p>コストが大きい順に見たいためpriority_queueを用いて大きい順に取った．最初は小さい順からとってしまい．WAを生やした．mapを使っているからidなどを作らずにmap巡回をしたほうがより分かりやすい(?)．</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; L(n),D(n);
    rep(i,n) cin &gt;&gt; L[i];
    rep(i,n) cin &gt;&gt; D[i];

    vector&lt;int&gt; id(L.begin(),L.end());
    sort(id.begin(),id.end());
    id.erase(unique(id.begin(),id.end()),id.end());

    int sum = 0;
    map&lt;int,vector&lt;int&gt; &gt; m;
    rep(i,n) {
        m[L[i]].push_back(D[i]);
        sum += D[i];
    }

    int ans = sum;
    priority_queue&lt;int&gt; que;
    rep(i,id.size()) {
        vector&lt;int&gt; v(m[id[i]].begin(),m[id[i]].end());
        int res = sum;
        int cnt = v.size()-1;

        rep(j,v.size()) res -= v[j];

        vector&lt;int&gt; t;
        while(que.size() &amp;&amp; cnt) {
            int q = que.top();
            que.pop();

            res -= q;
            t.push_back(q);
            cnt--;
        }

        ans = min(ans,res);

        rep(j,t.size()) que.push(t[j]);
        rep(j,v.size()) que.push(v[j]);
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
