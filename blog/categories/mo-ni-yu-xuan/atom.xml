<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 模擬予選 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/mo-ni-yu-xuan/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-04-27T23:36:02+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JAG Contest 2016 Domestic C みさわさんの根付き木]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/27/jag-contest-2016-domestic-c-misawasanfalsegen-fu-kimu/"/>
    <updated>2016-04-27T23:21:58+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/27/jag-contest-2016-domestic-c-misawasanfalsegen-fu-kimu</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://jag2016-domestic.contest.atcoder.jp/tasks/jag2016secretspring_c">C: みさわさんの根付き木 - JAG Contest 2016 Domestic | AtCoder</a></h4><p>(null)</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>


<p>最初に，完全2分木にして配列を用いて表せば実装簡単だと思い，書き始めたが深さが大きい時に対応出来ないことに気づき，配列ではなくmapにした．一応書き終わり，サンプルを試している内にそもそもこの方法ではノード番号がlong longで収まり切らないことに気づいた．<br/>
次に純粋に文字列を木に直して，rootからmergeしていく方法にしてACが取れた．正しい方針が立てれずに時間を無駄にしてしまったので反省したい．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;

#define REP(i, k, n) for(int i = k; i &lt; n; i++) 
#define rep(i, n) for(int i = 0; i &lt; n; i++) 

using namespace std;

struct Tree {
    int v;
    Tree* left;
    Tree* right;

    Tree(int v) : v(v) {}
};

void f(string s, Tree* node) {
    string t = "";
    REP(i, 1, s.size()-1) {
        t += s[i];
    }

    if(t == "") return;
    s = t;

    int root = 0, sum = 0;
    string left = "";

    int i = 0;
    for(i = 0; i &lt; s.size(); i++) {
        left += s[i];

        if(s[i] == '(') sum++;
        else if(s[i] == ')') sum--;

        if(sum == 0){
            stringstream ss;
            i += 2;
            REP(j, i, s.size()) {
                if(s[j] == ']') {
                    i++;
                    break;
                } else {
                    ss &lt;&lt; s[j];
                    i++;
                }
            }
            ss &gt;&gt; root;
            node-&gt;v = root;
            break;
        }
    }

    string right = "";
    for(; i &lt; s.size(); i++) {
        right += s[i];
    }

    node-&gt;left = new Tree(-1);
    f(left, node-&gt;left);

    node-&gt;right = new Tree(-1);
    f(right, node-&gt;right);
}

void merge(Tree* res, Tree* node, Tree* node2) {
    res-&gt;v = node-&gt;v + node2-&gt;v;
    // cout &lt;&lt; "-------- merge:" &lt;&lt; res-&gt;v &lt;&lt; " " &lt;&lt; node-&gt;v &lt;&lt; " " &lt;&lt; node2-&gt;v &lt;&lt; endl;

    res-&gt;left = new Tree(-1);
    if(node-&gt;left != NULL &amp;&amp; node-&gt;left-&gt;v != -1 &amp;&amp; node2-&gt;left != NULL &amp;&amp; node2-&gt;left-&gt;v != -1) {
        merge(res-&gt;left, node-&gt;left, node2-&gt;left);
    }

    res-&gt;right = new Tree(-1);
    if(node-&gt;right != NULL &amp;&amp; node-&gt;right-&gt;v != -1 &amp;&amp; node2-&gt;right != NULL &amp;&amp; node2-&gt;right-&gt;v != -1) {
        merge(res-&gt;right, node-&gt;right, node2-&gt;right);
    }
}

string dfs(Tree* res) {
    if(res-&gt;v == -1) {
        return "()";
    }

    stringstream ss;
    ss &lt;&lt; res-&gt;v;
    return "(" + dfs(res-&gt;left) + "[" + ss.str() + "]" + dfs(res-&gt;right) + ")";
}

// void dfs(Tree* res) {
//  cout &lt;&lt; " --- in dfs --- " &lt;&lt; res-&gt;v &lt;&lt; endl;
//  if(res-&gt;v == -1) {
//      cout &lt;&lt; "()";
//      return;
//  }
//
//  cout &lt;&lt; "(";
//  if(res-&gt;left != NULL) dfs(res-&gt;left);
//  cout &lt;&lt; "[" &lt;&lt; res-&gt;v &lt;&lt; "]" &lt;&lt; endl;
//  if(res-&gt;right != NULL) dfs(res-&gt;right);
//  cout &lt;&lt; ")";
//  return;
// }

int main() {
    string s, t;
    cin &gt;&gt; s &gt;&gt; t;

    s = "(" + s + ")";
    t = "(" + t + ")";

    Tree *root = new Tree(-1);
    f(s, root);

    Tree *root2 = new Tree(-1);
    f(t, root2);

    Tree *res = new Tree(-1);
    merge(res, root, root2);

    string ret = dfs(res);

    // 最後の()を取る.
    REP(i, 1, ret.size()-1) {
        cout &lt;&lt; ret[i];
    }
    cout &lt;&lt; endl;


    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
