<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 模擬予選 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/mo-ni-yu-xuan/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-09-03T02:19:57+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JAG Contest 2016 DomesticB E ぼくのかんがえたさいきょうのおふとん]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/17/jag-contest-domesticb-e-bokufalsekangaetasaikiyoufalseohuton/"/>
    <updated>2016-06-17T17:23:13+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/17/jag-contest-domesticb-e-bokufalsekangaetasaikiyoufalseohuton</id>
    <content type="html"><![CDATA[<!-- more -->

最適なおふとんの並べ方が分かっていたとすると，おふとんを一番上から連続して使うことしか出来ないので，$M$日間のぬくもり需要$d_j$の順番は関係なくなる．sort後は$d\_i < d\_{i+1}$となっていて，$d\_{i+1}$の最小は$d_i$で最小であったおふとんの並び方に新しくおふとんを追加するかしないか，となる．

$$
	dp[i][j] := i日目まででおふとん集合jの時の最小値
$$

として，動的計画法．集合$j$の部分集合のminと考えるのではなく，集合$j$に要素を一個加えたものを更新する．

## Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <bitset>

#define REP(i, k, n) for(int i = k; i < n; i++)
#define rep(i, n) for(int i = 0; i < n; i++)
#define INF 1<<30

using namespace std;
typedef long long ll;

ll dp[105][1<<15];
ll res[1<<15];

int main() {
	int n, m;
	while(cin >> n >> m) {
		if(n == 0 && m == 0) break;

		vector<ll> s(n), d(m);
		rep(i, n) cin >> s[i];
		rep(i, m) cin >> d[i];

		sort(d.begin(), d.end());

		rep(i, 105) rep(j, 1<<15) dp[i][j] = INF;
		rep(j, 1<<15) dp[0][j] = 0;

		rep(i, m) {
			ll val = INF;
			rep(j, 1<<n) {
				ll sum = 0;
				rep(k, n) {
					if(j & (1<<k)) {
						sum += s[k];
					}
				}

				rep(k, n) {
					if(j & (1<<k)) continue;
					dp[i][j | (1<<k)] = min(dp[i][j | (1<<k)], dp[i][j]);
				}

				dp[i+1][j] = min(dp[i+1][j], dp[i][j] + abs(d[i] - sum));
			}
		}

		ll ans = INF;
		rep(j, 1<<n) {
			ans = min(ans, dp[m][j]);
		}

		cout << ans << endl;
	}
	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAG Contest 2016 DomesticB D 夏合宿の朝は早い]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/17/jag-contest-2016-domesticb-d-xia-he-su-falsezhao-hazao-i/"/>
    <updated>2016-06-17T17:13:18+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/17/jag-contest-2016-domesticb-d-xia-he-su-falsezhao-hazao-i</id>
    <content type="html"><![CDATA[<!-- more -->

強連結成分分解した後，各連結成分の始点が全て起きている確立の積を求める．始点が起きている確立は，$1 - $その強連結成分のノード番号に属するノードが全員起きていない確立で求まる．始点かどうかは，強連結成分分解後のグラフのノードの自分に向いている辺の個数が$0$であればよいのでカウントしていった．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <set>

#define REP(i, k, n) for(int i = k; i < n; i++)
#define rep(i, n) for(int i = 0; i < n; i++)

using namespace std;

struct SCC {
	int n;
	vector<vector<int> > g, rg, ng, scc;
	vector<int> res;
	bool used[105];

	SCC(int _n) {
		n = _n;
		g.resize(n); rg.resize(n); scc.resize(n); res.resize(n);
	}

	void add(int i, int j) {
		g[i].push_back(j);
		rg[j].push_back(i);
	}

	vector<int> vs;
	void dfs(int v) {
		used[v] = true;
		rep(i, g[v].size()) {
			if(!used[ g[v][i] ]) dfs(g[v][i]);
		}
		vs.push_back(v);
	}

	void rdfs(int v, int k) {
		used[v] = true;
		res[v] = k;
		scc[k].push_back(v);

		rep(i, rg[v].size()) {
			if(!used[ rg[v][i] ]) rdfs(rg[v][i], k);
		}
	}

	void ng_make(int k) {
		ng.resize(k);

		rep(i, n) {
			set<int> S;
			rep(j, g[i].size()) {
				int to = g[i][j];
				if(res[i] == res[to]) continue;
				if(S.find(res[to]) != S.end()) continue;
				ng[res[i]].push_back(res[to]);
				S.insert(res[to]);
			}
		}
	}

	int build() {
		memset(used, 0, sizeof(used));
		rep(i, n) {
			if(!used[i]) dfs(i);
		}

		memset(used, 0, sizeof(used));
		int k = 0;
		for(int i = vs.size()-1; i >= 0; i--) {
			if(!used[vs[i]]) rdfs(vs[i], k++);
		}

		ng_make(k);
		return k;
	}
};

int main() {
	int n;
	while(cin >> n && n) {
		vector<double> v(n);
		SCC scc(n);

		rep(i, n) {
			int x;
			cin >> v[i] >> x;

			rep(j, x) {
				int a;
				cin >> a;
				
				a--;
				scc.add(i, a);
			}
		}

		int k = scc.build();
		vector<vector<int> > g = scc.ng;

		int cnt[105];
		memset(cnt, 0, sizeof(cnt));

		rep(i, k) {
			rep(j, g[i].size()) {
				cnt[g[i][j]]++;
			}
		}

		double ans = 1.0;
		rep(i, k) {
			if(cnt[i] != 0) continue;
			double t = 1.0;
			rep(j, scc.scc[i].size()) {
				int u = scc.scc[i][j];
				t *= v[u];
			}

			ans *= (1.0 - t);
		}

		cout << fixed;
		cout.precision(20);
		cout << ans << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAG Contest 2016 Domestic D インビジブル]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/27/jag-contest-2016-domestic-d-inbiziburu/"/>
    <updated>2016-04-27T23:39:09+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/27/jag-contest-2016-domestic-d-inbiziburu</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article"><h4><a href="http://jag2016-domestic.contest.atcoder.jp/tasks/jag2016secretspring_d">D: インビジブル - JAG Contest 2016 Domestic | AtCoder</a></h4><p>(null)</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

状態を({% m %} a {% em %}のデッキから何枚取ったか， {% m %} b {% em %}のデッキから何枚取ったか，場のスタック，何ターン目，前回のスタックが空の状態でパスをしたかどうか)にしてメモ化再帰．minimaxみたいな感じでプレイヤー {% m %} 1 {% em %}のターンでは {% m %} c - d {% em %}の最大化，プレイヤー {% m %} 2 {% em %}のターンでは {% m %} c - d {% em %}の最小化をした．  

本番では，メモ化するときに，stackの状態を持たねばならないと思っていたが，スタックのサイズだけを持てば良いことに気付けなかった．スタックが空の状態で無くてもパスパスをした時点で終了だと思い込んでいた．

# Code

```cpp
#include <iostream>
#include <sstream>
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
#include <map>
#include <stack>

#define REP(i, k, n) for(int i = k; i < n; i++) 
#define rep(i, n) for(int i = 0; i < n; i++) 
#define INF 1<<30

using namespace std;
typedef pair<int, int> P;

int n, m;
vector<int> a, b;

int f(stack<P> &st) {
	int c = 0, d = 0;
	bool cf = true, df = true;
	while(st.size()) {
		P p = st.top(); st.pop();
		if(p.first == 0) {
			if(p.second == -1) {
				df = false;
			} else if(cf) {
				c += p.second;
			}
		} else {
			if(p.second == -1) {
				cf = false;
			} else if(df) {
				d += p.second;
			}
		}
	}
	return c - d;
}

int memo[55][55][2][2][105];

int dfs(int i, int j, stack<P> st, int turn, bool flag) {
	if(memo[i][j][turn % 2][flag][st.size()] != INF) return memo[i][j][turn % 2][flag][st.size()];

	int ret = 0, size = st.size();
	if(flag) {
		if(turn % 2 == 0) {
			ret = 0;
			if(i != n) {
				st.push(P(0, a[i]));
				ret = max(ret, dfs(i + 1, j, st, turn + 1, false));
				st.pop();
			}
		} else {
			ret = 0;
			if(j != m) {
				st.push(P(1, b[j]));
				ret = min(ret, dfs(i, j + 1, st, turn + 1, false));
				st.pop();
			}
		}
	} else {
		if(turn % 2 == 0) {
			ret = -INF;
			if(i != n) {
				st.push(P(0, a[i]));
				ret = max(ret, dfs(i + 1, j, st, turn + 1, false));
				st.pop();
			}

			bool ch = (st.size() == 0);
			int d = f(st);
			ret = max(ret, dfs(i, j, st, turn + 1, ch) + d);
		} else {
			ret = INF;

			if(j != m) {
				st.push(P(1, b[j]));
				ret = min(ret, dfs(i, j + 1, st, turn + 1, false));
				st.pop();
			}

			bool ch = (st.size() == 0);
			int d = f(st);
			ret = min(ret, dfs(i, j, st, turn + 1, ch) + d);
		}
	}

	return memo[i][j][turn % 2][flag][size] = ret;
}

int main() {
	cin >> n >> m;

	a.resize(n);
	rep(i, n) cin >> a[i];

	b.resize(m);
	rep(i, m) cin >> b[i];

	stack<P> st;
	rep(i, 55) rep(j, 55) rep(k, 2) rep(l, 2) rep(o, 105) memo[i][j][k][l][o] = INF;
	cout << dfs(0, 0, st, 0, false) << endl;
	return 0;
}

```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAG Contest 2016 Domestic C みさわさんの根付き木]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/27/jag-contest-2016-domestic-c-misawasanfalsegen-fu-kimu/"/>
    <updated>2016-04-27T23:21:58+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/27/jag-contest-2016-domestic-c-misawasanfalsegen-fu-kimu</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://jag2016-domestic.contest.atcoder.jp/tasks/jag2016secretspring_c">C: みさわさんの根付き木 - JAG Contest 2016 Domestic | AtCoder</a></h4><p>(null)</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

最初に，完全2分木にして配列を用いて表せば実装簡単だと思い，書き始めたが深さが大きい時に対応出来ないことに気づき，配列ではなくmapにした．一応書き終わり，サンプルを試している内にそもそもこの方法ではノード番号がlong longで収まり切らないことに気づいた．  
次に純粋に文字列を木に直して，rootからmergeしていく方法にしてACが取れた．正しい方針が立てれずに時間を無駄にしてしまったので反省したい．


# Code

```cpp
#include <iostream>
#include <sstream>
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
#include <map>

#define REP(i, k, n) for(int i = k; i < n; i++) 
#define rep(i, n) for(int i = 0; i < n; i++) 

using namespace std;

struct Tree {
	int v;
	Tree* left;
	Tree* right;

	Tree(int v) : v(v) {}
};

void f(string s, Tree* node) {
	string t = "";
	REP(i, 1, s.size()-1) {
		t += s[i];
	}

	if(t == "") return;
	s = t;

	int root = 0, sum = 0;
	string left = "";

	int i = 0;
	for(i = 0; i < s.size(); i++) {
		left += s[i];

		if(s[i] == '(') sum++;
		else if(s[i] == ')') sum--;

		if(sum == 0){
			stringstream ss;
			i += 2;
			REP(j, i, s.size()) {
				if(s[j] == ']') {
					i++;
					break;
				} else {
					ss << s[j];
					i++;
				}
			}
			ss >> root;
			node->v = root;
			break;
		}
	}

	string right = "";
	for(; i < s.size(); i++) {
		right += s[i];
	}

	node->left = new Tree(-1);
	f(left, node->left);

	node->right = new Tree(-1);
	f(right, node->right);
}

void merge(Tree* res, Tree* node, Tree* node2) {
	res->v = node->v + node2->v;
	// cout << "-------- merge:" << res->v << " " << node->v << " " << node2->v << endl;

	res->left = new Tree(-1);
	if(node->left != NULL && node->left->v != -1 && node2->left != NULL && node2->left->v != -1) {
		merge(res->left, node->left, node2->left);
	}

	res->right = new Tree(-1);
	if(node->right != NULL && node->right->v != -1 && node2->right != NULL && node2->right->v != -1) {
		merge(res->right, node->right, node2->right);
	}
}

string dfs(Tree* res) {
	if(res->v == -1) {
		return "()";
	}

	stringstream ss;
	ss << res->v;
	return "(" + dfs(res->left) + "[" + ss.str() + "]" + dfs(res->right) + ")";
}

int main() {
	string s, t;
	cin >> s >> t;

	s = "(" + s + ")";
	t = "(" + t + ")";

	Tree *root = new Tree(-1);
	f(s, root);
	
	Tree *root2 = new Tree(-1);
	f(t, root2);
	
	Tree *res = new Tree(-1);
	merge(res, root, root2);
	
	string ret = dfs(res);

	// 最後の()を取る.
	REP(i, 1, ret.size()-1) {
		cout << ret[i];
	}
	cout << endl;


	return 0;
}

```


]]></content>
  </entry>
  
</feed>
