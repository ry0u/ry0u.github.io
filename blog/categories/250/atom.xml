<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 250 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/250/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-09-03T02:19:57+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ2331 A Way to Invite Friends]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/14/aoj2331-a-way-to-invite-friends/"/>
    <updated>2016-05-14T23:45:52+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/14/aoj2331-a-way-to-invite-friends</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2331">A Way to Invite Friends | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

各友だちの，嫌がらない海に行く人数の範囲( {% m %} a_i 〜 b_i {% em %})が与えられる．海に誘える最大人数を求める．  
海に行く人数には「わたし」も含まれるので {% m %} i {% em %}人誘えるかは， {% m %} i+1 {% em %}人で海に行くことを嫌がらない友だちの数が {% m %} i {% em %}人以上いるか，となるのでいもす法で累積和を取って順番に見ていった．


# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int n;
	cin >> n;

	int imos[100005];
	memset(imos, 0, sizeof(imos));

	rep(i, n) {
		int a, b;
		cin >> a >> b;

		imos[a]++;
		imos[b+1]--;
	}

	REP(i, 1, 100005) {
		imos[i] += imos[i-1];
	}

	int ans = 0;
	rep(i, 100005) {
		if(imos[i+1] >= i) {
			ans = i;
		}
	}

	cout << ans << endl;

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2620 Trodden Cable]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj2620-trodden-cable/"/>
    <updated>2016-03-22T21:52:44+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj2620-trodden-cable</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2620">Trodden Cable</a></h4><p>Nathan O. Davis is running a company. His company owns a web service which has a lot of users. So his office is full of servers, routers and messy LAN cables. He is now very puzzling over the messy cables, because they are causing many kinds of problems. For example, staff working at the company often trip over a cable.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

全く分からずに調べた．

http://acm-icpc.aitea.net/index.php?plugin=attach&refer=2013%2FPractice%2F%E5%A4%8F%E5%90%88%E5%AE%BF%2F%E8%AC%9B%E8%A9%95&openfile=trodden_cable.pdf:image=http://acm-icpc.aitea.net/index.php?plugin=attach&refer=2013%2FPractice%2F%E5%A4%8F%E5%90%88%E5%AE%BF%2F%E8%AC%9B%E8%A9%95&openfile=trodden_cable.pdf  

この画像が非常に分かりやすい．移動する時にまたがる線のコストを{% m %} +1 {% em %}して，移動が終わったグリッドグラフでdijkstra．  

現在位置を(y, x)と置くと  

* {% m %} R {% em %}の時， {% m %} (y, x+1) \to (y+1, x+1) {% em %}
* {% m %} L {% em %}の時， {% m %} (y, x) \to (y+1, x) {% em %}
* {% m %} U {% em %}の時， {% m %} (y, x) \to (y, x+1) {% em %}
* {% m %} D {% em %}の時， {% m %} (y+1, x) \to (y+1, x+1) {% em %}

に {% m %} +1 {% em %}した．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int w, h, n;
int sx,sy,gx,gy;
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1};

bool can(int y, int x) {
	if(0 <= y && y < h && 0 <= x && x < w) return true;
	return false;
}

struct edge {
	int from,to;
	ll cost;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int f,int t,int c) : from(f),to(t),cost(c) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

vector<edge> G[505*505 + 5];
ll d[505 * 505 + 5];

void dijkstra(int s, int n) {
	priority_queue<P, vector<P>, greater<P> > que;
	fill(d, d+n, INF);

	d[s] = 0;
	que.push(P(0,s));

	while(que.size()) {
		P p = que.top();
		que.pop();

		int v = p.second;
		if(d[v] < p.first) continue;

		rep(i, G[v].size()) {
			edge e = G[v][i];
			if(d[e.to] > d[v] + e.cost) {
				d[e.to] = d[v] + e.cost;
				que.push(P(d[e.to],e.to));
			}
		}
	}
}

int main() {
	cin >> w >> h >> n;

	cin >> sx >> sy >> gx >> gy;

	rep(i, h * w) {
		G[i].clear();
	}

	w++;
	h++;

	rep(i, h) {
		rep(j, w) {
			rep(k, 4) {
				int y = i + dy[k];
				int x = j + dx[k];

				if(can(y, x)) {
					G[i*w + j].push_back(edge(y*w + x, 0));
				}
			}
		}
	}

	rep(i, n) {
		int y, x, t;
		cin >> x >> y >> t;

		string s;
		cin >> s;

		rep(k, t) {
			rep(j, s.size()) {
				int from = -1, to = -1;
				if(s[j] == 'R' && x + 1 < w - 1) {
					from = y * w + (x + 1);
					to = (y + 1) * w + (x + 1);
					x++;
				} else if(s[j] == 'L' && 0 <= x - 1) {
					from = y * w + x;
					to = (y + 1) * w + x;
					x--;
				} else if(s[j] == 'U' && 0 <= y - 1) {
					from = y * w + x;
					to = y * w + (x + 1);
					y--;
				} else if(s[j] == 'D' && y + 1 < h - 1) {
					from = (y + 1) * w + x;
					to = (y + 1) * w + (x + 1);
					y++;
				}

				if(from == -1 && to == -1) continue;
				rep(k, G[from].size()) {
					if(G[from][k].to == to) {
						G[from][k].cost++;
					}
				}
				rep(k, G[to].size()) {
					if(G[to][k].to == from) {
						G[to][k].cost++;
					}
				}
			}
		}
	}

	// rep(i, h) {
	// 	rep(j, w) {
	// 		cout << " --------- " << i << ", " << j << " :" << i * w + j << " |";
	// 		rep(k, G[i*w + j].size()) {
	// 			cout << "(" << G[i*w + j][k].to << ", " << G[i*w + j][k].cost << ") ";
	// 		}
	// 		cout << endl;
	// 	}
	// }

	dijkstra(sy * w + sx, h * w);

	// rep(i, h) {
	// 	rep(j, w) {
	// 		cout << d[i*w + j] << " ";
	// 	}
	// 	cout << endl;
	// }

	cout << d[gy * w + gx] << endl;

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2641 Magic Bullet]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj2641-magic-bullet/"/>
    <updated>2016-03-22T21:29:19+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj2641-magic-bullet</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2641">Magic Bullet | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

点{% m %} (sx, sy, sz) {% em %}，点 {% m %} (dx, dy, dz) {% em %}を結ぶ線分が{% m %} N {% em %}個の球と交差しているかを見る．それぞれの球の中心から直線への射影を出す．その点が線分に収まっていて，球の中心との距離がr以内なら交差しているとした．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair
#define EPS 1e-8
#define equals(a,b) fabs((a) - (b)) < EPS

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

struct Point3D {
	double x, y, z;

	Point3D() : x(0), y(0), z(0) {}

	Point3D(double x, double y, double z) : x(x), y(y), z(z) {}

	Point3D operator+(const Point3D &o) const { return Point3D(x+o.x, y+o.y, z+o.z); }

	Point3D operator-(const Point3D &o) const { return Point3D(x-o.x, y-o.y, z-o.z); }

	Point3D operator*(const double m) const { return Point3D(x*m, y*m, z*m); }

	Point3D operator/(const double d) const { return Point3D(x/d, y/d, z/d); }

	bool operator==(const Point3D &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }
};

ostream& operator << (ostream& os, const Point3D& p) {
	os << "(" << p.x << ", " << p.y << ", " << p.z << ")";
	return os;
}

double dot(Point3D a, Point3D b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
Point3D cross(Point3D a, Point3D b) { return Point3D(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x); }

double norm(Point3D p) { return dot(p, p); }
double abs(Point3D p) { return sqrt(norm(p)); }

struct Line {
	Point3D a, b;

	Line() : a(Point3D(0, 0, 0)), b(Point3D(0, 0, 0)) {}

	Line(Point3D a, Point3D b) : a(a), b(b) {}
};

ostream& operator << (ostream& os, const Line& l) {
	os << "(" << l.a.x << ", " << l.a.y << ", " << l.a.z <<  ")-(" << l.b.x << "," << l.b.y << ", " << l.b.z <<  ")";
	return os;
}

Point3D project(Line l, Point3D p) {
	Point3D base = l.b - l.a;
	double t = dot(base, p-l.a) / dot(base, base);
	return l.a + base * t;
}

struct Ball {
	Point3D p;
	double r;

	Ball() : p(Point3D(0, 0, 0)), r(0.0) {}

	Ball(Point3D p, double r) : p(p), r(r) {}
};

ostream& operator << (ostream& os, const Ball& b) {
	os << "(" << b.p.z << ", " << b.p.y << ", " << b.p.z << " :" << b.r << ")";
	return os;
}

int main() {
	int n, q;
	cin >> n >> q;

	vector<Ball> v(n);
	vector<ll> cost(n);
	rep(i, n) {
		cin >> v[i].p.x >> v[i].p.y >> v[i].p.z >> v[i].r >> cost[i];
	}

	rep(i, q) {
		ll ans = 0;
		Point3D s, t;
		cin >> s.x >> s.y >> s.z >> t.x >> t.y >> t.z;

		Line line(s, t);

		rep(j, n) {
			Point3D proj = project(line, v[j].p);

			if(abs(line.b - line.a) >= abs(proj - line.a) && abs(line.a - line.b) >= abs(proj - line.b)) {
				if(abs(proj - v[j].p) < v[j].r + EPS) {
					ans += cost[j];
				}
			}
		}

		cout << ans << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1250 Leaky Cryptography]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj1250-leaky-cryptography/"/>
    <updated>2016-03-22T21:00:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj1250-leaky-cryptography</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1250">Leaky Cryptography</a></h4><p>The ACM ICPC judges are very careful about not leaking their problems, and all communications are encrypted. However, one does sometimes make mistakes, like using too weak an encryption scheme. Here is an example of that. The encryption chosen was very simple: encrypt each chunk of the input by flipping some bits according to a shared key.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

一番下の桁から順番に決めていく．今までの {% m %} \rm{sum} {% em %}の {% m %} i {% em %}桁目と {% m %} N_1 〜 N_8{% em %}の{% m %} i {% em %}桁の和が {% m %} N_9 {% em %}の {% m %} i {% em %}桁と一致しているかを見る．一致していない場合に， {% m %} 8 {% em %}つの{% m %} i {% em %}桁目を反転して，答えの {% m %} i {% em %}桁目のビットを立てる．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <bitset>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

ll f(string s) {
	ll res = 0, t = 1;

	for(int i = s.size()-1; i >= 0; i--) {
		if('0' <= s[i] && s[i] <= '9') {
			res += (s[i] - '0') * t;
		} else {
			res += (10 + (s[i] - 'a')) * t;
		}
		t *= 16;
	}
	return res;
}

int main() {
	int n;
	cin >> n;

	rep(q, n) {
		vector<string> v(9);
		vector<ll> t(9);
		rep(i, 9) {
			cin >> v[i];
			t[i] = f(v[i]);
		}

		ll ans = 0;

		vector< vector<int> > bit(9, vector<int>(32));
		rep(i, 9) {
			rep(j, 32) {
				if(t[i] & (1LL << j)) {
					bit[i][j] = 1;
				}
			}
		}

		ans = 0;
		ll sum = 0;
		rep(i, 32) {
			ll d = 0;
			rep(j, 8) {
				d += bit[j][i];
			}
			bitset<32> ss(sum);

			if( ((((sum >> i) & 1) + d) & 1) == bit[8][i]) {
				sum += (d << i);
			} else {
				d = 0;
				rep(j, 8) {
					d += bit[j][i] ^ 1;
				}
				sum += (d << i);
				ans += (1LL << i);
			}
		}

		cout << hex << ans << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1325 Bit String Recordering]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj1325-bit-string-recordering/"/>
    <updated>2016-03-22T20:46:04+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj1325-bit-string-recordering</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1345">Bit String Reordering | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

連続するビット列の数が与えられる．最初を {% m %} 0 {% em %}にする， {% m %} 1 {% em %}にするの {% m %} 2 {% em %}パターンをシュミレーション(左端から決めていき，違ったら右から持ってくる)して，swap回数の小さい方を出力した．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int n, m;
	cin >> n >> m;

	vector<int> a(n), b(m);
	rep(i, n) cin >> a[i];
	rep(i, m) cin >> b[i];


	vector<int> c, d;
	rep(i, m) {
		rep(j, b[i]) {
			if(i & 1) {
				c.push_back(1);
				d.push_back(0);
			} else {
				c.push_back(0);
				d.push_back(1);
			}
		}
	}

	int ans = INF, res = 0;
	vector<int> t(a.begin(), a.end());
	rep(i, n) {
		if(t[i] == c[i]) continue;

		REP(j, i+1, n) {
			if(c[i] == t[j]) {
				for(int k = j; k-1 >= i; k--) {
					swap(t[k], t[k-1]);
					res++;
				}
				break;
			}
		}
	}

	bool flag = true;
	rep(i, n) {
		if(t[i] == c[i]) continue;
		flag = false;
	}

	if(flag) {
		ans = min(ans, res);
	}

	res = 0;
	rep(i, n) t[i] = a[i];

	rep(i, n) {
		if(t[i] == d[i]) continue;

		REP(j, i+1, n) {
			if(d[i] == t[j]) {
				for(int k = j; k-1 >= i; k--) {
					swap(t[k], t[k-1]);
					res++;
				}
				break;
			}

		}
	}

	flag = true;
	rep(i, n) {
		if(t[i] == d[i]) continue;
		flag = false;
	}

	if(flag) {
		ans = min(ans, res);
	}

	cout << ans << endl;

	return 0;
}
```

]]></content>
  </entry>
  
</feed>
