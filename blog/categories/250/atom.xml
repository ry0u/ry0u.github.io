<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 250 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/250/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-20T23:38:16+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ1325 Ginkgo Numbers]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/20/aoj1325-ginkgo-numbers/"/>
    <updated>2016-03-20T23:11:37+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/20/aoj1325-ginkgo-numbers</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1325">Ginkgo Numbers</a></h4><p>We will define Ginkgo numbers and multiplication on Ginkgo numbers. A Ginkgo number is a pair where m and n are integers. For example, , and are Ginkgo numbers. A Ginkgo number is called a prime if m 2+ n 2 > 1 and it has exactly eight divisors.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>与えられている <script type="math/tex"> 2 </script>個目の性質だけを使った． <script type="math/tex"> m ^2 + n ^2 </script>を割り切れる数が <script type="math/tex"> x ^2 + y ^2 </script>という形で表せるか，という問題になり</p>

<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://mathtrain.jp/twosquare">フェルマーの二平方和定理 | 高校数学の美しい物語</a></h4><p>整数論の美しい定理であるフェルマーの二平方和定理を解説します。平方剰余などの議論を用いた証明。</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>


<p>この記事通りに，素因数の<script type="math/tex"> 4k + 3 </script>型の指数が全て偶数かどうかを見て判断する． <script type="math/tex"> 1 </script>と <script type="math/tex"> m ^2 + n ^2 </script>以外に存在するか，ということで合計して<script type="math/tex"> 3 </script>つ以上あれば<script type="math/tex"> C </script>となる．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

map&lt;ll,ll&gt; prime_factor(ll n) {
    map&lt;ll,ll&gt; res;
    for(ll i=2; i*i &lt;= n; i++) {
        while(n%i == 0) {
            res[i]++;
            n /= i;
        }
    }

    if(n != 1) res[n] = 1;
    return res;
}

int main() {
    int n;
    cin &gt;&gt; n;

    rep(i, n) {
        int m, n;
        cin &gt;&gt; m &gt;&gt; n;

        int s = m * m + n * n;
        int cnt = 0;

        REP(i, 1, s + 1) {
            if(s % i == 0) {
                map&lt;ll, ll&gt; ret = prime_factor(s / i);
                map&lt;ll, ll&gt;::iterator ite;
                bool flag = true;
                for(ite = ret.begin(); ite != ret.end(); ite++) {
                    if(ite-&gt;first  % 4 != 3) continue;
                    if(ite-&gt;second % 2 == 0) continue;
                    flag = false;
                }

                if(flag) {
                    cnt++;
                }
            }
        }

        if(cnt &gt;= 3) cout &lt;&lt; "C" &lt;&lt; endl;
        else cout &lt;&lt; "P" &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2232 Ennichi]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/20/aoj2232-ennichi/"/>
    <updated>2016-03-20T23:05:17+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/20/aoj2232-ennichi</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2232">Ennichi | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>ぷよぷよ？みたいなやつ．横に隣り合うマスを実際に入れ替えてシュミレーションする．空きマスと交換すると，最初に落下処理をしなければならないことになかなか気付けなかった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int h, w, n;

int sx,sy,gx,gy;
int dx[4] = {1,-1, 0, 0};
int dy[4] = {0, 0, 1,-1};
vector&lt;string&gt; s;
bool used[35][35], used2[35][35];

bool can(int y,int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}

bool func(vector&lt;string&gt; t) {

    for(int i = h - 1; i &gt;= 0; i--) {
        for(int j = w - 1; j &gt;= 0; j--) {
            if(t[i][j] == '.') continue;

            int k = i;
            while(can(k+1, j) &amp;&amp; t[k+1][j] == '.') {
                swap(t[k][j], t[k+1][j]);
                k++;
            }
        }
    }

    while(true) {
        bool flag = false;
        memset(used, 0, sizeof(used));
        memset(used2, 0, sizeof(used2));

        for(int i = h-1; i &gt;= 0; i--) {
            for(int j = w-1; j &gt;= 0; j--) {
                if(t[i][j] == '.') continue;

                if(!used[i][j]) {
                    int len = 1;
                    int k = j+1;
                    while(can(i, k) &amp;&amp; t[i][k] == t[i][j]) {
                        len++;
                        k++;
                    }

                    k = j-1;
                    while(can(i, k) &amp;&amp; t[i][k] == t[i][j]) {
                        len++;
                        k--;
                    }

                    if(len &gt;= n) {
                        flag = true;
                        used[i][j] = true;
                        k = j + 1;
                        while(can(i, k) &amp;&amp; t[i][k] == t[i][j]) {
                            used[i][k] = true;
                            k++;
                        }

                        k = j - 1;
                        while(can(i, k) &amp;&amp; t[i][k] == t[i][j]) {
                            used[i][k] = true;
                            k--;
                        }
                    }
                }

                if(!used2[i][j]) {
                    int len = 1;
                    int k = i + 1;
                    while(can(k, j) &amp;&amp; t[k][j] == t[i][j]) {
                        len++;
                        k++;
                    }

                    k = i - 1;
                    while(can(k, j) &amp;&amp; t[k][j] == t[i][j]) {
                        len++;
                        k--;
                    }

                    if(len &gt;= n) {
                        flag = true;
                        used2[i][j] = true;
                        k = i + 1;
                        while(can(k, j) &amp;&amp; t[k][j] == t[i][j]) {
                            used2[k][j] = true;
                            k++;
                        }

                        k = i - 1;
                        while(can(k, j) &amp;&amp; t[k][j] == t[i][j]) {
                            used2[k][j];
                            k++;
                        }
                    }
                }
            }
        }

        rep(i, h) {
            rep(j, w) {
                if(used[i][j] || used2[i][j]) t[i][j] = '.';
            }
        }

        for(int i = h - 1; i &gt;= 0; i--) {
            for(int j = w - 1; j &gt;= 0; j--) {
                if(t[i][j] == '.') continue;

                int k = i;
                while(can(k+1, j) &amp;&amp; t[k+1][j] == '.') {
                    swap(t[k][j], t[k+1][j]);
                    k++;
                }
            }
        }

        if(flag) continue;
        else break;
    }

    rep(i, h) {
        rep(j, w) {
            if(t[i][j] == '.') continue;
            return false;
        }
    }
    return true;
}

int main() {
    cin &gt;&gt; h &gt;&gt; w &gt;&gt; n;

    s.resize(h);
    rep(i, h) cin &gt;&gt; s[i];

    bool flag = false;
    rep(i, h) {
        rep(j, w) {
            if(s[i][j] == '.') continue;

            if(j == 0) {
                swap(s[i][j], s[i][j+1]);
                flag |= func(s);
                swap(s[i][j], s[i][j+1]);
            } else if(j == w-1) {
                swap(s[i][j], s[i][j-1]);
                flag |= func(s);
                swap(s[i][j], s[i][j-1]);
            } else {
                swap(s[i][j], s[i][j+1]);
                flag |= func(s);
                swap(s[i][j], s[i][j+1]);
                swap(s[i][j], s[i][j-1]);
                flag |= func(s);
                swap(s[i][j], s[i][j-1]);
            }
        }
    }

    if(flag) cout &lt;&lt; "YES" &lt;&lt; endl;
    else cout &lt;&lt; "NO" &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2243 Step Step Evolution]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/20/aoj2243-step-step-evolution/"/>
    <updated>2016-03-20T22:50:10+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/20/aoj2243-step-step-evolution</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2243">Step Step Evolution</a></h4><p>Japanese video game company has developed the music video game called Step Step Evolution. The gameplay of Step Step Evolution is very simple. Players stand on the dance platform, and step on panels on it according to a sequence of arrows shown in the front screen.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>左右交互に踏めなくなった回数を数える．最初に左足，右足の <script type="math/tex"> 2 </script>パターンの<script type="math/tex"> min </script>を取る． <script type="math/tex"> \rm{mod} 3</script> で場合分けをしたが， <script type="math/tex"> \rm{mod} 2 </script>になっている箇所があることにずっと気づかずに時間を溶かした．気をつけたい．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

bool can(bool f, int cur, int to) {
    if(f) {
        if(cur % 3 == 1 &amp;&amp; to % 3 != 1) return false;
        if(cur % 3 == 2 &amp;&amp; to % 3 == 0) return false;
        return true;
    } else {
        if(cur % 3 == 0 &amp;&amp; to % 3 != 0) return false;
        if(cur % 3 == 2 &amp;&amp; to % 3 == 1) return false;
        return true;
    }
}

int main() {
    string s;
    while(cin &gt;&gt; s) {
        if(s == "#") break;

        vector&lt;int&gt; v(s.size());
        rep(i, s.size()) v[i] = s[i] - '0';

        int ans = INF, res = 0;
        int left = v[0], right = 0, ord = 0;

        REP(i, 1, v.size()) {
            if(ord &amp; 1) {
                if(can(1, right, v[i])) {
                    left = v[i];
                    ord++;
                } else {
                    right = v[i];
                    res++;
                }
            } else {
                if(can(0, left, v[i])) {
                    right = v[i];
                    ord++;
                } else {
                    left = v[i];
                    res++;
                }
            }
        }

        ans = min(ans, res);

        res = 0;
        left = 0, right = v[0], ord = 1;
        REP(i, 1, v.size()) {
            if(ord &amp; 1) {
                if(can(1, right, v[i])) {
                    left = v[i];
                    ord++;
                } else {
                    right = v[i];
                    res++;
                }
            } else {
                if(can(0, left, v[i])) {
                    right = v[i];
                    ord++;
                } else {
                    left = v[i];
                    res++;
                }
            }
        }

        ans = min(ans, res);
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1316 The Sorcerer's Donut]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/20/aoj1316-the-sorcerers-donut/"/>
    <updated>2016-03-20T22:29:14+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/20/aoj1316-the-sorcerers-donut</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1316">The Sorcerer's Donut</a></h4><p>Your master went to the town for a day. You could have a relaxed day without hearing his scolding. But he ordered you to make donuts dough by the evening. Loving donuts so much, he can't live without eating tens of donuts everyday. What a chore for such a beautiful day.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>盤面が小さいので，ある方向に一周した文字列を列挙して <script type="math/tex"> 2 </script>回以上出て辞書順最小のものを出力した．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int w,h,x,y;
int sx,sy,gx,gy;
int dx[9] = { 1, 1, 1, 0, 0, 0,-1,-1,-1};
int dy[9] = {-1, 0, 1,-1, 0, 1,-1, 0, 1};

bool can(int y,int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}

int main() {
    while(cin &gt;&gt; h &gt;&gt; w) {
        if(h == 0 &amp;&amp; w == 0) break;

        vector&lt;string&gt; s(h);
        rep(i, h) cin &gt;&gt; s[i];

        map&lt;string, int&gt; m;
        bool used[15][25];

        rep(i, h) {
            rep(j, w) {
                rep(k, 9) {
                    int y = i, x = j;
                    memset(used, 0, sizeof(used));
                    string t = "";
                    while(!used[y][x]) {
                        used[y][x] = true;
                        t += s[y][x];

                        y = (y + h + dy[k]) % h;
                        x = (x + w + dx[k]) % w;

                        if(t.size() &gt; 1) m[t]++;
                    }
                }
            }
        }

        string ans = "";
        map&lt;string, int&gt;::iterator ite;
        for(ite = m.begin(); ite != m.end(); ite++) {
            if(ite-&gt;second &lt; 2) continue;
            if(ite-&gt;first.size() &gt; ans.size()) {
                ans = ite-&gt;first;
            } else if(ite-&gt;first.size() == ans.size()) {
                bool flag = true;
                rep(i, ans.size()) {
                    if(ite-&gt;first[i] &lt;= ans[i]) continue;
                    flag = false;
                }

                if(flag) ans = ite-&gt;first;
            }
        }

        if(ans.size() == 0) cout &lt;&lt; 0 &lt;&lt; endl;
        else cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1286 Expected Allowance]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj1286-expected-allowance/"/>
    <updated>2016-03-18T22:54:03+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj1286-expected-allowance</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1286">Expected Allowance | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p><script type="math/tex; mode=display">
    dp[i][j] := i回，m面のサイコロを降った時にjが出る回数
</script></p>

<p>として，シュミレーション．サイコロを振るのは <script type="math/tex"> dp[i+1][j+k] += dp[i][j] </script>と書ける．配列を再利用するために，<script type="math/tex"> iとi+1 </script>の偶奇を見て遷移する．次に遷移する場所に値が残っているとおかしいことになるので，<script type="math/tex"> dp[i][j] </script>からサイコロを振ったらそこは初期化する．分母は全て <script type="math/tex"> m ^n </script>で， <script type="math/tex"> k </script>引いた時に最低でも <script type="math/tex"> 1 </script>になるようにして期待値を求める．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int dp[2][100005];

int main() {
    int n, m, k;
    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; k) {
        if(n == 0 &amp;&amp; m == 0 &amp;&amp; k == 0) break;

        memset(dp, 0, sizeof(dp));
        REP(j, 1, m + 1) {
            dp[1][j] = 1;
        }

        rep(i, n) {
            rep(j, 100005) {
                if(dp[i &amp; 1][j] == 0) continue;
                REP(k, 1, m+1) {
                    dp[(i+1)&amp;1][j+k] += dp[i&amp;1][j];
                }
                dp[i&amp;1][j] = 0;
            }
        }

        double ans = 0, t = 1;
        rep(i, n) {
            t *= m;
        }

        rep(j, 100005) {
            if(dp[n&amp;1][j] == 0) continue;

            double l = j - k;
            if(l &lt;= 0) l = 1;
            ans += (dp[n &amp; 1][j] / t) * l;
        }

        cout &lt;&lt; fixed;
        cout.precision(20);
        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
