<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 250 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/250/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-22T22:11:56+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ2620 Trodden Cable]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj2620-trodden-cable/"/>
    <updated>2016-03-22T21:52:44+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj2620-trodden-cable</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2620">Trodden Cable</a></h4><p>Nathan O. Davis is running a company. His company owns a web service which has a lot of users. So his office is full of servers, routers and messy LAN cables. He is now very puzzling over the messy cables, because they are causing many kinds of problems. For example, staff working at the company often trip over a cable.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>全く分からずに調べた．</p>

<p><a href="http://acm-icpc.aitea.net/index.php?plugin=attach&amp;refer=2013%2FPractice%2F%E5%A4%8F%E5%90%88%E5%AE%BF%2F%E8%AC%9B%E8%A9%95&amp;openfile=trodden_cable.pdf:image=http://acm-icpc.aitea.net/index.php?plugin=attach&amp;refer=2013%2FPractice%2F%E5%A4%8F%E5%90%88%E5%AE%BF%2F%E8%AC%9B%E8%A9%95&amp;openfile=trodden_cable.pdf">http://acm-icpc.aitea.net/index.php?plugin=attach&amp;refer=2013%2FPractice%2F%E5%A4%8F%E5%90%88%E5%AE%BF%2F%E8%AC%9B%E8%A9%95&amp;openfile=trodden_cable.pdf:image=http://acm-icpc.aitea.net/index.php?plugin=attach&amp;refer=2013%2FPractice%2F%E5%A4%8F%E5%90%88%E5%AE%BF%2F%E8%AC%9B%E8%A9%95&amp;openfile=trodden_cable.pdf</a></p>

<p>この画像が非常に分かりやすい．移動する時にまたがる線のコストを<script type="math/tex"> +1 </script>して，移動が終わったグリッドグラフでdijkstra．</p>

<p>現在位置を(y, x)と置くと</p>

<ul>
<li><script type="math/tex"> R </script>の時， <script type="math/tex"> (y, x+1) \to (y+1, x+1) </script></li>
<li><script type="math/tex"> L </script>の時， <script type="math/tex"> (y, x) \to (y+1, x) </script></li>
<li><script type="math/tex"> U </script>の時， <script type="math/tex"> (y, x) \to (y, x+1) </script></li>
<li><script type="math/tex"> D </script>の時， <script type="math/tex"> (y+1, x) \to (y+1, x+1) </script></li>
</ul>


<p>に <script type="math/tex"> +1 </script>した．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int w, h, n;
int sx,sy,gx,gy;
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1};

bool can(int y, int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}

struct edge {
    int from,to;
    ll cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[505*505 + 5];
ll d[505 * 505 + 5];

void dijkstra(int s, int n) {
    priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que;
    fill(d, d+n, INF);

    d[s] = 0;
    que.push(P(0,s));

    while(que.size()) {
        P p = que.top();
        que.pop();

        int v = p.second;
        if(d[v] &lt; p.first) continue;

        rep(i, G[v].size()) {
            edge e = G[v][i];
            if(d[e.to] &gt; d[v] + e.cost) {
                d[e.to] = d[v] + e.cost;
                que.push(P(d[e.to],e.to));
            }
        }
    }
}

int main() {
    cin &gt;&gt; w &gt;&gt; h &gt;&gt; n;

    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; gx &gt;&gt; gy;

    rep(i, h * w) {
        G[i].clear();
    }

    w++;
    h++;

    rep(i, h) {
        rep(j, w) {
            rep(k, 4) {
                int y = i + dy[k];
                int x = j + dx[k];

                if(can(y, x)) {
                    G[i*w + j].push_back(edge(y*w + x, 0));
                }
            }
        }
    }

    rep(i, n) {
        int y, x, t;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; t;

        string s;
        cin &gt;&gt; s;

        rep(k, t) {
            rep(j, s.size()) {
                int from = -1, to = -1;
                if(s[j] == 'R' &amp;&amp; x + 1 &lt; w - 1) {
                    from = y * w + (x + 1);
                    to = (y + 1) * w + (x + 1);
                    x++;
                } else if(s[j] == 'L' &amp;&amp; 0 &lt;= x - 1) {
                    from = y * w + x;
                    to = (y + 1) * w + x;
                    x--;
                } else if(s[j] == 'U' &amp;&amp; 0 &lt;= y - 1) {
                    from = y * w + x;
                    to = y * w + (x + 1);
                    y--;
                } else if(s[j] == 'D' &amp;&amp; y + 1 &lt; h - 1) {
                    from = (y + 1) * w + x;
                    to = (y + 1) * w + (x + 1);
                    y++;
                }

                if(from == -1 &amp;&amp; to == -1) continue;
                rep(k, G[from].size()) {
                    if(G[from][k].to == to) {
                        G[from][k].cost++;
                    }
                }
                rep(k, G[to].size()) {
                    if(G[to][k].to == from) {
                        G[to][k].cost++;
                    }
                }
            }
        }
    }

    // rep(i, h) {
    //  rep(j, w) {
    //      cout &lt;&lt; " --------- " &lt;&lt; i &lt;&lt; ", " &lt;&lt; j &lt;&lt; " :" &lt;&lt; i * w + j &lt;&lt; " |";
    //      rep(k, G[i*w + j].size()) {
    //          cout &lt;&lt; "(" &lt;&lt; G[i*w + j][k].to &lt;&lt; ", " &lt;&lt; G[i*w + j][k].cost &lt;&lt; ") ";
    //      }
    //      cout &lt;&lt; endl;
    //  }
    // }

    dijkstra(sy * w + sx, h * w);

    // rep(i, h) {
    //  rep(j, w) {
    //      cout &lt;&lt; d[i*w + j] &lt;&lt; " ";
    //  }
    //  cout &lt;&lt; endl;
    // }

    cout &lt;&lt; d[gy * w + gx] &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2641 Magic Bullet]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj2641-magic-bullet/"/>
    <updated>2016-03-22T21:29:19+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj2641-magic-bullet</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2641">Magic Bullet | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>点<script type="math/tex"> (sx, sy, sz) </script>，点 <script type="math/tex"> (dx, dy, dz) </script>を結ぶ線分が<script type="math/tex"> N </script>個の球と交差しているかを見る．それぞれの球の中心から直線への射影を出す．その点が線分に収まっていて，球の中心との距離がr以内なら交差しているとした．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair
#define EPS 1e-8
#define equals(a,b) fabs((a) - (b)) &lt; EPS

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct Point3D {
    double x, y, z;

    Point3D() : x(0), y(0), z(0) {}

    Point3D(double x, double y, double z) : x(x), y(y), z(z) {}

    Point3D operator+(const Point3D &amp;o) const { return Point3D(x+o.x, y+o.y, z+o.z); }

    Point3D operator-(const Point3D &amp;o) const { return Point3D(x-o.x, y-o.y, z-o.z); }

    Point3D operator*(const double m) const { return Point3D(x*m, y*m, z*m); }

    Point3D operator/(const double d) const { return Point3D(x/d, y/d, z/d); }

    bool operator==(const Point3D &amp;o) const { return fabs(x-o.x) &lt; EPS &amp;&amp; fabs(y-o.y) &lt; EPS; }
};

ostream&amp; operator &lt;&lt; (ostream&amp; os, const Point3D&amp; p) {
    os &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ", " &lt;&lt; p.z &lt;&lt; ")";
    return os;
}

double dot(Point3D a, Point3D b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
Point3D cross(Point3D a, Point3D b) { return Point3D(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x); }

double norm(Point3D p) { return dot(p, p); }
double abs(Point3D p) { return sqrt(norm(p)); }

struct Line {
    Point3D a, b;

    Line() : a(Point3D(0, 0, 0)), b(Point3D(0, 0, 0)) {}

    Line(Point3D a, Point3D b) : a(a), b(b) {}
};

ostream&amp; operator &lt;&lt; (ostream&amp; os, const Line&amp; l) {
    os &lt;&lt; "(" &lt;&lt; l.a.x &lt;&lt; ", " &lt;&lt; l.a.y &lt;&lt; ", " &lt;&lt; l.a.z &lt;&lt;  ")-(" &lt;&lt; l.b.x &lt;&lt; "," &lt;&lt; l.b.y &lt;&lt; ", " &lt;&lt; l.b.z &lt;&lt;  ")";
    return os;
}

Point3D project(Line l, Point3D p) {
    Point3D base = l.b - l.a;
    double t = dot(base, p-l.a) / dot(base, base);
    return l.a + base * t;
}

struct Ball {
    Point3D p;
    double r;

    Ball() : p(Point3D(0, 0, 0)), r(0.0) {}

    Ball(Point3D p, double r) : p(p), r(r) {}
};

ostream&amp; operator &lt;&lt; (ostream&amp; os, const Ball&amp; b) {
    os &lt;&lt; "(" &lt;&lt; b.p.z &lt;&lt; ", " &lt;&lt; b.p.y &lt;&lt; ", " &lt;&lt; b.p.z &lt;&lt; " :" &lt;&lt; b.r &lt;&lt; ")";
    return os;
}

int main() {
    int n, q;
    cin &gt;&gt; n &gt;&gt; q;

    vector&lt;Ball&gt; v(n);
    vector&lt;ll&gt; cost(n);
    rep(i, n) {
        cin &gt;&gt; v[i].p.x &gt;&gt; v[i].p.y &gt;&gt; v[i].p.z &gt;&gt; v[i].r &gt;&gt; cost[i];
    }

    rep(i, q) {
        ll ans = 0;
        Point3D s, t;
        cin &gt;&gt; s.x &gt;&gt; s.y &gt;&gt; s.z &gt;&gt; t.x &gt;&gt; t.y &gt;&gt; t.z;

        Line line(s, t);

        rep(j, n) {
            Point3D proj = project(line, v[j].p);

            if(abs(line.b - line.a) &gt;= abs(proj - line.a) &amp;&amp; abs(line.a - line.b) &gt;= abs(proj - line.b)) {
                if(abs(proj - v[j].p) &lt; v[j].r + EPS) {
                    ans += cost[j];
                }
            }
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1250 Leaky Cryptography]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj1250-leaky-cryptography/"/>
    <updated>2016-03-22T21:00:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj1250-leaky-cryptography</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1250">Leaky Cryptography</a></h4><p>The ACM ICPC judges are very careful about not leaking their problems, and all communications are encrypted. However, one does sometimes make mistakes, like using too weak an encryption scheme. Here is an example of that. The encryption chosen was very simple: encrypt each chunk of the input by flipping some bits according to a shared key.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>一番下の桁から順番に決めていく．今までの <script type="math/tex"> \rm{sum} </script>の <script type="math/tex"> i </script>桁目と <script type="math/tex"> N_1 〜 N_8</script>の<script type="math/tex"> i </script>桁の和が <script type="math/tex"> N_9 </script>の <script type="math/tex"> i </script>桁と一致しているかを見る．一致していない場合に， <script type="math/tex"> 8 </script>つの<script type="math/tex"> i </script>桁目を反転して，答えの <script type="math/tex"> i </script>桁目のビットを立てる．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;bitset&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll f(string s) {
    ll res = 0, t = 1;

    for(int i = s.size()-1; i &gt;= 0; i--) {
        if('0' &lt;= s[i] &amp;&amp; s[i] &lt;= '9') {
            res += (s[i] - '0') * t;
        } else {
            res += (10 + (s[i] - 'a')) * t;
        }
        t *= 16;
    }
    return res;
}

int main() {
    int n;
    cin &gt;&gt; n;

    rep(q, n) {
        vector&lt;string&gt; v(9);
        vector&lt;ll&gt; t(9);
        rep(i, 9) {
            cin &gt;&gt; v[i];
            t[i] = f(v[i]);
        }

        ll ans = 0;

        vector&lt; vector&lt;int&gt; &gt; bit(9, vector&lt;int&gt;(32));
        rep(i, 9) {
            rep(j, 32) {
                if(t[i] &amp; (1LL &lt;&lt; j)) {
                    bit[i][j] = 1;
                }
            }
        }

        ans = 0;
        ll sum = 0;
        rep(i, 32) {
            ll d = 0;
            rep(j, 8) {
                d += bit[j][i];
            }
            bitset&lt;32&gt; ss(sum);

            if( ((((sum &gt;&gt; i) &amp; 1) + d) &amp; 1) == bit[8][i]) {
                sum += (d &lt;&lt; i);
            } else {
                d = 0;
                rep(j, 8) {
                    d += bit[j][i] ^ 1;
                }
                sum += (d &lt;&lt; i);
                ans += (1LL &lt;&lt; i);
            }
        }

        cout &lt;&lt; hex &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1325 Bit String Recordering]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj1325-bit-string-recordering/"/>
    <updated>2016-03-22T20:46:04+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj1325-bit-string-recordering</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1345">Bit String Reordering | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>連続するビット列の数が与えられる．最初を <script type="math/tex"> 0 </script>にする， <script type="math/tex"> 1 </script>にするの <script type="math/tex"> 2 </script>パターンをシュミレーション(左端から決めていき，違ったら右から持ってくる)して，swap回数の小さい方を出力した．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;int&gt; a(n), b(m);
    rep(i, n) cin &gt;&gt; a[i];
    rep(i, m) cin &gt;&gt; b[i];


    vector&lt;int&gt; c, d;
    rep(i, m) {
        rep(j, b[i]) {
            if(i &amp; 1) {
                c.push_back(1);
                d.push_back(0);
            } else {
                c.push_back(0);
                d.push_back(1);
            }
        }
    }

    int ans = INF, res = 0;
    vector&lt;int&gt; t(a.begin(), a.end());
    rep(i, n) {
        if(t[i] == c[i]) continue;

        REP(j, i+1, n) {
            if(c[i] == t[j]) {
                for(int k = j; k-1 &gt;= i; k--) {
                    swap(t[k], t[k-1]);
                    res++;
                }
                break;
            }
        }
    }

    bool flag = true;
    rep(i, n) {
        if(t[i] == c[i]) continue;
        flag = false;
    }

    if(flag) {
        ans = min(ans, res);
    }

    res = 0;
    rep(i, n) t[i] = a[i];

    rep(i, n) {
        if(t[i] == d[i]) continue;

        REP(j, i+1, n) {
            if(d[i] == t[j]) {
                for(int k = j; k-1 &gt;= i; k--) {
                    swap(t[k], t[k-1]);
                    res++;
                }
                break;
            }

        }
    }

    flag = true;
    rep(i, n) {
        if(t[i] == d[i]) continue;
        flag = false;
    }

    if(flag) {
        ans = min(ans, res);
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2639 Yamanote Line]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj2639-yamanote-line/"/>
    <updated>2016-03-22T20:34:06+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj2639-yamanote-line</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2639">Yamanote Line | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>起きる，寝るを実際に繰り返す．</p>

<ul>
<li><script type="math/tex"> \rm{used}[i][0] :=  起きてる時に時間iに訪れたか</script></li>
<li><script type="math/tex"> \rm{used}[i][1] :=  寝ている時に時間iに訪れたか</script></li>
</ul>


<p>とする．既に訪れた場所に訪れるとそこでループするので，ループせずに目的の場所に辿り着ける場合は今までの合計の時間，そうではない場合は-1を出力した．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int a, b, c;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;

    bool used[60][2];
    memset(used, 0, sizeof(used));

    int cnt = 0, ans = 0;
    bool flag = true;
    while(true) {
        if(cnt &amp; 1) {
            ans += b;
            if(used[ans%60][1]) {
                flag = false;
                break;
            }
            used[ans%60][1] = true;
        } else {
            if(ans % 60 + a &gt;= 60 &amp;&amp; ans % 60 &lt;= c) {
                ans += c - ans % 60;
                break;
            }
            else if(c &gt;= ans % 60 &amp;&amp; (ans + a) % 60 &gt;= c) {
                ans += c - ans % 60;
                break;
            } else {
                ans += a;
                if(used[ans%60][0]) {
                    flag = false;
                    break;
                }
                used[ans%60][0] = true;
            }
        }
        cnt++;
    }

    if(flag) cout &lt;&lt; ans &lt;&lt; endl;
    else cout &lt;&lt; -1 &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
