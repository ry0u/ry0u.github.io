<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: topcoder | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/topcoder/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-05T20:01:22+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM335 D2H MinimumVariancePartition]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/05/srm335-d2h-minimumvariancepartition/"/>
    <updated>2017-02-05T19:28:10+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/05/srm335-d2h-minimumvariancepartition</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7363&rd=10659">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

数列が与えられる．この数列を$k$個の数列に分け，それぞれの数列の分散の和を最小化したい．まず初めに$[i, j)$の分散を全て計算しておく．

$$
	dp[i][j] := i番目までをj個に分けた時の分散の和の最小値
$$

として動的計画法．$j$番目まで見て$k+1$個に分ける時は，$[0, i)$と$[i, j)$に分けて$dp[i][k]$と$[i, j)$の分散の和を候補としてminを取っていく．

```cpp
#include <bits/stdc++.h>

#define rep(i,n) for(int i=0;i<(int)(n);i++)
#define REP(i,k,n) for(int i=k;i<(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

class MinimumVariancePartition {
	public:
	double minDev(vector <int> mixedSamples, int K) {
		vector<int> v = mixedSamples;
		sort(v.begin(), v.end());

		double dp[55][55];
		rep(i, 55) rep(j, 55) dp[i][j] = INF;
		dp[0][0] = 0;

		double var[55][55];
		memset(var, 0, sizeof(var));
		rep(i, v.size()) {
			REP(j, i+1, v.size()+1) {
				double mean = 0;
				REP(k, i, j) {
					mean += v[k];
				}
				mean /= (j - i);

				REP(k, i, j) {
					var[i][j] += (v[k] - mean) * (v[k] - mean);
				}
				var[i][j] /= (j - i);
			}
		}

		rep(i, v.size()) {
			REP(j, i+1, v.size()+1) {
				rep(k, K) {
					dp[j][k+1] = min(dp[j][k+1], dp[i][k] + var[i][j]);
				}
			}
		}

		return dp[v.size()][K];
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM335 D1E-D2M Multifactorial]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/05/srm335-d1e-d2m-multifactorial/"/>
    <updated>2017-02-05T19:11:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/05/srm335-d1e-d2m-multifactorial</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6835&rd=10659">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$fac\_k(n)$は次のように定義される．

$$
\begin{eqnarray}
	fac\_k (n) &=& n\ \ \ if\ k >= n\\\
	fac\_k (n) &=& n * fac_k(n - k)\ \ \ if\ k < n
\end{eqnarray}
$$

$n, k$が与えられるので，$fac_k(n)$を文字列で返す．$10 ^{18}$をより大きくなる場合は$overflow$を返す．

---

$n * fac_k(n - k)$が$10 ^{18}$より大きくなるかを判断したいが，そのままかけて比較すると実際に大きくなるときはオーバーフローしてしまうので，$10 ^ {18} >= i * ret$を$\frac{10 ^{18}}{i} >= ret$に変形する．

```cpp
#include <bits/stdc++.h>

#define rep(i,n) for(int i=0;i<(int)(n);i++)
#define REP(i,k,n) for(int i=k;i<(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

class Multifactorial {
	public:
	string calcMultiFact(int n, int k) {
		bool flag = true;
		ll ret = 1;
		for(int i = n; i > 0; i -= k) {
			if(1e18 / i >= ret) {
				ret *= i;
			} else {
				flag = false;
				break;
			}
		}

		if(flag) {
			string ans;
			stringstream ss;
			ss << ret;
			return ss.str();
		} else {
			return "overflow";
		}
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM334 D1M-D2H ExtendedHappyNumbers]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/03/srm334-d1m-d2h-extendedhappynumbers/"/>
    <updated>2017-02-03T00:18:35+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/03/srm334-d1m-d2h-extendedhappynumbers</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7244&rd=10658">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$S\_K(N)$は$N$の各桁を$K$乗した和と定義される．$S\_2(65) = 6 ^2 + 5 ^2 = 61$である．$N$に対する数列は

$$
	[N, S\_K(N), S\_K (S\_K (N) ), ...]
$$

と定義される．$N$, $K$が与えられた時の$happiness$は数列の中の最小値である．$A, B, K$が与えられるので，$A \sim B$の各$happiness$の和を求める．

---

$A \sim B$のそれぞれの数について数列を求めるが，別の数列を求めていたとしても同じ数が途中に出現すればそれ以降は同じになるので，これをメモ化する．内容はその後の最小値である．最大値は$N = 999999, K = 6$の$2125764$であるが十分に余裕を持って配列を持った．後はそれぞれについて$happiness$を求め，その和を答える．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

ll memo[5000005], k;

ll f(ll x) {
	ll ret = 0;
	while(x) {
		ll y = (x % 10), t = 1;
		rep(i, k) {
			t *= y;
		}
		ret += t;
		x /= 10;
	}
	return ret;
}

ll dfs(ll x) {
	if(memo[x] != -1) {
		if(memo[x] == INF) {
			ll y = x, res = x;
			while(true) {
				y = f(y);
				res = min(res, y);
				if(y == x) break;
			}
			return memo[x] = res;
		} else return memo[x];
	}

	memo[x] = INF;
	ll res = min(x, dfs( f(x)) );
	return memo[x] = res;
}

class ExtendedHappyNumbers {

    public:

    long long calcTheSum(int A, int B, int K) {
		ll ans = 0;
		memset(memo, -1, sizeof(memo));
		k = K;

		REP(i, A, B + 1) {
			ans += dfs(i);
		}

		return ans;
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM334 D1E EncodedSum]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/03/srm334-d1e-encodedsum/"/>
    <updated>2017-02-03T00:01:16+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/03/srm334-d1e-encodedsum</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7249&rd=10658">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$A \sim J$には，各々のアルファベットに$0 \sim 9$が対応する．全ての和の最大値を答える．まずは各アルファベットを1にして考えて，アルファベットごとの和を出す．この和が大きいものから数字を大きい順に当てはめていく．もし0で始まってしまう場合があったらそこはswapする．


```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<int(n);i++)
#define rep(i,n) for(int i=0;i<int(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<ll,ll> P;

class EncodedSum {

    public:

    long long maximumSum(vector <string> numbers) {
		vector<vector<int> > s(numbers.size());
		rep(i, numbers.size()) {
			s[i].resize(numbers[i].size());
			rep(j, numbers[i].size()) {
				s[i][j] = int(numbers[i][j] - 'A');
			}
		}

		bool flag[10];
		memset(flag, 0, sizeof(flag));

		vector<ll> x(10);
		rep(i, s.size()) {
			ll t = 1;
			flag[ s[i][0] ] = true;
			for(int j = s[i].size()-1; j >= 0; j--) {
				x[ s[i][j] ] += t;
				t *= 10;
			}
		}

		vector<P> v;
		vector<int> a(10);
		rep(i, 10) {
			v.push_back(P(x[i], i));
			a[i] = 9 - i;
		}

		sort(v.begin(), v.end(), greater<P>());

		ll ans = 0;
		for(int i = v.size()-1; i >= 0; i--) {
			if(flag[ v[i].second ] && a[i] == 0) {
				swap(a[i], a[i-1]);
			}
			ans += v[i].first * a[i];
		}

		return ans;
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM333 D1M-D2H RepeatedPatterns]]></title>
    <link href="http://ry0u.github.io/blog/2016/12/04/srm333-d1m-d2h-repeatedpatterns/"/>
    <updated>2016-12-04T00:53:49+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/12/04/srm333-d1m-d2h-repeatedpatterns</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7294&rd=10657">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

文字列$P1, P2, zeroCount$が与えられる．文字列$S$は$P1$を$1000000$回繰り返した後で$P2$を$1$回繰り返して連結する，この後に$P1$を$1000000$回繰り返した後で$P2$を$2$回繰り返して連結する...と$T$の長さが$10 ^{16}$以上になったら出来ないものとして考える．連続して'0'が$zeroCount$続く部分文字列がある時，その最初のindexを答える．

---

場合分けをたくさんした．$P1$が全て$0$, $P2$が全て$0$，そうでない場合と分けた．しっかり$P1$と$P2$の境目を考えなければいけなくて，適当にやったら非常にたくさんのWAを出した．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

class RepeatedPatterns {
	public:
	long long findZeroSegment(string P1, string P2, string zeroCount) {
		bool az = true, bz = true;
		rep(i, P1.size()) {
			if(P1[i] == '0') continue;
			az = false;
		}

		rep(i, P2.size()) {
			if(P2[i] == '0') continue;
			bz = 0;
		}

		int afront = 0, aback = 0;
		rep(i, P1.size()) {
			if(P1[i] == '0') afront++;
			else break;
		}

		for(int i = P1.size()-1; i >= 0; i--) {
			if(P1[i] == '0') aback++;
			else break;
		}

		int bfront = 0, bback = 0;
		rep(i, P2.size()) {
			if(P2[i] == '0') bfront++;
			else break;
		}

		for(int i = P2.size()-1; i >= 0; i--) {
			if(P2[i] == '0') bback++;
			else break;
		}

		ll zc;
		stringstream ss;
		ss << zeroCount;
		ss >> zc;

		if(az && bz) {
			return 0;
		} else if(az) {
			if(zc <= 1000000 * P1.size() + bfront) {
				return 0;
			} else if(zc <= bback + 1000000 * P1.size() + bfront) {
				return 1000000 * P1.size() + P2.size() - bback;
			} else {
				return -1;
			}
		} else if(bz) {
			if(zc <= afront) {
				return 0;
			} else if(zc <= aback + afront) {
				return P1.size() - aback;
			} else {
				ll cnt = 1;
				ll res = 0;
				while(true) {
					res += P1.size() * 1000000;
					if(res + P2.size() * cnt <= 1e16 && zc <= aback + bfront * cnt) {
						return res - aback;
					}
					if(res + P2.size() * cnt + P1.size() * 1000000 <= 1e16 && zc <= aback + bfront * cnt + afront) {
						return res - aback;
					}
					res += P2.size() * cnt; cnt++;

					if(res >= 1e16) break;
				}
				return -1;
			}
		} else {
			int alen = 0, len = 0, aid = 0;
			for(int i = P1.size()-1; i >= 0; i--) {
				if(P1[i] == '0') {
					len++;
					if(alen <= len) {
						alen = len;
						aid = i;
					}
				} else {
					len = 0;
				}
			}

			len = 0;
			int blen = 0, bid = 0;
			for(int i = P2.size()-1; i >= 0; i--) {
				if(P2[i] == '0') {
					len++;
					if(blen <= len) {
						blen = len;
						bid = i;
					}
				} else {
					len = 0;
				}
			}

			if(zc <= afront) {
				return 0;
			} else if(zc <= alen) {
				return aid;
			} else if(zc <= aback + afront) {
				return P1.size() - aback;
			} else if(zc <= aback + bfront) {
				return P1.size() * 1000000 - aback;
			} else if(zc <= blen) {
				return P1.size() * 1000000 + bid;
			} else if(zc <= bback + afront) {
				return P1.size() * 1000000 + P2.size() - bback;
			} else if(zc <= bback + bfront) {
				return P1.size() * 1000000LL + P2.size() + P1.size() * 1000000 + P2.size() - bback;
			}
			return -1;
		}
	}
};
```
]]></content>
  </entry>
  
</feed>
