<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: topcoder | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/topcoder/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-10-27T03:35:54+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM319 D1M ConstructBST]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/27/srm319-d1m-constructbst/"/>
    <updated>2016-10-27T02:38:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/27/srm319-d1m-constructbst</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6714&rd=9999">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

完全二分木の制約はD2Hの同じ．今度は$1-indexed$で始まっている完全二分木の存在するノード番号が与えられるので，制約を満たすアルファベットの割り当て方の通りを求める．  
全てのノードに置いて部分木の大きさを求めておく．あるノードに対して左の子をleftとしてその部分木の大きさを$cntL$，右の子をrightとしてその部分木の大きさを$cntR$とする．既にleft, rightの部分木のアルファベットの割り当て方の通りが求まっていて$cnt1, cnt2$とすると見ているノードが取れる値の集合の分け方に対して，leftとrightのどの組み合わせでも制約を満たすので$cnt1 * cnt2$通りある．ノードが取れる値の集合の分け方というのはノードの部分木のsize$(L+R)$から左の子の選ぶ組み合わせにで求めることができるので最終的にノードの割り当て方の通りは$cnt1 * cnt2 * {}\_{cntL + cntR}C\_{cntL}$となる．これを再帰的にやる．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

struct Node {
	int cntL, cntR;
	Node *left, *right;

	Node() {
		cntL = cntR = 0;
		left = right = NULL;
	}
};

set<int> S;
void build(int x, Node *root) {
	root->left = new Node();
	root->right = new Node();

	if(S.find(2 * x) != S.end()) {
		build(2 * x, root->left);
		root->cntL = (root->left->cntL + root->left->cntR + 1);
	}

	if(S.find(2 * x + 1) != S.end()) {
		build(2 * x + 1, root->right);
		root->cntR = (root->right->cntL + root->right->cntR + 1);
	}
}

ll C[2005][2005];
void combination(int size) {
	for (int i = 0; i < size; i++) C[i][0] = 1LL;
	for (int i = 1; i < size; i++) {
		for (int j = 1; j <= i; j++) {
			C[i][j] = (C[i-1][j-1] + C[i-1][j]);
		}
	}
}

ll dfs(Node *node) {
	if(node == NULL) return 1;
	ll n = node->cntL, m = node->cntR;

	ll cnt1 = dfs(node->left);
	ll cnt2 = dfs(node->right);

	return cnt1 * cnt2 * C[n + m][n];
}

class ConstructBST {

    public:

    long long numInputs(vector <int> tree) {
		Node *root = new Node();
		S.clear();

		rep(i, tree.size()) {
			S.insert(tree[i]);
		}
		build(1, root);

		combination(2000);
		return dfs(root);
    }
};
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM319 D2H IncompleteBST]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/27/srm319-d2h-incompletebst/"/>
    <updated>2016-10-27T02:07:55+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/27/srm319-d2h-incompletebst</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6713&rd=9999">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

完全二分木が与えられる．完全二分木のためノードは子にleftとrightを持つが，その持つ値に制限がある．

* leftの部分木の全ての値はleftの値より小さいか等しくなければならない
* rightの部分木の全ての値はrightの値より大きくなければならない

完全二分木の中に1つだけ要素が決まっていないノード?がある．そのノードの値として制約を満たすアルファベットを全て並べる．

---

?のノードの値を全て探索して制約を満たしているかどうか見てあげる．dfsでは，今見ているノードが持って良い値の範囲を$[minval$, $maxval]$として持っておく．leftに行く場合には，その部分木が今見ているノードの値より小さいか等しくなければいけないので$[minval$, $val]$として進む．rightに行く場合には，その部分木が今見ているノードの値より大きくなければいけないので$[val + 1$, $minval]$として進む．矛盾なく進むことが出来たらtrueを返すようにした．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

int cnt[1<<21];
bool flag[1<<21];

int vmax = -1;
bool dfs(int id, int val, int minval, int maxval) {
	if(val < minval || val > maxval) {
		return false;
	}

	int l = (id * 2);
	int r = (id * 2 + 1);

	bool f1 = false, f2 = false;

	if(cnt[l] != -1) {
		f1 = dfs(l, cnt[l], minval, val);
	} else {
		f1 = true;
	}

	if(cnt[r] != -1) {
		f2 = dfs(r, cnt[r], val + 1, maxval);
	} else {
		f2 = true;
	}

	return f1 && f2;
}


class IncompleteBST {
	public:
	string missingValues(vector <string> tree) {
		int n = tree.size();
		memset(cnt, -1, sizeof(cnt));
		memset(flag, 0, sizeof(flag));

		int x = -1;
		rep(i, n) {
			string s = tree[i].substr(2);
			stringstream ss(s);
			int id; ss >> id;

			vmax = max(vmax, id);

			if(tree[i][0] == '?') {
				flag[id] = true;
				x = id;
			} else {
				int val = (tree[i][0] - 'A');
				cnt[id] = val;
			}

		}

		string ans = "";
		rep(i, 26) {
			cnt[x] = i;
			if(dfs(1, cnt[1], 0, 25)) {
				ans += char('A'+i);
			}
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM318 D2H SimplifiedDarts]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/27/srm318-d2h-simplifieddarts/"/>
    <updated>2016-10-27T01:04:06+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/27/srm318-d2h-simplifieddarts</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6685&rd=9998">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

ダーツの投げる場所が$2$つあり，短い距離で投げてあたった場合は$2$点，長い距離で投げてあたった場合は$3$点貰える．それぞれ当たる確立は$P1$%, $P2$%である．$N$回投げて，$W$点以上取った時の確立を求めたい．

$$
	dp[i][j] := i回投げてj点以上取った時の確立
$$

として動的計画法．短い距離の場合で$dp[i][j]$に遷移するのは，$i-1$回目に投げて$j-2$点だった時に投げてあたった場合と，$i-1$回目に既に$j$点取っていてはずした場合の和である．同様に長い距離の場合で$dp[i][j]$に遷移するのは$i-1$回目に投げて$j-3$点だった時に投げてあたった場合と，$i-1$回目に既に$j$点取っていてはずした場合の和である．この時，$W$点以上の確立も考慮しなければならない．例えば$W+2$点取る確立(以上ではない)は$-2$から遷移がスタートして$W$に来たと考える事ができるので，遷移元が配列外参照となる場合は単純に$1$として考えてあげれば大丈夫．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

double dp[1005][3005];

class SimplifiedDarts {
	public:
	double tryToWin(int W, int N, int P1, int P2) {
		double p1 = P1 / (100.0);
		double p2 = P2 / (100.0);

		memset(dp, 0, sizeof(dp));
		
		rep(i, N + 1) 
			dp[i][0] = 1.0;
		
		REP(i, 1, N + 1) {
			REP(j, 1, W + 1) {
				if(j - 2 >= 0) {
					dp[i][j] = max(dp[i][j], p1 * dp[i-1][j-2] + (1 - p1) * dp[i-1][j]);
				} else {
					dp[i][j] = max(dp[i][j], p1 + (1 - p1) * dp[i-1][j]);
				}
				if(j - 3 >= 0) {
					dp[i][j] = max(dp[i][j], p2 * dp[i-1][j-3] + (1 - p2) * dp[i-1][j]);
				} else {
					dp[i][j] = max(dp[i][j], p2 + (1 - p2) * dp[i-1][j]);
				}
			}
		}

		return dp[N][W] * 100;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM318 D1E-D2M ReturnToHome]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/27/srm318-d1e-d2m-returntohome/"/>
    <updated>2016-10-27T00:46:16+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/27/srm318-d1e-d2m-returntohome</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6684&rd=9998">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$(X, Y)$にいて何秒で$(0, 0)$に行けるか．移動方法は$2$通りある．

* 歩く:$1[s]$当たり$1$マス分進む
* ジャンプ:$T[s]$当たり$D$マス進む

進む方向は限定されていないので，基本的に$\frac{D}{T} > 1$の場合はジャンプした方が多く進める．基本的にはジャンプで進んでいき，そこから歩いて進んでいった場合と比較する．$1$回以上ジャンプした場合に残りの距離が$D$以下になった場合は，前回のジャンプを$(0, 0)$に向かって真っ直ぐ進むのではなく，適当な点を中継することで残り$1$回のジャンプで行くことができる．初期地点から$D$以下の場合は，必ずどこかの点を中継することで$2$回のジャンプで$(0, 0)$に行くことが出来る．

# Code

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair
#define EPS 1e-8

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

class ReturnToHome {
	public:
	double goHome(int X, int Y, int D, int T) {
		double sum = sqrt(X * X + Y * Y);

		double  ans = INF;
		ans = min(ans, sum);

		if(sum < D) {
			ans = min(ans, 2.0 * T);
		}

		double t = 0;
		while(sum > EPS) {
			sum -= D;
			t += T;

			if(t == T) {
				ans = min(ans, abs(sum) + t);
			} else if(sum <= EPS) {
				ans = min(ans, t);
			} else {
				ans = min(ans, sum + t);
			}
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM317 D1M CollectingPayment]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/26/srm317-d1m-collectingpayment/"/>
    <updated>2016-10-26T15:51:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/26/srm317-d1m-collectingpayment</id>
    <content type="html"><![CDATA[<!-- more -->
仕事が$moment[i]$日にあり報酬は$earning[i]$である．報酬は銀行に振り込まれる形で，振込手数料は$fee$である．振り込む日はこちらが自由に指定できて，報酬の一時的にストックしておける上限などもない．銀行に預けてあるお金は$i \% 7 == 1$の時に利息がついて，その時に銀行に預けてあるお金$ * \frac{rate}{1000}$となる．最終的に銀行に預けてあるお金を最大化する．  

$$
	dp[i] := i日目に銀行に預けてあるお金の最大値
$$

として動的計画法．$i$日目$\sim j$日目までは一括で銀行に振り込んでもらうとする．その報酬の合計がfee以下ではマイナスになるので，その場合はやらない．$i$日目から$j$日目にかけて利息がつく日が何回あったかをcountしておき，
$$
	dp[i] * pow(1.0 + \frac{rate}{1000.0}, cnt) + (sum - fee) \to dp[j]$
$$
で更新する．$i$日目までの銀行に預けてあるお金の最大値$*$利息をcount回行い，報酬から振込手数料を引いた金額を足す．ループの最初で利息が付く日の更新をしているため，$j$日目が利息が付く日で合った場合は$-1$している．しかし，このままでは今の最大値のまま銀行にずっと預けておくという遷移をしていないので，最後に$365$日まで預けておく場合を全てやる．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

double dp[400], E[400];

class CollectingPayment {
	public:
	double maximumProfit(vector <int> earning, vector <int> moment, int fee, int rate) {
		int n = earning.size();

		memset(E, 0, sizeof(E));
		rep(i, n) {
			E[moment[i]] = earning[i];
		}

		memset(dp, 0, sizeof(dp));

		rep(i, 366) {
			if(i % 7 == 1) 
				dp[i] = dp[i] * (1.0 + double(rate) / 1000.0);

			double sum = 0.0;
			int cnt = 0;
			REP(j, i+1, 366) {
				sum += E[j];
				if(j % 7 == 1) cnt++;
				if(sum < fee) continue;

				dp[j] = max(dp[j], (dp[i] * pow(1.0 + rate / 1000.0, cnt - (j % 7 == 1)) + sum - fee));
			}
		}

		double ans = 0;
		rep(i, 366) {
			ans = max(ans, dp[i]);
			int cnt = 0;
			REP(j, i+1, 366) {
				if(j % 7 == 1) {
					cnt++;
				}
			}
			ans = max(ans, dp[i] * pow(1.0 + rate / 1000.0, cnt));
		}
		return ans;
	}
};
```
]]></content>
  </entry>
  
</feed>
