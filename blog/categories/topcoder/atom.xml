<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: topcoder | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/topcoder/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-11-19T01:27:19+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM328 D1M BlockEnemy]]></title>
    <link href="http://ry0u.github.io/blog/2016/11/19/srm328-d1m-blockenemy/"/>
    <updated>2016-11-19T00:36:04+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/11/19/srm328-d1m-blockenemy</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6852&rd=10008">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

グラフが与えられる．$occupiedTowns[i]$同士が繋がっていないようにするために，辺を切る最小コストを求める．

---

まずは最小全域木を作る．すると木になったので$root$を$0$に決めて，dfsする．

$$
	dfs(cur, pre) := cur以下の部分木をoccupiedTowns同士が繋がらないようにした時の最小コスト\\\
	dp[i] := i以下の部分木を分離するための最小コスト
$$

葉まで行った時は，$occupiedTowns$の時は$dp[i]$をその辺のコストにして，そうでない場合は切る必要がないので$0$にして$0$を返す．ここから場合分け．今見ている頂点が$occupiedTowns$ではないときを考える．

{% img /images/SRM/328_1.png %}

今訪れている頂点が$1$で，赤の枠で囲まれている場所が$occupiedTowns$，辺のコストはそれぞれ$l$である．この時，このまま頂点$2$に伸びる辺と頂点$4$に伸びる頂点をつないでしまうと，$2$から$4$へ行けてしまうので何とかしなければならない．頂点$2$へ行く方法を切ってしまうと考えた場合，そこへ伸びる辺を切る方法と，頂点$2$以下の部分木を分離してしまう方法がある．下の図でいうと$l1$と$dp[2]$である．これらの$min$が頂点$2$へ行く方法を切る時の最小コストである．

{% img /images/SRM/328_2.png %}

同様に頂点$4$についても$min(l3, dp[4])$である．小さい順につながってしまうとダメな場所$-1$個の場所に行けないようにする．最後の残っている所を親に引き継ぐ(親を赤の枠にする)．今見ている頂点が$occupiedTowns$の時は，子の赤い枠の場所は全て切らねばならないので，その辺を切るか$dp$を切るかの小さい方の合計を持ち上げる．$dfs(0, -1)$の戻り値がそのまま答えとなる．


```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

vector<string> split(const string &str, char delim) {
	vector<string> res;
	size_t current = 0, found;
	while((found = str.find_first_of(delim, current)) != string::npos) {
		res.push_back(string(str, current, found - current));
		current = found + 1;
	}
	res.push_back(string(str, current, str.size() - current));
	return res;
}

int f(string s) {
	int ret;
	stringstream ss(s);
	ss >> ret;
	return ret;
}

struct UnionFind {
	vector<int> par, rank;
	int N;

	UnionFind(int n) {
		N = n;
		par.resize(n);
		rank.resize(n);

		rep(i, n) {
			par[i] = i;
			rank[i] = 0;
		}
	}

	int find(int x) {
		if(par[x] == x) return x;
		else return par[x] = find(par[x]);
	}

	void unite(int x, int y) {
		x = find(x);
		y = find(y);

		if(x == y) return;

		if(rank[x] < rank[y]) {
			par[x] = y;
		} else {
			par[y] = x;
			if(rank[x] == rank[y]) rank[x]++;
		}
	}

	bool same(int x, int y) {
		return find(x) == find(y);
	}

	int size() {
		int cnt = 0;
		rep(i, N) if(find(i) == i) cnt++;
		return cnt;
	}
};

struct edge {
	int from,to;
	int cost;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int f,int t,int c) : from(f),to(t),cost(c) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

vector<edge> G[55];
int dist[55][55];

int kruskal(int n, vector<edge> v) {
	sort(v.begin(),v.end());

	UnionFind uf(n);
	rep(i, 55) G[i].clear();
	rep(i, 55) rep(j, 55) dist[i][j] = INF;

	int ret = 0;
	rep(i, v.size()) {
		edge e = v[i];
		if(!uf.same(e.from,e.to)) {
			uf.unite(e.from,e.to);
			ret += e.cost;

			G[e.from].push_back(edge(e.to, e.cost));
			G[e.to].push_back(edge(e.from, e.cost));

			dist[e.from][e.to] = e.cost;
			dist[e.to][e.from] = e.cost;

			// cout << e.from << " -- " << e.to << " [label = \"" << e.cost << "\"];" << endl;
		}
	}

	return ret;
}

bool O[55];
int dp[55]; // 部分木iを消す時の最善
int n;

int dfs2(int cur, int pre) {
	int cnt = 0;
	rep(i, G[cur].size()) {
		edge e = G[cur][i];
		if(e.to == pre) continue;
		cnt++;
	}

	if(cnt == 0) {
		if(O[cur]) {
			dp[cur] = dist[cur][pre];
			return 0;
		} else {
			dp[cur] = 0;
			return 0;
		}
	}

	vector<int> v;
	int ret = 0;
	rep(i, G[cur].size()) {
		edge e = G[cur][i];
		if(e.to == pre) continue;

		int x = dfs2(e.to, cur);
		ret += x;
		int res = min(dp[e.to], dist[e.to][cur]);

		if(res == 0) continue;
		v.push_back(res);
	}

	if(O[cur]) {
		int sum = 0;
		rep(i, v.size()) {
			sum += v[i];
		}
		return sum + ret;
	} else {
		if(v.size() == 0) {
			dp[cur] = 0;
			return ret;
		}
		else if(v.size() == 1) {
			dp[cur] = v[0];
			return ret;
		} else {
			sort(v.begin(), v.end());

			int sum = 0;
			rep(i, v.size()-1) {
				sum += v[i];
			}

			dp[cur] = v[v.size()-1];
			return sum + ret;
		}
	}
}

class BlockEnemy {
	public:
	int minEffort(int N, vector <string> roads, vector <int> occupiedTowns) {
		n = N;
		memset(O, 0, sizeof(O));
		rep(i, occupiedTowns.size()) {
			O[occupiedTowns[i]] = true;
		}

		rep(i, 55) dp[i] = INF;

		vector<edge> E;
		rep(i, roads.size()) {
			vector<string> ret = split(roads[i], ' ');

			int a = f(ret[0]);
			int b = f(ret[1]);
			int e = f(ret[2]);

			E.push_back(edge(a, b, e));
		}

		kruskal(N, E);

		return dfs2(0, -1);
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM328 D1E-D2M LightsCube]]></title>
    <link href="http://ry0u.github.io/blog/2016/11/19/srm328-d1e-d2m-lightscube/"/>
    <updated>2016-11-19T00:24:30+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/11/19/srm328-d1e-d2m-lightscube</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7250&rd=10008">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

一辺が$N$の立方体の中に色$i$の明かりが与えられる．明かりは位置ステップ事に隣接している場所に広がる．広がる場所に重なりがあった場合は，番号が若い方が優先される．最終的に色$i$の光は何個あるか．愚直にやる．番号が若い順にやりたいので，最初のqueueに番号順に入れていく．後は順番に更新していけばよい．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;
typedef pair<P, int> PI;

vector<string> split(const string &str, char delim) {
	vector<string> res;
	size_t current = 0, found;
	while((found = str.find_first_of(delim, current)) != string::npos) {
		res.push_back(string(str, current, found - current));
		current = found + 1;
	}
	res.push_back(string(str, current, str.size() - current));
	return res;
}

int f(string s) {
	stringstream ss;
	ss << s;

	int x;
	ss >> x;

	return x;
}

int d[50][50][50], n;
int dx[6] = {1,-1, 0, 0, 0, 0};
int dy[6] = {0, 0, 1,-1, 0, 0};
int dz[6] = {0, 0, 0, 0, 1,-1};

bool can(int x, int y, int z) {
	if(0 <= x && x < n && 0 <= y && y < n && 0 <= z && z < n) return true;
	return false;
}

class LightsCube {
	public:
	vector <int> count(int N, vector <string> lights) {
		n = N;
		memset(d, -1, sizeof(d));
		queue<PI> que;
		rep(i, lights.size()) {
			vector<string> ret = split(lights[i], ' ');

			int x = f(ret[0]);
			int y = f(ret[1]);
			int z = f(ret[2]);

			d[x][y][z] = i;
			que.push(mp(mp(x, y), z));
		}

		while(que.size()) {
			PI p = que.front(); que.pop();

			int x = p.first.first;
			int y = p.first.second;
			int z = p.second;

			rep(i, 6) {
				int nx = x + dx[i];
				int ny = y + dy[i];
				int nz = z + dz[i];

				if(can(nx, ny, nz) && d[nx][ny][nz] == -1) {
					d[nx][ny][nz] = d[x][y][z];
					que.push(mp(mp(nx, ny), nz));
				}
			}
		}

		vector<int> v(lights.size());
		rep(i, N) {
			rep(j, N) {
				rep(k, N) {
					v[d[i][j][k]]++;
				}
			}
		}

		return v;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM327 D1E-D1H NiceOrUgly]]></title>
    <link href="http://ry0u.github.io/blog/2016/11/18/srm327-d1e-d1h-niceorugly/"/>
    <updated>2016-11-18T23:51:14+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/11/18/srm327-d1e-d1h-niceorugly</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6871&rd=10007">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

母音が$3$つ連続，または子音が$5$つ連続する場合はその文字列は$ugly$である．$nice$とは$ugly$ではない文字列の事を言う．'?'はどの文字列にも変更することができる．$nice$にも$ugly$である場合は$42$を，そうではに場合はその文字列がどちらかを返す．

---

$$
	dp[i][j][k][0] := i番目までに母音がj文字連続，子音がk文字連続して，未だuglyでない\\\
	dp[i][j][k][1] := i番目までに母音がj文字連続，子音がk文字連続して，既にugly
$$

として動的計画法．はてなの場合は，母音にするか子音にするか選べるので，どちらにも遷移する．後は今見ている文字通りに遷移する．母音が$3$つ連続，または子音が$5$つ連続がどこかでしていた場合，$ugly$になる可能性がある．その中で最後まで$ugly$にならなかったものがあれば，双方になり得るので$42$とする．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

bool vowels(char c) {
	if(c == 'A'|| c == 'E' || c == 'I' || c == 'O' ||  c == 'U') return true;
	return false;
}

bool dp[55][55][55][2];

class NiceOrUgly {

    public:

    string describe(string s) {
		
		memset(dp, 0, sizeof(dp));
		dp[0][0][0][0] = true;

		rep(i, s.size()) {
			rep(j, 3) {
				rep(k, 5) {
					rep(l, 2) {
						if(dp[i][j][k][l]) {
							if(s[i] == '?') {
								if(j + 1 == 3) {
									dp[i+1][j+1][0][1] = true;
								} else {
									dp[i+1][j+1][0][0] = true;
								}

								if(k + 1 == 5) {
									dp[i+1][0][k+1][1] = true;
								} else {
									dp[i+1][0][k+1][0] = true;
								}
							} else {
								if(vowels(s[i])) {
									if(j + 1 == 3) {
										dp[i+1][j+1][0][1] = true;
									} else {
										dp[i+1][j+1][0][0] = true;
									}
								} else {
									if(k + 1 == 5) {
										dp[i+1][0][k+1][1] = true;
									} else {
										dp[i+1][0][k+1][0] = true;
									}
								}
							}
						}
					}
				}
			}
		}

		bool flag = false;
		rep(i, s.size() + 1) {
			rep(j, 4) {
				rep(k, 6) {
					flag |= dp[i][j][k][1];
				}
			}
		}

		if(flag) {
			bool check = false;
			rep(j, 4) {
				rep(k, 6) {
					check |= dp[s.size()][j][k][0];
				}
			}

			if(check) return "42";
			return "UGLY";
		}
		else return "NICE";
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM327 D2M IQTest]]></title>
    <link href="http://ry0u.github.io/blog/2016/11/18/srm327-d2m-iqtest/"/>
    <updated>2016-11-18T23:41:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/11/18/srm327-d2m-iqtest</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6600&rd=10007">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

数列が与えられる．必ず$a \times x[i] + b = x[i+1]$となっている．この$a, b$が複数ある場合は$AMBIGUITY$，一つもない場合は$BUG$，唯一ある場合はその数列の次の値を返す．$a$を決め打ちすると，最初の二つから$b$が決まる．後はこの法則通りに並んでいるかを確かめる．要素が1個の場合のみ，この方法では出来ないので先にはじいておいた．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

class IQTest {

    public:

    string nextNumber(vector <int> previous) {

		vector<ll> v(previous.begin(), previous.end());

		if(v.size() == 1) return "AMBIGUITY";

		set<ll> st;

		REP(a, -100000, 100000) {
			ll b = v[1] - (v[0] * a);
			bool ch = true;

			rep(i, v.size()-1) {
				if(v[i] * a + b == v[i+1]) continue;
				ch = false;
			}

			if(ch) {
				st.insert(v[v.size()-1] * a + b);
			}
		}

		if(st.size() == 0) return "BUG";

		if(st.size() == 1) {
			stringstream ss;
			ss << *(st.begin());
			return ss.str();
		}

		return "AMBIGUITY";
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM326 D2H PoolFiller]]></title>
    <link href="http://ry0u.github.io/blog/2016/11/18/srm326-d2h-poolfiller/"/>
    <updated>2016-11-18T23:27:49+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/11/18/srm326-d2h-poolfiller</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6731&rd=10006https://community.topcoder.ciom/stat?c=problem_statement&pm=6803&rd=10006">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

プールのそれぞれの高さが与えられる．そのプールに貯めることができる水の量を返す．

---

回りが自分の所より高いブロックで囲われている場合にそこには水がたまる．探索するときに，プールから出てしまえばその時点で囲われていないので，一回のdfsで埋めながら探索するわけではなくて，まず囲まれているかどうかを確認した後に1ブロックずつ埋めていくことにした

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int v[55][55], cnt, n, m;
bool flag, used[55][55];

int dy[4] = {1, 0, -1, 0};
int dx[4] = {0, 1, 0, -1};

void dfs(int i, int j, int val) {
	if(used[i][j]) return;

	cnt++;
	used[i][j] = true;

	rep(k, 4) {
		int y = i + dy[k];
		int x = j + dx[k];

		if(0 <= y && y < n && 0 <= x && x < m) {
			if(v[y][x] == val) {
				dfs(y, x, val);
			} else if(v[y][x] > val) {
				continue;
			} else {
				flag = false;
			}
		} else {
			flag = false;
		}
	}
}

void dfs2(int i, int j, int val) {
	if(v[i][j] == val) {
		v[i][j]++;

		rep(k, 4) {
			int y = i + dy[k];
			int x = j + dx[k];

			dfs2(y, x, val);
		}
	}
}

class PoolFiller {

    public:

    int getCapacity(vector <string> layout) {
		n = layout.size();
		m = layout[0].size();

		memset(v, 0, sizeof(v));

		rep(i, n) {
			rep(j, m) {
				int t = int(layout[i][j] - '0');
				v[i][j] = t;
			}
		}

		int ans = 0;
		rep(i, n) {
			rep(j, m) {
				flag = true;

				while(flag) {
					cnt = 0;
					memset(used, 0, sizeof(used));

					dfs(i, j, v[i][j]);

					if(flag) {
						ans += cnt;
						dfs2(i, j, v[i][j]);
					}
				}
			}
		}

		return ans;
    }
};
```
]]></content>
  </entry>
  
</feed>
