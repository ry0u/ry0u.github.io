<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: topcoder | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/topcoder/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-05-31T15:00:25+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM691 D2M Sunnygraphs2]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/31/srm691-d2m-sunnygraphs2/"/>
    <updated>2016-05-31T14:32:34+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/31/srm691-d2m-sunnygraphs2</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14302&rd=16730">TopCoder Statistics - Problem Statement</a></h4><p>Hero has just constructed a very specific graph. He started with n isolated vertices, labeled 0 through n-1. For each vertex i Hero then chose a vertex a[i] (other than i) and he added an edge that connected i and a[i]. This way he created a graph with n vertices and n edges.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>　<script type="math/tex"> 0 \sim n-1 </script>の <script type="math/tex"> n </script>個の頂点で構成されるグラフがある．頂点 <script type="math/tex"> i </script>は頂点 <script type="math/tex"> a[i] </script>と接続している．新しい頂点<script type="math/tex"> n </script>を加えることを考える．グラフの部分集合<script type="math/tex"> M </script>を選び，<script type="math/tex"> e \in M </script>の <script type="math/tex"> eとa[e] </script>の結ぶ辺をカットし， <script type="math/tex"> eとn </script>を接続する．これをした時に頂点<script type="math/tex"> 0 \sim n-1 </script>が連結している部分集合<script type="math/tex"> M </script>の選び方はいくつあるか？</p>

<h1>Code</h1>

<pre><code class="cpp">// BEGIN CUT HERE

// END CUT HERE
#line 5 "Sunnygraphs2.cpp"
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)

using namespace std;
typedef long long ll;

struct UnionFind {
    vector&lt;int&gt; par,rank;
    int N;

    UnionFind(int n) {
        N = n;
        par.resize(n);
        rank.resize(n);

        rep(i,n) {
            par[i] = i;
            rank[i] = 0;
        }
    }

    int find(int x) {
        if(par[x] == x) return x;
        else return par[x] = find(par[x]);
    }

    void unite(int x,int y) {
        x = find(x);
        y = find(y);

        if(x == y) return;

        if(rank[x] &lt; rank[y]) {
            par[x] = y;
        }
        else {
            par[y] = x;
            if(rank[x] == rank[y]) rank[x]++;
        }
    }

    bool same(int x,int y) {
        return find(x) == find(y);
    }

    int size() {
        int cnt = 0;
        rep(i,N) if(find(i) == i) cnt++;
        return cnt;
    }
};

vector&lt;int&gt; g[105];
int d[105];

int dfs(int cur) {
    rep(i, g[cur].size()) {
        int t = g[cur][i];
        if(d[t] != -1) {
            return abs(d[t] - d[cur]) + 1;
        }
        d[t] = d[cur] + 1;
        return dfs(t);
    }
    return 0;
}

class Sunnygraphs2 {
    public:
    long long count(vector &lt;int&gt; a) {
        int n = a.size();
        rep(i, 105) g[i].clear();

        UnionFind uf(n);
        rep(i, n) {
            uf.unite(i, a[i]);
            g[i].push_back(a[i]);
        }

        int m = uf.size();

        map&lt;int, vector&lt;int&gt; &gt; ma;
        rep(i, n) {
            ma[uf.find(i)].push_back(i);
        }

        ll ans = 1;
        map&lt;int, vector&lt;int&gt; &gt;::iterator ite;

        for(ite = ma.begin(); ite != ma.end(); ite++) {
            int root = ite-&gt;first;
            vector&lt;int&gt; v = ite-&gt;second;

            memset(d, -1, sizeof(d));
            d[root] = 0;

            rep(i, 105) g[i].clear();
            rep(i, v.size()) {
                g[v[i]].push_back(a[v[i]]);
            }
            int len = dfs(root);

            ll cy = 1;
            rep(i, len) cy *= 2;
            cy--;

            ll res = 1;
            rep(i, v.size()-len) res *= 2;

            cy *= res;
            ans *= cy;
            continue;
        }

        if(m == 1) ans++;
        return ans;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM691 D2E PlusoneGame]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/31/srm691-d2e-plusonegame/"/>
    <updated>2016-05-31T13:50:42+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/31/srm691-d2e-plusonegame</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14303&rd=16730">TopCoder Statistics - Problem Statement</a></h4><p>Hero plays a game with a deck of cards and a counter. Initially, the counter is set to zero. During the game Hero must play each card in the deck exactly once. He gets to choose the order in which he plays the cards. You are given the description of the deck in the String s.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>文字列 <script type="math/tex"> s </script>が与えられる． <script type="math/tex"> + </script>の場合はカウンターをインクリメント， <script type="math/tex"> 0 \sim 9 </script>の場合は現在のカウンターとその桁の数の差の絶対値分，ペナルティがたまる．ペナルティが最小にように文字列を並び替えたい．</p>

<p>各桁を引く前にカウンターがその数と同じだけたまっている状態になっていれば，ペナルティは <script type="math/tex"> 0 </script>となる． なので，<script type="math/tex"> + </script>があるだけ<script type="math/tex"> 0+11111+2222222+333333+44444\dots </script>のように交互に並べ，足りない場合は <script type="math/tex"> + </script>無しで，余った場合は最後につけた．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)

using namespace std;
typedef long long ll;

class Plusonegame {
    public:
    string getorder(string s) {
        int n = s.size();
        map&lt;char, int&gt; m;
        int cnt = 0;

        rep(i, n) {
            if(s[i] == '+') cnt++;
            else {
                m[s[i]]++;
            }
        }

        string ans = "";
        rep(i, 10) {
            char c = '0' + i;

            rep(j, m[c]) {
                ans += c;
            }

            if(cnt &gt; 0) {
                ans += '+';
                cnt--;
            }
        }

        while(cnt) {
            ans += '+';
            cnt--;
        }

        return ans;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM684D2H Autohamil]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/16/srm684d2h-autohamil/"/>
    <updated>2016-03-16T00:01:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/16/srm684d2h-autohamil</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14183&rd=16688">TopCoder Statistics - Problem Statement</a></h4><p>In this problem, all strings are binary strings. That is, each character of a string is either '0' or '1'. A deterministic finite automaton is a machine that processes strings. The automaton has a finite set of possible states. The states are numbered 0 through n-1, where n is the number of states.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>有向グラフが与えられるので，ハミルトン路があるかどうかを判定せよ．</p>

<hr />

<p>閉路があるので，強連結成分分解する．分解後のグラフで<script type="math/tex"> 0 </script>を始点に探索を始め，分かれ道があれば出来ないと思ったが，全然違うしサンプルも合わない．こういう場合は出来る．</p>

<p><img src="/images/SRM/684d2h.png"></p>

<p>強連結成分分解をしDAGになったので，トポロジカルソートしてトポロジカル順序で<script type="math/tex"> i \to i+1 </script>の辺があるかを調べる．また，トポロジカル順序の開始が<script type="math/tex"> 0 </script>で無い場合も出来ないことを忘れない(分からなかった)．</p>

<h1>Code</h1>

<pre><code class="cpp">struct SCC {
    int n;
    vector&lt;vector&lt;int&gt; &gt; g, rg, ng, scc; // rg: 逆グラフ, ng: 分解後のグラフ
    vector&lt;int&gt; res; // scc: 強連結成分に属する頂点, res:強連結成分の番号
    bool used[100005];

    SCC(int _n) {
        n = _n;
        g.resize(n); rg.resize(n) ; scc.resize(n); res.resize(n);
    }

    SCC(const vector&lt;vector&lt;int&gt; &gt; &amp;g) : n(g.size()), g(g), rg(n), scc(n), res(n) {
        rep(i, n) {
            rep(j, g[i].size()) rg[g[i][j]].push_back(i);
        }
    }

    // i-jに辺を追加する
    void add(int i, int j) {
        g[i].push_back(j);
        rg[j].push_back(i);
    }

    vector&lt;int&gt; vs;
    void dfs(int v) {
        used[v] = true;
        rep(i, g[v].size()) {
            if(!used[ g[v][i] ]) dfs(g[v][i]);
        }
        vs.push_back(v);
    }

    void rdfs(int v, int k) {
        used[v] = true;
        res[v] = k; 
        scc[k].push_back(v);
        rep(i, rg[v].size()) {
            if(!used[ rg[v][i] ]) rdfs(rg[v][i], k);
        }
    }

    void ng_make(int k) {
        ng.resize(k);
        rep(i, n) {
            set&lt;int&gt; S;
            rep(j, g[i].size()) {
                int to = g[i][j];
                if(res[i] == res[to]) continue;
                if(S.find(res[to]) != S.end()) continue;
                ng[res[i]].push_back(res[to]);
                S.insert(res[to]);
            }
        }
    }

    int run() {
        memset(used, 0, sizeof(used));
        rep(i, n) {
            if (!used[i]) dfs(i);
        }

        memset(used, 0, sizeof(used));
        int k = 0;
        for (int i = vs.size()-1; i &gt;= 0; i--) {
            if (!used[vs[i]]) rdfs(vs[i], k++);
        }

        ng_make(k);
        return k;
    }
};

bool used[55];
vector&lt; vector&lt;int&gt; &gt; ng;
vector&lt;int&gt; out;

void dfs(int cur) {
    used[cur] = true;
    rep(i, ng[cur].size()) {
        int v = ng[cur][i];
        if(!used[v]) dfs(v);
    }
    out.push_back(cur);
}

class Autohamil {
    public:
    string check(vector &lt;int&gt; z0, vector &lt;int&gt; z1) {
        int n = z0.size();
        SCC scc(n);

        rep(i, n) {
            if(i != z0[i]) scc.add(i, z0[i]);
            if(i != z1[i]) scc.add(i, z1[i]);
        }

        int m = scc.run();
        ng.resize(m);
        rep(i, m) {
            ng[i].resize(scc.ng[i].size());
            rep(j, scc.ng[i].size()) {
                ng[i][j] = scc.ng[i][j];
            }
        }

        int cnt[55];
        memset(cnt, 0, sizeof(cnt));
        rep(i, m) {
            rep(j, ng[i].size()) {
                cnt[ng[i][j]]++;
            }
        }

        REP(i, 1, m) {
            if(cnt[i] == 0) return "Does not exist";
        }

        int s = scc.res[0];
        memset(used, 0, sizeof(used));
        out.clear();
        dfs(s);
        reverse(out.begin(), out.end());

        if(out[0] != 0) return "Does not exist";

        rep(i, out.size()-1) {
            bool ch = false;
            rep(j, ng[out[i]].size()) {
                if(ng[out[i]][j] == out[i+1]) {
                    ch = true;
                }
            }

            if(ch) continue;
            return "Does not exist";
        }
        return "Exists";
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM684D2M DivFreed2]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/15/srm684d2m-divfreed2/"/>
    <updated>2016-03-15T23:11:13+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/15/srm684d2m-divfreed2</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14186&rd=16688">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>数列の隣り合う全ての要素<script type="math/tex"> A(1 \leq A \leq k), B(1 \leq B \leq k) </script>が</p>

<ul>
<li><script type="math/tex"> A \leq B </script></li>
<li><script type="math/tex"> A \ \rm{mod} \  B \neq 0 </script></li>
</ul>


<p>のどちらかを満たす数列の数を<script type="math/tex"> \rm{mod} \ 10 ^9 + 7 </script> で求める．</p>

<hr />

<p><script type="math/tex; mode=display">
    dp[i][j] := i番目にjを選んだ時の数列の数
</script></p>

<p>とする．数列に追加する可能なものを選ぶので<script type="math/tex"> B </script>から考えると，<script type="math/tex"> B </script>より大きい，または<script type="math/tex"> AがB </script>を約数に持たなければ良い．基本的に全て遷移可能として(<script type="math/tex"> dp[i+1][j] += \sum_{l = 1} ^{k} dp[i][l]</script>)，後に約数の場所の遷移を無かったことにすれば良い．</p>

<h1>Code</h1>

<pre><code class="cpp">ll dp[15][100005];
vector&lt;ll&gt; d[100005];

vector&lt;ll&gt; divisor(ll n) {
    vector&lt;ll&gt; res;
    for(ll i = 2; i*i &lt;= n; i++) {
        if(n % i == 0) {
            res.push_back(i);
            if(i != n/i) res.push_back(n/i);
        }
    }
    return res;
}

class DivFreed2 {
    public:
    int count(int n, int k) {
        memset(dp, 0, sizeof(dp));

        rep(i, k + 1) {
            d[i].clear();
        }

        REP(i, 2, k + 1) {
            vector&lt;ll&gt; ret = divisor(i);
            ret.push_back(1);

            d[i].resize(ret.size());
            rep(j, ret.size()) {
                d[i][j] = ret[j];
            }
        }

        REP(i, 1, k + 1) {
            dp[1][i] = 1;
        }

        REP(i, 1, n) {
            ll sum = 0;
            REP(j, 1, k + 1) {
                sum += dp[i][j];
                sum %= MOD;
            }

            REP(j, 1, k + 1) {
                dp[i+1][j] += sum;
                dp[i+1][j] %= MOD;
            }

            REP(j, 1, k + 1) {
                rep(l, d[j].size()) {
                    dp[i+1][d[j][l]] -= dp[i][j];
                }
            }
        }

        ll ans = 0;
        rep(j, k + 1) {
            ans += dp[n][j];
            ans %= MOD;
        }

        return ans;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM683 D2H SubtreesCounting]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/04/srm683-d2h-subtreescounting/"/>
    <updated>2016-03-04T16:38:35+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/04/srm683-d2h-subtreescounting</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14179&rd=16653">TopCoder Statistics - Problem Statement</a></h4><p>You are given an undirected tree T. (The input format is specified below.) The vertices of the tree are numbered 0 through n-1. A subtree of T is any subgraph of T that is connected. The size of a subtree is the number of vertices it contains.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<h3>Sample1</h3>

<p>Sample1で構成される木は
<img src="/images/SRM/683d2h-0.png">
である．この木の全ての部分木の頂点数は</p>

<p>頂点数 <script type="math/tex"> 1 \to </script>
<img src="/images/SRM/683d2h-1.png">
<img src="/images/SRM/683d2h-2.png">
<img src="/images/SRM/683d2h-3.png"></p>

<p>頂点数 <script type="math/tex"> 2 \to </script>
<img src="/images/SRM/683d2h-4.png">
<img src="/images/SRM/683d2h-5.png"></p>

<p>頂点数 <script type="math/tex"> 3 \to </script>
<img src="/images/SRM/683d2h-6.png"></p>

<p>よって<script type="math/tex"> 1 + 1 + 1 + 2 + 2 + 3 = 10 </script>である．</p>

<hr />

<p>頂点<script type="math/tex"> i </script>を根とする木に頂点<script type="math/tex"> j </script>を根とする木を付け加える場合を考える．<br/>
<img src="/images/SRM/683d2h-7.png">
を
<img src="/images/SRM/683d2h-8.png">
としたい．<br/>
この時，
<script type="math/tex; mode=display">
\begin{eqnarray}
    dp[i] &amp;:=&amp; iを根とする全ての部分木の頂点数の和 \
    num[i] &amp;:=&amp; iを根とする部分木の個数
\end{eqnarray}
</script>
とすると，頂点数<script type="math/tex">dp[i]はdp[j] * num[i] + dp[i] * num[j] </script>だけ増加する．</p>

<ul>
<li><script type="math/tex"> dp[j] * num[i] </script><br/>
  <img src="/images/SRM/683d2h-9.png">
  <img src="/images/SRM/683d2h-10.png">
  <img src="/images/SRM/683d2h-11.png">
  <img src="/images/SRM/683d2h-12.png"></li>
<li><script type="math/tex"> dp[i] * num[j] </script><br/>
  <img src="/images/SRM/683d2h-12.png">
  <img src="/images/SRM/683d2h-13.png">
  <img src="/images/SRM/683d2h-14.png">
  <img src="/images/SRM/683d2h-15.png">
  <img src="/images/SRM/683d2h-16.png">
  <img src="/images/SRM/683d2h-17.png">
  <img src="/images/SRM/683d2h-18.png">
  <img src="/images/SRM/683d2h-19.png">
  <img src="/images/SRM/683d2h-20.png"></li>
</ul>


<p>同様に部分木の個数<script type="math/tex"> num[i]はnum[i] * num[j] </script>だけ増加する．適当に根を決め，潜って元の頂点に戻る時に足していく．自分の全ての子を潜り終わったらそれ以上変更があることはないので数える．</p>

<h1>Code</h1>

<pre><code class="cpp">struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[100005];
ll dp[100005], num[100005], cnt[100005];
bool used[100005];

void dfs(int cur) {
    used[cur] = true;
    dp[cur] = 1;
    num[cur] = 1;

    rep(i, G[cur].size()) {
        int to = G[cur][i].to;

        if(!used[to]) {
            dfs(to);

            dp[cur] += (dp[cur] * num[to]) + (dp[to] * num[cur]);
            num[cur] += num[cur] * num[to];

            dp[cur] %= MOD;
            num[cur] %= MOD;
        }
    }

    cnt[cur] = dp[cur];
}

class SubtreesCounting {
    public:
    int sumOfSizes(int n, int a0, int b, int c, int m) {

        rep(i, 100005) G[i].clear();

        vector&lt;ll&gt; v(n);
        v[0] = a0;

        REP(i, 1, n-1) {
            v[i] = (b * v[i-1]) % m + c;
            v[i] %= m;
        }

        REP(i, 1, n) {
            int j = v[i-1] % i;
            G[i].push_back(edge(j, 1));
            G[j].push_back(edge(i, 1));
        }

        memset(dp, 0, sizeof(dp));
        memset(num, 0, sizeof(num));
        memset(cnt, 0, sizeof(cnt));
        memset(used, 0, sizeof(used));

        dfs(0);

        ll ans = 0;
        rep(i, n) {
            ans += cnt[i];
            ans %= MOD;
        }

        return ans;
    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
