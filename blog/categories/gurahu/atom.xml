<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: グラフ | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/gurahu/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-06-09T14:11:03+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ2151 Brave Princess Revisited]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/09/aoj2151-brave-princess-revisited/"/>
    <updated>2016-06-09T13:59:08+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/09/aoj2151-brave-princess-revisited</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151">Brave Princess Revisited | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>状態を(襲われる盗賊や刺客の人数, お金, 頂点番号)としてdijkstra．現在の状態から次の状態への遷移は，護衛を雇わないで盗賊に襲われる，護衛を雇い守ってもらう，の$2$つである．お金が辺の長さより少ない場合は護衛を雇えないことに注意する．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;
typedef pair&lt;P, int&gt; PI;

struct edge {
    int from,to;
    int cost, res;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int t,int c,int r) : to(t), cost(c), res(r) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[105];
int d[105][105];

void dijkstra(int s, int l) {
    rep(i, 105) rep(j, 105) d[i][j] = INF;
    d[s][l] = 0;

    priority_queue&lt;PI, vector&lt;PI&gt;, greater&lt;PI&gt; &gt; que;
    que.push(mp(mp(0, -l), s));

    while(que.size()) {
        PI p = que.top(); que.pop();
        int cost = p.first.first;
        int coin = p.first.second;
        int v = p.second;
        coin *= -1;

        if(d[v][coin] &lt; cost) continue;

        rep(i, G[v].size()) {
            edge e = G[v][i];

            if(d[e.to][coin] &gt; d[v][coin] + e.res) {
                d[e.to][coin] = d[v][coin] + e.res;
                que.push(mp(mp(d[e.to][coin], -coin), e.to));
            }

            int nc = coin - e.cost;
            if(nc &gt;= 0 &amp;&amp; d[e.to][nc] &gt; d[v][coin]) {
                d[e.to][nc] = d[v][coin];
                que.push(mp(mp(d[e.to][nc], -nc), e.to));
            }
        }

    }
}

int main() {
    int n, m, l;
    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; l)  {
        if(n == 0 &amp;&amp; m == 0 &amp;&amp; l == 0) break;

        rep(i, 105) G[i].clear();

        rep(i, m) {
            int a, b, c, d;
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;

            a--; b--;

            G[a].push_back(edge(b, c, d));
            G[b].push_back(edge(a, c, d));
        }

        dijkstra(0, l);

        int ans = INF;
        rep(i, l+1) {
            ans = min(ans, d[n-1][i]);
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2608 Minus One]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/06/aoj2608-minus-one/"/>
    <updated>2016-06-06T23:24:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/06/aoj2608-minus-one</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2608">Minus One | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>$G$に$e$を付け加えて無向グラフにおける$s$から$t$への最短路の長さより$1$だけ大きいものの個数を答える．これはつまり，パスを貼った時に最短経路長が$1$小さくなるものである．</p>

<p>$s$からの最短経路長を$d[i]$，$t$からの最短経路長を$d2[i]$とする．点$a$と点$b$を結んだ場合，$s \to a \to b \to t$という経路を行くとすると，コストは$d[a] + 1 + d2[b]$となる．この時$s \to t$の最短経路長$+1$となる経路は，
$$
\begin{eqnarray}
    d[t] - 1 &amp;=&amp; d[a] + 1 + d2[b] \\
    d2[b] &amp;=&amp; d[t] - 2 - d[a]
\end{eqnarray}
$$
が条件となる．愚直に$a, b$のペアを列挙して確認すると$O(n ^2)$で間に合わないが，点$a$を決めた時に，経路長$1$少なくなる$b$の選び方は$d[t] - 2 - d[a]$となる$d2[i]$の個数と決まるので，先に$d2[i]$をカウントしておくと$O(n)$で求められる．最短経路を求めるのが一番時間がかかるので全体で$O(n logn)$．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[100005];
int d[100005], d2[100005], cnt[100005];

void dijkstra(int s) {
    priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que;
    rep(i, 100005) d[i] = INF;

    que.push(mp(0, s));
    d[s] = 0;

    while(que.size()) {
        P p = que.top(); que.pop();
        int cost = p.first;
        int v = p.second;

        if(d[v] &lt; cost) continue;

        rep(i, G[v].size()) {
            edge e = G[v][i];
            if(d[e.to] &gt; d[v] + e.cost) {
                d[e.to] = d[v] + e.cost;
                que.push(mp(d[e.to], e.to));
            }
        }
    }
}

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    int s, t;
    cin &gt;&gt; s &gt;&gt; t;
    s--; t--;

    rep(i, m) {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        a--; b--;

        G[a].push_back(edge(b, 1));
        G[b].push_back(edge(a, 1));
    }

    dijkstra(s);
    rep(i, n) d2[i] = d[i];

    dijkstra(t);
    rep(i, n) swap(d[i], d2[i]);

    memset(cnt, 0, sizeof(cnt));
    rep(i, n) {
        if(d2[i] == INF) continue;
        cnt[d2[i]]++;
    }

    ll ans = 0;
    rep(i, n) {
        if(d[i] == INF || d2[i] == INF) continue;
        int x = d[t] - 2 - d[i];

        if(x &gt;= 0) {
            ans += cnt[x];
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>経路復元とか色々していて，色々考えた後に書き直したら非常にスッキリして面白いと思った．但し解くのに時間がかかりすぎている&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM691 D2M Sunnygraphs2]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/31/srm691-d2m-sunnygraphs2/"/>
    <updated>2016-05-31T14:32:34+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/31/srm691-d2m-sunnygraphs2</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14302&rd=16730">TopCoder Statistics - Problem Statement</a></h4><p>Hero has just constructed a very specific graph. He started with n isolated vertices, labeled 0 through n-1. For each vertex i Hero then chose a vertex a[i] (other than i) and he added an edge that connected i and a[i]. This way he created a graph with n vertices and n edges.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>　<script type="math/tex"> 0 \sim n-1 </script>の <script type="math/tex"> n </script>個の頂点で構成されるグラフがある．頂点 <script type="math/tex"> i </script>は頂点 <script type="math/tex"> a[i] </script>と接続している．新しい頂点<script type="math/tex"> n </script>を加えることを考える．グラフの部分集合<script type="math/tex"> M </script>を選び，<script type="math/tex"> e \in M </script>の <script type="math/tex"> eとa[e] </script>の結ぶ辺をカットし， <script type="math/tex"> eとn </script>を接続する．これをした時に頂点<script type="math/tex"> 0 \sim n-1 </script>が連結している部分集合<script type="math/tex"> M </script>の選び方はいくつあるか？</p>

<p><img src="/images/SRM/691d2m.png"></p>

<p>連結成分ごとで考える．全てを繋げたいので，それぞれの連結成分の中の組み合わせを掛けていけばよい．また，各頂点から必ず <script type="math/tex"> 1 </script>本のみ結ぶ辺が出ているので，連結成分は必ず <script type="math/tex"> 1 </script>つの閉路を持つので，各連結成分の組み合わせの数は， <script type="math/tex"> (2 ^{サイクル長} - 1) \times 2 ^{連結成分の頂点数-サイクル長} </script>となる(サイクルの方の組み合わせはサイクル全てを選ばないと全てが連結でなくなるので <script type="math/tex"> -1 </script>)．unionfindで連結成分を調べて，各連結成分ごとにdfsしてサイクル長を出した．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;map&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)

using namespace std;
typedef long long ll;

struct UnionFind {
    vector&lt;int&gt; par,rank;
    int N;

    UnionFind(int n) {
        N = n;
        par.resize(n);
        rank.resize(n);

        rep(i,n) {
            par[i] = i;
            rank[i] = 0;
        }
    }

    int find(int x) {
        if(par[x] == x) return x;
        else return par[x] = find(par[x]);
    }

    void unite(int x,int y) {
        x = find(x);
        y = find(y);

        if(x == y) return;

        if(rank[x] &lt; rank[y]) {
            par[x] = y;
        }
        else {
            par[y] = x;
            if(rank[x] == rank[y]) rank[x]++;
        }
    }

    bool same(int x,int y) {
        return find(x) == find(y);
    }

    int size() {
        int cnt = 0;
        rep(i,N) if(find(i) == i) cnt++;
        return cnt;
    }
};

vector&lt;int&gt; g[105];
int d[105];

int dfs(int cur) {
    rep(i, g[cur].size()) {
        int t = g[cur][i];
        if(d[t] != -1) {
            return abs(d[t] - d[cur]) + 1;
        }
        d[t] = d[cur] + 1;
        return dfs(t);
    }
    return 0;
}

class Sunnygraphs2 {
    public:
    long long count(vector &lt;int&gt; a) {
        int n = a.size();
        rep(i, 105) g[i].clear();

        UnionFind uf(n);
        rep(i, n) {
            uf.unite(i, a[i]);
            g[i].push_back(a[i]);
        }

        int m = uf.size();

        map&lt;int, vector&lt;int&gt; &gt; ma;
        rep(i, n) {
            ma[uf.find(i)].push_back(i);
        }

        ll ans = 1;
        map&lt;int, vector&lt;int&gt; &gt;::iterator ite;

        for(ite = ma.begin(); ite != ma.end(); ite++) {
            int root = ite-&gt;first;
            vector&lt;int&gt; v = ite-&gt;second;

            memset(d, -1, sizeof(d));
            d[root] = 0;

            rep(i, 105) g[i].clear();
            rep(i, v.size()) {
                g[v[i]].push_back(a[v[i]]);
            }
            int len = dfs(root);

            ll cy = 1;
            rep(i, len) cy *= 2;
            cy--;

            ll res = 1;
            rep(i, v.size()-len) res *= 2;

            cy *= res;
            ans *= cy;
            continue;
        }

        if(m == 1) ans++;
        return ans;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1280 Slim Span]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/21/aoj1280-slim-span/"/>
    <updated>2016-05-21T02:41:52+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/21/aoj1280-slim-span</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1280">Slim Span</a></h4><p>Given an undirected weighted graph G, you should find one of spanning trees specified as follows. A spanning tree T is a tree (a connected subgraph without cycles) which connects all the n vertices with n - 1 edges.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>The <script type="math/tex"> slimness </script> of a spanning tree Tは全域木を構成する辺の最大値 <script type="math/tex"> - </script>最小値と定義される．この値の最小値を求める．<br/>
出来るだけコストが近いものを使った方が良いので，まず使うコストの一番小さいものを決めて，それからコストを増やしていく．全域木が構成出来た時点でのコストのminを取る． <script type="math/tex"> O(nm) </script>．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct UnionFind {
    vector&lt;int&gt; par,rank;
    int N;

    UnionFind(int n) {
        N = n;
        par.resize(n);
        rank.resize(n);

        rep(i,n) {
            par[i] = i;
            rank[i] = 0;
        }
    }

    int find(int x) {
        if(par[x] == x) return x;
        else return par[x] = find(par[x]);
    }

    void unite(int x,int y) {
        x = find(x);
        y = find(y);

        if(x == y) return;

        if(rank[x] &lt; rank[y]) {
            par[x] = y;
        }
        else {
            par[y] = x;
            if(rank[x] == rank[y]) rank[x]++;
        }
    }

    bool same(int x,int y) {
        return find(x) == find(y);
    }

    int size() {
        int cnt = 0;
        rep(i,N) if(find(i) == i) cnt++;
        return cnt;
    }
};

int main() {
    int n, m;

    while(cin &gt;&gt; n &gt;&gt; m) {
        if(n == 0 &amp;&amp; m == 0) break;

        vector&lt;int&gt; a(m), b(m), c(m);
        map&lt;int, vector&lt;P&gt; &gt; es;
        rep(i, m) {
            cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];
            a[i]--; b[i]--;

            es[c[i]].push_back(P(a[i], b[i]));
        }

        int ans = INF;

        REP(i, 1, 10001) {
            if(es[i].size() == 0) continue;
            UnionFind uf(n);
            REP(j, i, 10001) {
                if(es[j].size() == 0) continue;
                rep(k, es[j].size()) {
                    int a = es[j][k].first;
                    int b = es[j][k].second;

                    if(uf.same(a, b)) continue;
                    uf.unite(a, b);
                }

                if(uf.size() == 1) {
                    ans = min(ans, j - i);
                    break;
                }
            }
        }

        if(ans == INF) cout &lt;&lt; -1 &lt;&lt; endl;
        else cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2005 Water Pipe Construction]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/20/aoj2005-water-pipe-construction/"/>
    <updated>2016-05-20T23:21:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/20/aoj2005-water-pipe-construction</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2005">Water Pipe Construction | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>水源<script type="math/tex"> s </script>から， <script type="math/tex"> 2つの </script>主要な基地 <script type="math/tex"> g_1, g_2 </script>まで水を運ぶための導水管の敷設にかかるコストを最小化する．<br/>
以下の<script type="math/tex"> 3 </script>パターンに分かれる．</p>

<p><img src="/images/AOJ/2005-1.png">
<img src="/images/AOJ/2005-2.png">
<img src="/images/AOJ/2005-3.png"></p>

<p>　<script type="math/tex"> n(3 \leq n \leq 100) </script>なのでwarshall-floydで最短経路を出してこの <script type="math/tex"> 3 </script>パターンのminを取った．<br/>
経路復元がいるかと思ったけど，いらなかった．もし <script type="math/tex"> s \to g1 \to g2 </script>で <script type="math/tex"> s \to g1 </script>と <script type="math/tex"> g1 \to g2 </script>の通る頂点に重なりがある場合，重複して道を数えているのでそのパターンではなく，パターン <script type="math/tex"> 3 </script>のケースの方が良い．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll d[105][105];
int to[105][105];

void warshall_floyd(int n, int m) {
    rep(i, n) rep(j, n) d[i][j] = INF;
    rep(i, n) d[i][i] = 0;

    rep(i, n) rep(j, n) to[i][j] = j;

    //input
    rep(i, m) {
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;

        a--; b--;
        d[a][b] = c;
        // d[b][a] = c;
    }

    rep(k,n) {
        rep(i,n) {
            rep(j,n) {
                if(d[i][k] == INF || d[k][j] == INF) continue;
                if(d[i][j] &gt; d[i][k] + d[k][j]) {
                    d[i][j] = d[i][k] + d[k][j];
                    to[i][j] = to[i][k];
                }
            }
        }
    }
}

vector&lt;int&gt; path(int s, int g) {
    int cur = s;
    vector&lt;int&gt; ret;
    for(; cur != g; cur = to[cur][g]) {
        ret.push_back(cur);
    }

    ret.push_back(g);
    return ret;
}

int main() {
    int n, m, s, g1, g2;
    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; g1 &gt;&gt; g2) {
        if(n == 0 &amp;&amp; m == 0 &amp;&amp; s == 0 &amp;&amp; g1 == 0 &amp;&amp; g2 == 0) break;

        s--; g1--; g2--;
        warshall_floyd(n, m);

        ll ans = INF;
        rep(i, n) {
            ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);
        }

        ans = min(ans, d[s][g1] + d[g1][g2]);
        ans = min(ans, d[s][g2] + d[g2][g1]);

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
