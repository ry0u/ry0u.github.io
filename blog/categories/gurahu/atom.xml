<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: グラフ | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/gurahu/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-22T22:11:56+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ2620 Trodden Cable]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj2620-trodden-cable/"/>
    <updated>2016-03-22T21:52:44+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj2620-trodden-cable</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2620">Trodden Cable</a></h4><p>Nathan O. Davis is running a company. His company owns a web service which has a lot of users. So his office is full of servers, routers and messy LAN cables. He is now very puzzling over the messy cables, because they are causing many kinds of problems. For example, staff working at the company often trip over a cable.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>全く分からずに調べた．</p>

<p><a href="http://acm-icpc.aitea.net/index.php?plugin=attach&amp;refer=2013%2FPractice%2F%E5%A4%8F%E5%90%88%E5%AE%BF%2F%E8%AC%9B%E8%A9%95&amp;openfile=trodden_cable.pdf:image=http://acm-icpc.aitea.net/index.php?plugin=attach&amp;refer=2013%2FPractice%2F%E5%A4%8F%E5%90%88%E5%AE%BF%2F%E8%AC%9B%E8%A9%95&amp;openfile=trodden_cable.pdf">http://acm-icpc.aitea.net/index.php?plugin=attach&amp;refer=2013%2FPractice%2F%E5%A4%8F%E5%90%88%E5%AE%BF%2F%E8%AC%9B%E8%A9%95&amp;openfile=trodden_cable.pdf:image=http://acm-icpc.aitea.net/index.php?plugin=attach&amp;refer=2013%2FPractice%2F%E5%A4%8F%E5%90%88%E5%AE%BF%2F%E8%AC%9B%E8%A9%95&amp;openfile=trodden_cable.pdf</a></p>

<p>この画像が非常に分かりやすい．移動する時にまたがる線のコストを<script type="math/tex"> +1 </script>して，移動が終わったグリッドグラフでdijkstra．</p>

<p>現在位置を(y, x)と置くと</p>

<ul>
<li><script type="math/tex"> R </script>の時， <script type="math/tex"> (y, x+1) \to (y+1, x+1) </script></li>
<li><script type="math/tex"> L </script>の時， <script type="math/tex"> (y, x) \to (y+1, x) </script></li>
<li><script type="math/tex"> U </script>の時， <script type="math/tex"> (y, x) \to (y, x+1) </script></li>
<li><script type="math/tex"> D </script>の時， <script type="math/tex"> (y+1, x) \to (y+1, x+1) </script></li>
</ul>


<p>に <script type="math/tex"> +1 </script>した．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int w, h, n;
int sx,sy,gx,gy;
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1};

bool can(int y, int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}

struct edge {
    int from,to;
    ll cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[505*505 + 5];
ll d[505 * 505 + 5];

void dijkstra(int s, int n) {
    priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que;
    fill(d, d+n, INF);

    d[s] = 0;
    que.push(P(0,s));

    while(que.size()) {
        P p = que.top();
        que.pop();

        int v = p.second;
        if(d[v] &lt; p.first) continue;

        rep(i, G[v].size()) {
            edge e = G[v][i];
            if(d[e.to] &gt; d[v] + e.cost) {
                d[e.to] = d[v] + e.cost;
                que.push(P(d[e.to],e.to));
            }
        }
    }
}

int main() {
    cin &gt;&gt; w &gt;&gt; h &gt;&gt; n;

    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; gx &gt;&gt; gy;

    rep(i, h * w) {
        G[i].clear();
    }

    w++;
    h++;

    rep(i, h) {
        rep(j, w) {
            rep(k, 4) {
                int y = i + dy[k];
                int x = j + dx[k];

                if(can(y, x)) {
                    G[i*w + j].push_back(edge(y*w + x, 0));
                }
            }
        }
    }

    rep(i, n) {
        int y, x, t;
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; t;

        string s;
        cin &gt;&gt; s;

        rep(k, t) {
            rep(j, s.size()) {
                int from = -1, to = -1;
                if(s[j] == 'R' &amp;&amp; x + 1 &lt; w - 1) {
                    from = y * w + (x + 1);
                    to = (y + 1) * w + (x + 1);
                    x++;
                } else if(s[j] == 'L' &amp;&amp; 0 &lt;= x - 1) {
                    from = y * w + x;
                    to = (y + 1) * w + x;
                    x--;
                } else if(s[j] == 'U' &amp;&amp; 0 &lt;= y - 1) {
                    from = y * w + x;
                    to = y * w + (x + 1);
                    y--;
                } else if(s[j] == 'D' &amp;&amp; y + 1 &lt; h - 1) {
                    from = (y + 1) * w + x;
                    to = (y + 1) * w + (x + 1);
                    y++;
                }

                if(from == -1 &amp;&amp; to == -1) continue;
                rep(k, G[from].size()) {
                    if(G[from][k].to == to) {
                        G[from][k].cost++;
                    }
                }
                rep(k, G[to].size()) {
                    if(G[to][k].to == from) {
                        G[to][k].cost++;
                    }
                }
            }
        }
    }

    // rep(i, h) {
    //  rep(j, w) {
    //      cout &lt;&lt; " --------- " &lt;&lt; i &lt;&lt; ", " &lt;&lt; j &lt;&lt; " :" &lt;&lt; i * w + j &lt;&lt; " |";
    //      rep(k, G[i*w + j].size()) {
    //          cout &lt;&lt; "(" &lt;&lt; G[i*w + j][k].to &lt;&lt; ", " &lt;&lt; G[i*w + j][k].cost &lt;&lt; ") ";
    //      }
    //      cout &lt;&lt; endl;
    //  }
    // }

    dijkstra(sy * w + sx, h * w);

    // rep(i, h) {
    //  rep(j, w) {
    //      cout &lt;&lt; d[i*w + j] &lt;&lt; " ";
    //  }
    //  cout &lt;&lt; endl;
    // }

    cout &lt;&lt; d[gy * w + gx] &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2386 Sightseeing Tour]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/22/aoj2386-sightseeing-tour/"/>
    <updated>2016-03-22T18:40:06+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/22/aoj2386-sightseeing-tour</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2386">Sightseeing Tour | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>隣接グラフが与えれる．全ての<script type="math/tex">2</script>点間を結ぶコストが最小であり，ハミルトン路を持つグラフのコストの和を答える．<br/>
完全グラフは向きにかかわらずに必ずハミルトン路を持つらしいので， <script type="math/tex"> 2 </script>点間のコストの小さい方を採用する．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    ll cost[105][105];
    memset(cost, 0, sizeof(cost));

    rep(i, n) {
        rep(j, n) cin &gt;&gt; cost[i][j];
    }

    ll ans = 0;
    rep(i, n) {
        REP(j, i+1, n) {
            ans += min(cost[i][j], cost[j][i]);
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0616 JOI Park]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj0616-joi-park/"/>
    <updated>2016-03-18T16:24:27+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj0616-joi-park</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0616">JOI Park | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>まず，<script type="math/tex"> 広場0 </script>からの各広場までの最短経路を求める．次に，コストが小さい順にソートし，その場所への到達コストを仮の<script type="math/tex"> X </script>と置き，整備する場所とする．整備される場所同士は，地下道を通して行き来できるためそのコストを全体から引く．始点を到達コスト<script type="math/tex"> 0 </script>の広場と見れば整備しない場合も考慮される．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1LL&lt;&lt;60
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[100005];
ll d[100005];
bool used[100005];

void dijkstra(int s,int n) {
    priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; que;
    fill(d,d+n,INF);

    d[s] = 0;
    que.push(P(0,s));

    while(que.size()) {
        P p = que.top();
        que.pop();

        int v = p.second;
        if(d[v] &lt; p.first) continue;

        rep(i,G[v].size()) {
            edge e = G[v][i];
            if(d[e.to] &gt; d[v] + e.cost) {
                d[e.to] = d[v] + e.cost;
                que.push(P(d[e.to],e.to));
            }
        }
    }
}

int main() {
    int n, m, c;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;

    ll sum = 0;
    rep(i, m) {
        int a, b, d;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;

        a--;
        b--;
        sum += d;

        G[a].push_back(edge(b, d));
        G[b].push_back(edge(a, d));
    }

    dijkstra(0, n);

    vector&lt;pair&lt;ll, int&gt; &gt; v(n);
    rep(i, n) {
        v[i].first = d[i];
        v[i].second = i;
    }

    sort(v.begin(), v.end());
    memset(used, 0, sizeof(used));

    ll ans = INF;
    rep(i, v.size()) {
        int j = v[i].second;
        used[j] = true;

        rep(k, G[j].size()) {
            if(used[G[j][k].to]) {
                sum -= G[j][k].cost;
            }
        }

        ans = min(ans, d[j] * c + sum);
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0605 Modern Mansion]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/16/aoj0605-modern-mansion/"/>
    <updated>2016-03-16T01:28:12+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/16/aoj0605-modern-mansion</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0605">Modern Mansion | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>状態を <script type="math/tex"> (cost, id, state) </script>として，現在どちら方向の扉が空いているかを持ってdijkstra．扉が空いている方向で最小値を更新出来る場所に行く．TLEを連発した．時間制限が1secで0.94secでギリギリ通した．変にlogをつけて死んでいた．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1LL&lt;&lt;60
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;
typedef pair&lt;P, bool&gt; PI;

int w, h, k;
vector&lt;P&gt; X[200005], Y[200005];
vector&lt;P&gt; xy;
ll d[200005][2];

// PI f(int a, int b, int c) {
//  return mp(mp(a, b), c);
// }

void dijkstra() {
    rep(i, 200005) {
        d[i][0] = INF;
        d[i][1] = INF;
    }

    // cost id (0 or 1)
    priority_queue&lt;PI, vector&lt;PI&gt;, greater&lt;PI&gt; &gt; que;

    rep(i, X[1].size()) {
        int y = X[1][i].first;
        int to = X[1][i].second;

        d[to][1] = y;
        // que.push(f(y, to, 1));
        que.push(mp(mp(y, to), 1));
    }

    while(que.size()) {
        PI p = que.top(); 
        que.pop();

        int c = p.first.first;
        int v = p.first.second;
        int state = p.second;

        if(d[v][state] &lt; c) continue;

        int y = xy[v].first;
        int x = xy[v].second;

        if(state == 0) {
            rep(i, X[x].size()) {
                int ny = X[x][i].first;
                int to = X[x][i].second;

                if(ny == y) continue;

                if(d[to][1] &gt; d[v][state] + abs(ny - y) + 1) {
                    d[to][1] = d[v][state] + abs(ny- y) + 1;
                    // que.push(f(d[to][1], to, 1));
                    que.push(mp(mp(d[to][1], to), 1));
                }
            }
        } else {
            rep(i, Y[y].size()) {
                int nx = Y[y][i].first;
                int to = Y[y][i].second;

                if(nx == x) continue;

                if(d[to][0] &gt; d[v][state] + abs(nx - x) + 1) {
                    d[to][0] = d[v][state] + abs(nx - x) + 1;
                    // que.push(f(d[to][0], to, 0));
                    que.push(mp(mp(d[to][0], to), 0));
                }
            }
        }
    }
}

int main() {
    cin &gt;&gt; w &gt;&gt; h &gt;&gt; k;

    xy.resize(k);
    rep(i, k) {
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;

        xy[i] = mp(y, x);
        X[x].push_back(mp(y, i));
        Y[y].push_back(mp(x, i));
    }

    dijkstra();

    ll ans = INF;
    rep(i, k) {
        int y = xy[i].first;
        int x = xy[i].second;

        if(y == h) {
            ans = min(ans, d[i][1] + abs(w - x));
        }

        if(x == w) {
            ans = min(ans, d[i][0] + abs(h - y));
        }
    }

    if(ans == INF) cout &lt;&lt; -1 &lt;&lt; endl;
    else cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM684D2H Autohamil]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/16/srm684d2h-autohamil/"/>
    <updated>2016-03-16T00:01:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/16/srm684d2h-autohamil</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14183&rd=16688">TopCoder Statistics - Problem Statement</a></h4><p>In this problem, all strings are binary strings. That is, each character of a string is either '0' or '1'. A deterministic finite automaton is a machine that processes strings. The automaton has a finite set of possible states. The states are numbered 0 through n-1, where n is the number of states.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>有向グラフが与えられるので，ハミルトン路があるかどうかを判定せよ．</p>

<hr />

<p>閉路があるので，強連結成分分解する．分解後のグラフで<script type="math/tex"> 0 </script>を始点に探索を始め，分かれ道があれば出来ないと思ったが，全然違うしサンプルも合わない．こういう場合は出来る．</p>

<p><img src="/images/SRM/684d2h.png"></p>

<p>強連結成分分解をしDAGになったので，トポロジカルソートしてトポロジカル順序で<script type="math/tex"> i \to i+1 </script>の辺があるかを調べる．また，トポロジカル順序の開始が<script type="math/tex"> 0 </script>で無い場合も出来ないことを忘れない(分からなかった)．</p>

<h1>Code</h1>

<pre><code class="cpp">struct SCC {
    int n;
    vector&lt;vector&lt;int&gt; &gt; g, rg, ng, scc; // rg: 逆グラフ, ng: 分解後のグラフ
    vector&lt;int&gt; res; // scc: 強連結成分に属する頂点, res:強連結成分の番号
    bool used[100005];

    SCC(int _n) {
        n = _n;
        g.resize(n); rg.resize(n) ; scc.resize(n); res.resize(n);
    }

    SCC(const vector&lt;vector&lt;int&gt; &gt; &amp;g) : n(g.size()), g(g), rg(n), scc(n), res(n) {
        rep(i, n) {
            rep(j, g[i].size()) rg[g[i][j]].push_back(i);
        }
    }

    // i-jに辺を追加する
    void add(int i, int j) {
        g[i].push_back(j);
        rg[j].push_back(i);
    }

    vector&lt;int&gt; vs;
    void dfs(int v) {
        used[v] = true;
        rep(i, g[v].size()) {
            if(!used[ g[v][i] ]) dfs(g[v][i]);
        }
        vs.push_back(v);
    }

    void rdfs(int v, int k) {
        used[v] = true;
        res[v] = k; 
        scc[k].push_back(v);
        rep(i, rg[v].size()) {
            if(!used[ rg[v][i] ]) rdfs(rg[v][i], k);
        }
    }

    void ng_make(int k) {
        ng.resize(k);
        rep(i, n) {
            set&lt;int&gt; S;
            rep(j, g[i].size()) {
                int to = g[i][j];
                if(res[i] == res[to]) continue;
                if(S.find(res[to]) != S.end()) continue;
                ng[res[i]].push_back(res[to]);
                S.insert(res[to]);
            }
        }
    }

    int run() {
        memset(used, 0, sizeof(used));
        rep(i, n) {
            if (!used[i]) dfs(i);
        }

        memset(used, 0, sizeof(used));
        int k = 0;
        for (int i = vs.size()-1; i &gt;= 0; i--) {
            if (!used[vs[i]]) rdfs(vs[i], k++);
        }

        ng_make(k);
        return k;
    }
};

bool used[55];
vector&lt; vector&lt;int&gt; &gt; ng;
vector&lt;int&gt; out;

void dfs(int cur) {
    used[cur] = true;
    rep(i, ng[cur].size()) {
        int v = ng[cur][i];
        if(!used[v]) dfs(v);
    }
    out.push_back(cur);
}

class Autohamil {
    public:
    string check(vector &lt;int&gt; z0, vector &lt;int&gt; z1) {
        int n = z0.size();
        SCC scc(n);

        rep(i, n) {
            if(i != z0[i]) scc.add(i, z0[i]);
            if(i != z1[i]) scc.add(i, z1[i]);
        }

        int m = scc.run();
        ng.resize(m);
        rep(i, m) {
            ng[i].resize(scc.ng[i].size());
            rep(j, scc.ng[i].size()) {
                ng[i][j] = scc.ng[i][j];
            }
        }

        int cnt[55];
        memset(cnt, 0, sizeof(cnt));
        rep(i, m) {
            rep(j, ng[i].size()) {
                cnt[ng[i][j]]++;
            }
        }

        REP(i, 1, m) {
            if(cnt[i] == 0) return "Does not exist";
        }

        int s = scc.res[0];
        memset(used, 0, sizeof(used));
        out.clear();
        dfs(s);
        reverse(out.begin(), out.end());

        if(out[0] != 0) return "Does not exist";

        rep(i, out.size()-1) {
            bool ch = false;
            rep(j, ng[out[i]].size()) {
                if(ng[out[i]][j] == out[i+1]) {
                    ch = true;
                }
            }

            if(ch) continue;
            return "Does not exist";
        }
        return "Exists";
    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
