<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: グラフ | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/gurahu/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-10T01:42:35+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM339 D2H OnTime]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/10/srm339-d2h-ontime/"/>
    <updated>2017-02-10T00:11:24+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/10/srm339-d2h-ontime</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7423&rd=10663">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

駅$0$から駅$n-1$に行きたい．空白区切りで$a\ b\ departure\ time\ cost$が与えられる．駅$a$と駅$b$を結ぶバスは，時刻$departure$に出発し，時間$time$かかり，コストは$cost$である．時刻$T$以内に駅$n-1$に着けない場合は$-1$，着ける場合は最小コストを答える．

---

(駅番号, 時刻)を状態にしてdijkstra．

```cpp
#include <bits/stdc++.h>

#define rep(i,n) for(int i=0;i<(int)(n);i++)
#define REP(i,k,n) for(int i=k;i<(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair<int, int> P;
typedef pair<P, int> PI;
typedef pair<P, P> PP;

vector<string> split(const string &str, char delim) {
	vector<string> res;
	size_t current = 0, found;
	while((found = str.find_first_of(delim, current)) != string::npos) {
		res.push_back(string(str, current, found - current));
		current = found + 1;
	}
	res.push_back(string(str, current, str.size() - current));
	return res;
}

vector<PP> G[55];
int d[55][100005];

void dijkstra() {
	rep(i, 55) rep(j, 100005) d[i][j] = INF;
	d[0][0] = 0;

	priority_queue<PI, vector<PI>, greater<PI> > que;
	que.push(mp(mp(0, 0), 0));

	while(que.size()) {
		PI p = que.top(); que.pop();
		int c = p.fi.fi;
		int t = p.fi.se;
		int cur = p.se;

		if(d[cur][t] < cur) continue;

		rep(i, G[cur].size()) {
			int departure = G[cur][i].fi.fi;
			int time = G[cur][i].fi.se;
			int cost = G[cur][i].se.fi;
			int next = G[cur][i].se.se;

			if(departure != 0 && time != 0 && departure <= t) continue;
			if(d[next][departure + time] > c + cost) {
				d[next][departure + time] = c + cost;
				que.push(mp(mp(c + cost, departure + time), next));
			}
		}
	}
}

class OnTime {
	public:
	int minCost(int N, int T, vector <string> buses) {
		rep(i, 55) G[i].clear();

		int M = buses.size();
		rep(i, M) {
			stringstream ss;
			ss << buses[i];
			int a, b, departure, time, cost;
			ss >> a >> b >> departure >> time >> cost;

			G[a].push_back(mp(mp(departure, time), mp(cost, b)));
		}

		dijkstra();

		int ans = INF;
		rep(i, T + 1) {
			ans = min(ans, d[N-1][i]);
		}

		if(ans == INF) return -1;
		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM335 D1M ExpensiveTravel]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/05/srm335-d1m-expensivetravel/"/>
    <updated>2017-02-05T22:49:18+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/05/srm335-d1m-expensivetravel</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7337&rd=10659">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$(startRow, startCol)$から$(endRow, endCol)$に移動したい．各マスは$k(1 \leq k \leq 9)$の種類があって，コストは$\frac{1}{k}$である．一回の移動はマスのコストの和が$1$以下でなければならない．何回の移動で$(endRow, endCol)$にたどり着けるか．

---

コスト和が$1$以下の$(x1, y1) \to (x2, y2)$を辺の重み$1$としてグラフを構成して，dijkstra．


```cpp
#include <bits/stdc++.h>

#define rep(i,n) for(int i=0;i<(int)(n);i++)
#define REP(i,k,n) for(int i=k;i<(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair
#define EPS 1e-4

#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair<int, int> P;
typedef pair<double, int> D;

int h, w;
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1};

bool can(int y, int x) {
	if(0 <= y && y < h && 0 <= x && x < w) return true;
	return false;
}

struct edge {
	int from,to;
	int cost;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int f,int t,int c) : from(f),to(t),cost(c) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

int d[100005];
vector<edge> G[10005];

void dijkstra(int s, int n) {
	priority_queue<P, vector<P>, greater<P> > que;
	rep(i, n) {
		d[i] = INF;
	}

	d[s] = 0;
	que.push(P(0,s));

	while(que.size()) {
		P p = que.top();
		que.pop();

		int v = p.second;
		if(d[v] < p.first) continue;

		rep(i, G[v].size()) {
			edge e = G[v][i];
			if(d[e.to] > d[v] + e.cost) {
				d[e.to] = d[v] + e.cost;
				que.push(P(d[e.to],e.to));
			}
		}
	}
}

class ExpensiveTravel {
	public:
	int minTime(vector <string> m, int startRow, int startCol, int endRow, int endCol) {
		h = m.size(), w = m[0].size();
		int n = h * w;

		double v[55][55];
		memset(v, 0, sizeof(v));
		rep(i, h) {
			rep(j, w) {
				int t = (m[i][j] - '0');
				v[i][j] = t;
			}
		}

		double cost[2505];

		rep(i, n) {
			G[i].clear();
		}

		rep(i, h) {
			rep(j, w) {
				rep(k, n) cost[k] = INF;
				cost[i*w+j] = 0;
				priority_queue<D, vector<D>, greater<D> > que;
				que.push(mp(1.0 / v[i][j], i * w + j));

				while(que.size()) {
					D di = que.top(); que.pop();
					int y = di.second / w;
					int x = di.second % w;

					rep(k, 4) {
						int ny = y + dy[k];
						int nx = x + dx[k];

						if(can(ny, nx) && cost[ny*w+nx] > di.first + 1.0 / v[ny][nx]) {
							cost[ny*w+nx] = di.first + 1.0 / v[ny][nx];
							if(cost[ny*w+nx] < 1.0 + EPS) {
								que.push(mp(cost[ny*w+nx], ny * w + nx));
								G[i*w+j].push_back(edge(ny*w+nx, 1));
							}
						}
					}
				}

			}
		}

		startRow--;
		startCol--;
		dijkstra(startRow * w + startCol, n);

		endRow--;
		endCol--;
		if(d[endRow * w + endCol] == INF) {
			return -1;
		}

		return d[endRow * w + endCol];
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM328 D1M BlockEnemy]]></title>
    <link href="http://ry0u.github.io/blog/2016/11/19/srm328-d1m-blockenemy/"/>
    <updated>2016-11-19T00:36:04+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/11/19/srm328-d1m-blockenemy</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6852&rd=10008">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

グラフが与えられる．$occupiedTowns[i]$同士が繋がっていないようにするために，辺を切る最小コストを求める．

---

まずは最小全域木を作る．すると木になったので$root$を$0$に決めて，dfsする．

$$
	dfs(cur, pre) := cur以下の部分木をoccupiedTowns同士が繋がらないようにした時の最小コスト\\\
	dp[i] := i以下の部分木を分離するための最小コスト
$$

葉まで行った時は，$occupiedTowns$の時は$dp[i]$をその辺のコストにして，そうでない場合は切る必要がないので$0$にして$0$を返す．ここから場合分け．今見ている頂点が$occupiedTowns$ではないときを考える．

{% img /images/SRM/328_1.png %}

今訪れている頂点が$1$で，赤の枠で囲まれている場所が$occupiedTowns$，辺のコストはそれぞれ$l$である．この時，このまま頂点$2$に伸びる辺と頂点$4$に伸びる頂点をつないでしまうと，$2$から$4$へ行けてしまうので何とかしなければならない．頂点$2$へ行く方法を切ってしまうと考えた場合，そこへ伸びる辺を切る方法と，頂点$2$以下の部分木を分離してしまう方法がある．下の図でいうと$l1$と$dp[2]$である．これらの$min$が頂点$2$へ行く方法を切る時の最小コストである．

{% img /images/SRM/328_2.png %}

同様に頂点$4$についても$min(l3, dp[4])$である．小さい順につながってしまうとダメな場所$-1$個の場所に行けないようにする．最後の残っている所を親に引き継ぐ(親を赤の枠にする)．今見ている頂点が$occupiedTowns$の時は，子の赤い枠の場所は全て切らねばならないので，その辺を切るか$dp$を切るかの小さい方の合計を持ち上げる．$dfs(0, -1)$の戻り値がそのまま答えとなる．


```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

vector<string> split(const string &str, char delim) {
	vector<string> res;
	size_t current = 0, found;
	while((found = str.find_first_of(delim, current)) != string::npos) {
		res.push_back(string(str, current, found - current));
		current = found + 1;
	}
	res.push_back(string(str, current, str.size() - current));
	return res;
}

int f(string s) {
	int ret;
	stringstream ss(s);
	ss >> ret;
	return ret;
}

struct UnionFind {
	vector<int> par, rank;
	int N;

	UnionFind(int n) {
		N = n;
		par.resize(n);
		rank.resize(n);

		rep(i, n) {
			par[i] = i;
			rank[i] = 0;
		}
	}

	int find(int x) {
		if(par[x] == x) return x;
		else return par[x] = find(par[x]);
	}

	void unite(int x, int y) {
		x = find(x);
		y = find(y);

		if(x == y) return;

		if(rank[x] < rank[y]) {
			par[x] = y;
		} else {
			par[y] = x;
			if(rank[x] == rank[y]) rank[x]++;
		}
	}

	bool same(int x, int y) {
		return find(x) == find(y);
	}

	int size() {
		int cnt = 0;
		rep(i, N) if(find(i) == i) cnt++;
		return cnt;
	}
};

struct edge {
	int from,to;
	int cost;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int f,int t,int c) : from(f),to(t),cost(c) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

vector<edge> G[55];
int dist[55][55];

int kruskal(int n, vector<edge> v) {
	sort(v.begin(),v.end());

	UnionFind uf(n);
	rep(i, 55) G[i].clear();
	rep(i, 55) rep(j, 55) dist[i][j] = INF;

	int ret = 0;
	rep(i, v.size()) {
		edge e = v[i];
		if(!uf.same(e.from,e.to)) {
			uf.unite(e.from,e.to);
			ret += e.cost;

			G[e.from].push_back(edge(e.to, e.cost));
			G[e.to].push_back(edge(e.from, e.cost));

			dist[e.from][e.to] = e.cost;
			dist[e.to][e.from] = e.cost;

			// cout << e.from << " -- " << e.to << " [label = \"" << e.cost << "\"];" << endl;
		}
	}

	return ret;
}

bool O[55];
int dp[55]; // 部分木iを消す時の最善
int n;

int dfs2(int cur, int pre) {
	int cnt = 0;
	rep(i, G[cur].size()) {
		edge e = G[cur][i];
		if(e.to == pre) continue;
		cnt++;
	}

	if(cnt == 0) {
		if(O[cur]) {
			dp[cur] = dist[cur][pre];
			return 0;
		} else {
			dp[cur] = 0;
			return 0;
		}
	}

	vector<int> v;
	int ret = 0;
	rep(i, G[cur].size()) {
		edge e = G[cur][i];
		if(e.to == pre) continue;

		int x = dfs2(e.to, cur);
		ret += x;
		int res = min(dp[e.to], dist[e.to][cur]);

		if(res == 0) continue;
		v.push_back(res);
	}

	if(O[cur]) {
		int sum = 0;
		rep(i, v.size()) {
			sum += v[i];
		}
		return sum + ret;
	} else {
		if(v.size() == 0) {
			dp[cur] = 0;
			return ret;
		}
		else if(v.size() == 1) {
			dp[cur] = v[0];
			return ret;
		} else {
			sort(v.begin(), v.end());

			int sum = 0;
			rep(i, v.size()-1) {
				sum += v[i];
			}

			dp[cur] = v[v.size()-1];
			return sum + ret;
		}
	}
}

class BlockEnemy {
	public:
	int minEffort(int N, vector <string> roads, vector <int> occupiedTowns) {
		n = N;
		memset(O, 0, sizeof(O));
		rep(i, occupiedTowns.size()) {
			O[occupiedTowns[i]] = true;
		}

		rep(i, 55) dp[i] = INF;

		vector<edge> E;
		rep(i, roads.size()) {
			vector<string> ret = split(roads[i], ' ');

			int a = f(ret[0]);
			int b = f(ret[1]);
			int e = f(ret[2]);

			E.push_back(edge(a, b, e));
		}

		kruskal(N, E);

		return dfs2(0, -1);
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM322 D1M ExtendedDominoes]]></title>
    <link href="http://ry0u.github.io/blog/2016/11/18/srm322-d1m-extendeddominoes/"/>
    <updated>2016-11-18T20:32:58+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/11/18/srm322-d1m-extendeddominoes</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6779&rd=10002">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

ドミノのピースが与えられて，それには表と裏に数字が書いてある．それは反転しても良い．ピースの裏とピースの表が同じ数字の時にくっつけることが出来て，円環になるように最初のピースの表と，最後のピースの裏が同じになるようにする．このようにした時に何通りの分け方が存在するか．

---

分からなかったので解説を見た．頂点をひと桁の数字とすると，ドミノは辺と見ることができる．反転して使っても良いので無向グラフとなる．このグラフの，一筆書きができる連結成文に分け方を求めるという問題になる．

$i$番目の頂点の次数を$d[i]$として，今その頂点に入ってきたとすると，$d[i]-1$通り出て行く候補がある．出て行った後は入ってきたパスと出て行くパスを消したいので，次数を$d[i]-2$する．後はこれを全ての頂点においてやる．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

class ExtendedDominoes {
	public:
	long long countCycles(vector <string> pieces) {
		int d[10];
		memset(d, 0, sizeof(d));

		rep(i, pieces.size()) {
			rep(j, 2) {
				d[pieces[i][j]-'0']++;
			}
		}

		rep(i, 10) {
			if(d[i] % 2 == 1) return 0;
		}

		ll  ans = 1;
		rep(i, 10) {
			while(d[i]) {
				ans *= (d[i] - 1);
				d[i] -= 2;
			}
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM317 D2H OrdringCount]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/26/srm317-d2h-ordringcount/"/>
    <updated>2016-10-26T15:18:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/26/srm317-d2h-ordringcount</id>
    <content type="html"><![CDATA[<!-- more -->

グラフが与えられるのでトポロジカル順序の個数を答える．  
逆から考えていく．トポロジカル順序として一番最後となるのは，出次数が0のノードとなる．既に決めた頂点数集合$S$をbitとして持ち，

$$
	dp[S] := 頂点集合Sをトポロジカルソートする方法の数
$$

とする．逆から見て，この頂点集合$S$の次に選べるものは，頂点の隣接しているのものが頂点集合の中に既に含まれているか，隣接しているノードが無いかのどちらかである．最終的に$dp[(1<<n)-1]$が答えとなる．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

ll dp[1<<21];

class OrderingCount {
	public:
	long long countOrderings(vector <string> req) {
		int n = req.size();

		memset(dp, 0, sizeof(dp));
		dp[0] = 1;

		rep(i, 1<<n) {
			rep(j, n) {
				if(i & (1 << j)) continue;

				bool flag = true;
				rep(k, n) {
					if(i & (1 << k)) continue;
					if(req[j][k] == 'Y') flag = false;
				}

				if(flag) {
					dp[i | (1 << j)] += dp[i];
				}
			}
		}

		return dp[(1<<n)-1];
	}
};
```
]]></content>
  </entry>
  
</feed>
