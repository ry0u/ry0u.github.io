<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: グラフ | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/gurahu/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-09-03T02:19:57+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM305 D2H Cannibals]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/25/srm305-d2h-cannibals/"/>
    <updated>2016-08-25T13:22:20+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/25/srm305-d2h-cannibals</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6410&rd=9826">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

川渡り問題．宣教師と先住民の問題で，sample0がよく出るやつ．
http://www.umechando.com/playroom/04.htm
このページでsample0をやった．

---

状態を考えると，(本土の宣教師の人数, 本土の先住民の人数, 対岸の宣教師の人数, 対岸の先住民の人数, ボートがどっちにあるか)で，これを$memo[105][105][105][105][2]$で取るとMLE．宣教師は本土$+$対岸は必ず$M$，先住民も本土$+$対岸は必ず$C$となるので，本土だけをメモすれば対岸の人数も分かる．よって$memo[105][105][2]$で良い．後は各状態から船に乗って移動するのを遷移を全探索するdijkstraをした．宣教師より先住民の方が多い場合は遷移できないが，宣教師が$0$人の場合は出来ることに注意する(なかなかこれを書いていないことに気づかなかった)．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;
typedef pair<P, P> PP;

int memo[105][105][2];

struct State {
	int a, b, c, d, cost;
	bool flag;

	State(int a, int b, int c, int d, int cost, bool flag) : a(a), b(b), c(c), d(d), cost(cost), flag(flag) {}

	bool operator<(const State& s) const {
		return cost < s.cost;
    }
	bool operator>(const State& s) const {
		return cost > s.cost;
    }
};

ostream& operator << (ostream& os, const State& s) {
	os << "(" << s.a << ", " << s.b << " | " << s.c << ", " << s.d << ") : " << s.cost << " flag:" << s.flag;
	return os;
}

bool ok(State s) {
	int a = s.a, b = s.b, c = s.c, d = s.d;
	bool f1 = false;
	if(a == 0 || b == 0) f1 = true;
	if(a >= b) f1 = true;

	bool f2 = false;
	if(c == 0 || d == 0) f2 = true;
	if(c >= d) f2 = true;

	return (f1 && f2);
}

class Cannibals {
	public:
	int minCrossings(int M, int C, int R) {
		memset(memo, -1, sizeof(memo));


		priority_queue<State, vector<State>, greater<State> > que;
		que.push(State(M, C, 0, 0, 0, 0));
		memo[M][C][0] = 0;

		while(que.size()) {
			State s = que.top(); que.pop();

			if(s.flag == 0) {
				rep(i, s.a + 1) {
					rep(j, s.b + 1) {
						if(i == 0 && j == 0) continue;
						if(i + j > R) continue;
						if(i != 0 && j != 0 && i < j) continue;

						int a = s.a - i;
						int b = s.b - j;


						State nc(a, b, s.c + i, s.d + j, s.cost + 1, 1);

						if(ok(nc) && memo[nc.a][nc.b][nc.flag] == -1) {
							memo[nc.a][nc.b][nc.flag] = nc.cost;
							que.push(nc);
						}
					}
				}
			} else {
				rep(i, s.c + 1) {
					rep(j, s.d + 1) {
						if(i == 0 && j == 0) continue;
						if(i + j > R) continue;
						if(i != 0 && j != 0 && i < j) continue;

						int c = s.c - i;
						int d = s.d - j;

						State nc(s.a + i, s.b + j, c, d, s.cost + 1, 0);

						if(ok(nc) && memo[nc.a][nc.b][nc.flag] == -1) {
							memo[nc.a][nc.b][nc.flag] = nc.cost;
							que.push(nc);
						}
					}
				}
			}
		}

		return memo[0][0][1];
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM301 D1M EscapingJail]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/21/srm301-d1m-escapingjail/"/>
    <updated>2016-08-21T21:12:51+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/21/srm301-d1m-escapingjail</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6222&rd=9822">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

隣接行列が与えられるので，全ての二点間の最短経路の中の最長を出す．$N \leq 50$なので，warshall_floydした．

<!-- more -->

# Code

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<28
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

int n;
int cost[55][55];

int f(char c) {
	if('0' <= c && c <= '9') return (c - '0');
	if('a' <= c && c <= 'z') return (c - 'a' + 10);
	if('A' <= c && c <= 'Z') return (c - 'A' + 36);
	return INF;
}

class EscapingJail {
	public:
	int getMaxDistance(vector<string> v) {
		int n = v.size();
		memset(cost, 0, sizeof(cost));

		rep(i, n) {
			rep(j, n) {
				cost[i][j] = f(v[i][j]);
			}
		}

		rep(k, n) {
			rep(i, n) {
				rep(j, n) {
					cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);
				}
			}
		}

		int ans = -1;
		rep(i, n) {
			rep(j, n) {
				if(i == j) continue;
				if(cost[i][j] == INF) continue;
				ans = max(ans, cost[i][j]);
			}
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JAG Contest 2016 DomesticB D 夏合宿の朝は早い]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/17/jag-contest-2016-domesticb-d-xia-he-su-falsezhao-hazao-i/"/>
    <updated>2016-06-17T17:13:18+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/17/jag-contest-2016-domesticb-d-xia-he-su-falsezhao-hazao-i</id>
    <content type="html"><![CDATA[<!-- more -->

強連結成分分解した後，各連結成分の始点が全て起きている確立の積を求める．始点が起きている確立は，$1 - $その強連結成分のノード番号に属するノードが全員起きていない確立で求まる．始点かどうかは，強連結成分分解後のグラフのノードの自分に向いている辺の個数が$0$であればよいのでカウントしていった．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <set>

#define REP(i, k, n) for(int i = k; i < n; i++)
#define rep(i, n) for(int i = 0; i < n; i++)

using namespace std;

struct SCC {
	int n;
	vector<vector<int> > g, rg, ng, scc;
	vector<int> res;
	bool used[105];

	SCC(int _n) {
		n = _n;
		g.resize(n); rg.resize(n); scc.resize(n); res.resize(n);
	}

	void add(int i, int j) {
		g[i].push_back(j);
		rg[j].push_back(i);
	}

	vector<int> vs;
	void dfs(int v) {
		used[v] = true;
		rep(i, g[v].size()) {
			if(!used[ g[v][i] ]) dfs(g[v][i]);
		}
		vs.push_back(v);
	}

	void rdfs(int v, int k) {
		used[v] = true;
		res[v] = k;
		scc[k].push_back(v);

		rep(i, rg[v].size()) {
			if(!used[ rg[v][i] ]) rdfs(rg[v][i], k);
		}
	}

	void ng_make(int k) {
		ng.resize(k);

		rep(i, n) {
			set<int> S;
			rep(j, g[i].size()) {
				int to = g[i][j];
				if(res[i] == res[to]) continue;
				if(S.find(res[to]) != S.end()) continue;
				ng[res[i]].push_back(res[to]);
				S.insert(res[to]);
			}
		}
	}

	int build() {
		memset(used, 0, sizeof(used));
		rep(i, n) {
			if(!used[i]) dfs(i);
		}

		memset(used, 0, sizeof(used));
		int k = 0;
		for(int i = vs.size()-1; i >= 0; i--) {
			if(!used[vs[i]]) rdfs(vs[i], k++);
		}

		ng_make(k);
		return k;
	}
};

int main() {
	int n;
	while(cin >> n && n) {
		vector<double> v(n);
		SCC scc(n);

		rep(i, n) {
			int x;
			cin >> v[i] >> x;

			rep(j, x) {
				int a;
				cin >> a;
				
				a--;
				scc.add(i, a);
			}
		}

		int k = scc.build();
		vector<vector<int> > g = scc.ng;

		int cnt[105];
		memset(cnt, 0, sizeof(cnt));

		rep(i, k) {
			rep(j, g[i].size()) {
				cnt[g[i][j]]++;
			}
		}

		double ans = 1.0;
		rep(i, k) {
			if(cnt[i] != 0) continue;
			double t = 1.0;
			rep(j, scc.scc[i].size()) {
				int u = scc.scc[i][j];
				t *= v[u];
			}

			ans *= (1.0 - t);
		}

		cout << fixed;
		cout.precision(20);
		cout << ans << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM692 D1E HardProof]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/10/srm692-d1e-hardproof/"/>
    <updated>2016-06-10T22:53:39+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/10/srm692-d1e-hardproof</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14334&rd=16747">TopCoder Statistics - Problem Statement</a></h4><p>You are preparing for an exam in Calculus 4. In the chapter "Abstract Fourier Series", you encountered an excercise in which you are given a collection of N statements and your task is to prove that all N statements are equivalent. For the purpose of this problem, we will number the statements 0 through N-1.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$0 => 1$を頂点$0$ $\to$ 頂点$1$の有向グラフと考えると，$N$個の頂点を含む閉路の中でその辺の最大コスト$-$最小コストを答えれば良いとなる．  
  
コストが近いものを同士を使った方が良いので，使うコストの端を持ってしゃくとり法をした．（考え方は[ここ]({% post_url 2016-05-21-aoj1280-slim-span %})に似てると思った）  
$N$個の頂点を含む閉路の検出は強連結成分分解した後の連結成分数が$1$であるかどうかで判定．  
全て辺を張ってで行けるか行けないを持ったらTLE．辺を追加したり削除したりした場合でもTLE．毎回毎回グラフを作り直したらACした．(最初の$2$つは$N ^2$よりもかかっている(?)よく分かっていない)

# Code

```cpp
struct edge {
	int from,to;
	int cost;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int f,int t,int c) : from(f),to(t),cost(c) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

struct SCC {
	int n;
	vector<vector<int> > g, rg, ng, scc; // rg: 逆グラフ, ng: 分解後のグラフ
	vector<int> res; // scc: 強連結成分に属する頂点, res:強連結成分の番号
	bool used[100005];

	SCC(int _n) {
		n = _n;
		g.resize(n); rg.resize(n) ; scc.resize(n); res.resize(n);
	}

	SCC(const vector<vector<int> > &g) : n(g.size()), g(g), rg(n), scc(n), res(n) {
		rep(i, n) {
			rep(j, g[i].size()) rg[g[i][j]].push_back(i);
		}
	}

	// i-jに辺を追加する
	void add(int i, int j) {
		g[i].push_back(j);
		rg[j].push_back(i);
	}

	vector<int> vs;
	void dfs(int v) {
		used[v] = true;
		rep(i, g[v].size()) {
			if(!used[ g[v][i] ]) dfs(g[v][i]);
		}
		vs.push_back(v);
	}

	void rdfs(int v, int k) {
		used[v] = true;
		res[v] = k; 
		scc[k].push_back(v);
		rep(i, rg[v].size()) {
			if(!used[ rg[v][i] ]) rdfs(rg[v][i], k);
		}
	}

	void ng_make(int k) {
		ng.resize(k);
		rep(i, n) {
			set<int> S;
			rep(j, g[i].size()) {
				int to = g[i][j];
				if(res[i] == res[to]) continue;
				if(S.find(res[to]) != S.end()) continue;
				ng[res[i]].push_back(res[to]);
				S.insert(res[to]);
			}
		}
	}

	int build() {
		memset(used, 0, sizeof(used));
		rep(i, n) {
			if (!used[i]) dfs(i);
		}

		memset(used, 0, sizeof(used));
		int k = 0;
		for (int i = vs.size()-1; i >= 0; i--) {
			if (!used[vs[i]]) rdfs(vs[i], k++);
		}

		// ng_make(k);
		return k;
	}
};

class HardProof {
	public:
	int minimumCost(vector<int> D) {
		int n = sqrt(D.size());

		int k = -1;
		map<int, vector<P> > m;

		rep(i, n) {
			rep(j, n) {
				k++;
				if(i == j) continue;
				m[D[k]].push_back(mp(i, j));
			}
		}

		int ans = INF;
		map<int, vector<P> >::iterator l = m.begin(), r = m.begin(), ite;

		for(r = m.begin(); r != m.end(); r++) {
			k = 1;
			while(k == 1) {
				SCC scc(n);
				ite = l;
				while(ite != m.end() && ite->first <= r->first) {
					vector<P> v = ite->second;
					rep(i, v.size()) {
						int a = v[i].first, b = v[i].second;
						scc.add(a, b);
					}

					if(ite == r) break;
					ite++;
				}

				k = scc.build();
				if(k == 1) {
					ans = min(ans, r->first - l->first);
					l++;
					continue;
				}
				break;
			}
		}

		if(ans == INF) return 0;
		return ans;
	}
};
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2151 Brave Princess Revisited]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/09/aoj2151-brave-princess-revisited/"/>
    <updated>2016-06-09T13:59:08+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/09/aoj2151-brave-princess-revisited</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151">Brave Princess Revisited | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

状態を(襲われる盗賊や刺客の人数, お金, 頂点番号)としてdijkstra．現在の状態から次の状態への遷移は，護衛を雇わないで盗賊に襲われる，護衛を雇い守ってもらう，の$2$つである．お金が辺の長さより少ない場合は護衛を雇えないことに注意する．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;
typedef pair<P, int> PI;

struct edge {
	int from,to;
	int cost, res;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int t,int c,int r) : to(t), cost(c), res(r) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

vector<edge> G[105];
int d[105][105];

void dijkstra(int s, int l) {
	rep(i, 105) rep(j, 105) d[i][j] = INF;
	d[s][l] = 0;

	priority_queue<PI, vector<PI>, greater<PI> > que;
	que.push(mp(mp(0, -l), s));

	while(que.size()) {
		PI p = que.top(); que.pop();
		int cost = p.first.first;
		int coin = p.first.second;
		int v = p.second;
		coin *= -1;

		if(d[v][coin] < cost) continue;
		
		rep(i, G[v].size()) {
			edge e = G[v][i];

			if(d[e.to][coin] > d[v][coin] + e.res) {
				d[e.to][coin] = d[v][coin] + e.res;
				que.push(mp(mp(d[e.to][coin], -coin), e.to));
			}

			int nc = coin - e.cost;
			if(nc >= 0 && d[e.to][nc] > d[v][coin]) {
				d[e.to][nc] = d[v][coin];
				que.push(mp(mp(d[e.to][nc], -nc), e.to));
			}
		}

	}
}

int main() {
	int n, m, l;
	while(cin >> n >> m >> l)  {
		if(n == 0 && m == 0 && l == 0) break;

		rep(i, 105) G[i].clear();

		rep(i, m) {
			int a, b, c, d;
			cin >> a >> b >> c >> d;

			a--; b--;

			G[a].push_back(edge(b, c, d));
			G[b].push_back(edge(a, c, d));
		}

		dijkstra(0, l);

		int ans = INF;
		rep(i, l+1) {
			ans = min(ans, d[n-1][i]);
		}

		cout << ans << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
</feed>
