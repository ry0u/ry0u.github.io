<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: グラフ | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/gurahu/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-18T23:11:03+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ0616 JOI Park]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj0616-joi-park/"/>
    <updated>2016-03-18T16:24:27+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj0616-joi-park</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0616">JOI Park | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>まず，<script type="math/tex"> 広場0 </script>からの各広場までの最短経路を求める．次に，コストが小さい順にソートし，その場所への到達コストを仮の<script type="math/tex"> X </script>と置き，整備する場所とする．整備される場所同士は，地下道を通して行き来できるためそのコストを全体から引く．始点を到達コスト<script type="math/tex"> 0 </script>の広場と見れば整備しない場合も考慮される．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1LL&lt;&lt;60
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[100005];
ll d[100005];
bool used[100005];

void dijkstra(int s,int n) {
    priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; que;
    fill(d,d+n,INF);

    d[s] = 0;
    que.push(P(0,s));

    while(que.size()) {
        P p = que.top();
        que.pop();

        int v = p.second;
        if(d[v] &lt; p.first) continue;

        rep(i,G[v].size()) {
            edge e = G[v][i];
            if(d[e.to] &gt; d[v] + e.cost) {
                d[e.to] = d[v] + e.cost;
                que.push(P(d[e.to],e.to));
            }
        }
    }
}

int main() {
    int n, m, c;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;

    ll sum = 0;
    rep(i, m) {
        int a, b, d;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;

        a--;
        b--;
        sum += d;

        G[a].push_back(edge(b, d));
        G[b].push_back(edge(a, d));
    }

    dijkstra(0, n);

    vector&lt;pair&lt;ll, int&gt; &gt; v(n);
    rep(i, n) {
        v[i].first = d[i];
        v[i].second = i;
    }

    sort(v.begin(), v.end());
    memset(used, 0, sizeof(used));

    ll ans = INF;
    rep(i, v.size()) {
        int j = v[i].second;
        used[j] = true;

        rep(k, G[j].size()) {
            if(used[G[j][k].to]) {
                sum -= G[j][k].cost;
            }
        }

        ans = min(ans, d[j] * c + sum);
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0605 Modern Mansion]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/16/aoj0605-modern-mansion/"/>
    <updated>2016-03-16T01:28:12+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/16/aoj0605-modern-mansion</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0605">Modern Mansion | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>状態を <script type="math/tex"> (cost, id, state) </script>として，現在どちら方向の扉が空いているかを持ってdijkstra．扉が空いている方向で最小値を更新出来る場所に行く．TLEを連発した．時間制限が1secで0.94secでギリギリ通した．変にlogをつけて死んでいた．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1LL&lt;&lt;60
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;
typedef pair&lt;P, bool&gt; PI;

int w, h, k;
vector&lt;P&gt; X[200005], Y[200005];
vector&lt;P&gt; xy;
ll d[200005][2];

// PI f(int a, int b, int c) {
//  return mp(mp(a, b), c);
// }

void dijkstra() {
    rep(i, 200005) {
        d[i][0] = INF;
        d[i][1] = INF;
    }

    // cost id (0 or 1)
    priority_queue&lt;PI, vector&lt;PI&gt;, greater&lt;PI&gt; &gt; que;

    rep(i, X[1].size()) {
        int y = X[1][i].first;
        int to = X[1][i].second;

        d[to][1] = y;
        // que.push(f(y, to, 1));
        que.push(mp(mp(y, to), 1));
    }

    while(que.size()) {
        PI p = que.top(); 
        que.pop();

        int c = p.first.first;
        int v = p.first.second;
        int state = p.second;

        if(d[v][state] &lt; c) continue;

        int y = xy[v].first;
        int x = xy[v].second;

        if(state == 0) {
            rep(i, X[x].size()) {
                int ny = X[x][i].first;
                int to = X[x][i].second;

                if(ny == y) continue;

                if(d[to][1] &gt; d[v][state] + abs(ny - y) + 1) {
                    d[to][1] = d[v][state] + abs(ny- y) + 1;
                    // que.push(f(d[to][1], to, 1));
                    que.push(mp(mp(d[to][1], to), 1));
                }
            }
        } else {
            rep(i, Y[y].size()) {
                int nx = Y[y][i].first;
                int to = Y[y][i].second;

                if(nx == x) continue;

                if(d[to][0] &gt; d[v][state] + abs(nx - x) + 1) {
                    d[to][0] = d[v][state] + abs(nx - x) + 1;
                    // que.push(f(d[to][0], to, 0));
                    que.push(mp(mp(d[to][0], to), 0));
                }
            }
        }
    }
}

int main() {
    cin &gt;&gt; w &gt;&gt; h &gt;&gt; k;

    xy.resize(k);
    rep(i, k) {
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;

        xy[i] = mp(y, x);
        X[x].push_back(mp(y, i));
        Y[y].push_back(mp(x, i));
    }

    dijkstra();

    ll ans = INF;
    rep(i, k) {
        int y = xy[i].first;
        int x = xy[i].second;

        if(y == h) {
            ans = min(ans, d[i][1] + abs(w - x));
        }

        if(x == w) {
            ans = min(ans, d[i][0] + abs(h - y));
        }
    }

    if(ans == INF) cout &lt;&lt; -1 &lt;&lt; endl;
    else cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM684D2H Autohamil]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/16/srm684d2h-autohamil/"/>
    <updated>2016-03-16T00:01:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/16/srm684d2h-autohamil</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=14183&rd=16688">TopCoder Statistics - Problem Statement</a></h4><p>In this problem, all strings are binary strings. That is, each character of a string is either '0' or '1'. A deterministic finite automaton is a machine that processes strings. The automaton has a finite set of possible states. The states are numbered 0 through n-1, where n is the number of states.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>有向グラフが与えられるので，ハミルトン路があるかどうかを判定せよ．</p>

<hr />

<p>閉路があるので，強連結成分分解する．分解後のグラフで<script type="math/tex"> 0 </script>を始点に探索を始め，分かれ道があれば出来ないと思ったが，全然違うしサンプルも合わない．こういう場合は出来る．</p>

<p><img src="/images/SRM/684d2h.png"></p>

<p>強連結成分分解をしDAGになったので，トポロジカルソートしてトポロジカル順序で<script type="math/tex"> i \to i+1 </script>の辺があるかを調べる．また，トポロジカル順序の開始が<script type="math/tex"> 0 </script>で無い場合も出来ないことを忘れない(分からなかった)．</p>

<h1>Code</h1>

<pre><code class="cpp">struct SCC {
    int n;
    vector&lt;vector&lt;int&gt; &gt; g, rg, ng, scc; // rg: 逆グラフ, ng: 分解後のグラフ
    vector&lt;int&gt; res; // scc: 強連結成分に属する頂点, res:強連結成分の番号
    bool used[100005];

    SCC(int _n) {
        n = _n;
        g.resize(n); rg.resize(n) ; scc.resize(n); res.resize(n);
    }

    SCC(const vector&lt;vector&lt;int&gt; &gt; &amp;g) : n(g.size()), g(g), rg(n), scc(n), res(n) {
        rep(i, n) {
            rep(j, g[i].size()) rg[g[i][j]].push_back(i);
        }
    }

    // i-jに辺を追加する
    void add(int i, int j) {
        g[i].push_back(j);
        rg[j].push_back(i);
    }

    vector&lt;int&gt; vs;
    void dfs(int v) {
        used[v] = true;
        rep(i, g[v].size()) {
            if(!used[ g[v][i] ]) dfs(g[v][i]);
        }
        vs.push_back(v);
    }

    void rdfs(int v, int k) {
        used[v] = true;
        res[v] = k; 
        scc[k].push_back(v);
        rep(i, rg[v].size()) {
            if(!used[ rg[v][i] ]) rdfs(rg[v][i], k);
        }
    }

    void ng_make(int k) {
        ng.resize(k);
        rep(i, n) {
            set&lt;int&gt; S;
            rep(j, g[i].size()) {
                int to = g[i][j];
                if(res[i] == res[to]) continue;
                if(S.find(res[to]) != S.end()) continue;
                ng[res[i]].push_back(res[to]);
                S.insert(res[to]);
            }
        }
    }

    int run() {
        memset(used, 0, sizeof(used));
        rep(i, n) {
            if (!used[i]) dfs(i);
        }

        memset(used, 0, sizeof(used));
        int k = 0;
        for (int i = vs.size()-1; i &gt;= 0; i--) {
            if (!used[vs[i]]) rdfs(vs[i], k++);
        }

        ng_make(k);
        return k;
    }
};

bool used[55];
vector&lt; vector&lt;int&gt; &gt; ng;
vector&lt;int&gt; out;

void dfs(int cur) {
    used[cur] = true;
    rep(i, ng[cur].size()) {
        int v = ng[cur][i];
        if(!used[v]) dfs(v);
    }
    out.push_back(cur);
}

class Autohamil {
    public:
    string check(vector &lt;int&gt; z0, vector &lt;int&gt; z1) {
        int n = z0.size();
        SCC scc(n);

        rep(i, n) {
            if(i != z0[i]) scc.add(i, z0[i]);
            if(i != z1[i]) scc.add(i, z1[i]);
        }

        int m = scc.run();
        ng.resize(m);
        rep(i, m) {
            ng[i].resize(scc.ng[i].size());
            rep(j, scc.ng[i].size()) {
                ng[i][j] = scc.ng[i][j];
            }
        }

        int cnt[55];
        memset(cnt, 0, sizeof(cnt));
        rep(i, m) {
            rep(j, ng[i].size()) {
                cnt[ng[i][j]]++;
            }
        }

        REP(i, 1, m) {
            if(cnt[i] == 0) return "Does not exist";
        }

        int s = scc.res[0];
        memset(used, 0, sizeof(used));
        out.clear();
        dfs(s);
        reverse(out.begin(), out.end());

        if(out[0] != 0) return "Does not exist";

        rep(i, out.size()-1) {
            bool ch = false;
            rep(j, ng[out[i]].size()) {
                if(ng[out[i]][j] == out[i+1]) {
                    ch = true;
                }
            }

            if(ch) continue;
            return "Does not exist";
        }
        return "Exists";
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[yukicoder No.92 逃走経路]]></title>
    <link href="http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-92-tao-zou-jing-lu/"/>
    <updated>2015-09-03T21:40:54+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/09/03/yukicoder-no-dot-92-tao-zou-jing-lu</id>
    <content type="html"><![CDATA[<p><a href="http://yukicoder.me/problems/149">http://yukicoder.me/problems/149</a></p>

<h1>考察</h1>

<p>dfsで行けるとこ全部行ったらTLEした．戻ることも考えられるので，状態数がすごいことになることがわかっていなかった．よくよく考えると，i回目の移動でいる場所としてはmaxでNなので，行ける場所をもって最後まで残った場所を答える．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;int&gt; v;
int n,m,k;

int main() {
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;

    map&lt;int,vector&lt;edge&gt; &gt; edges;
    rep(i,m) {
        int a,b,c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;

        a--;
        b--;

        edges[c].push_back(edge(a,b,c));
        edges[c].push_back(edge(b,a,c));
    }

    v.resize(k);
    rep(i,k) cin &gt;&gt; v[i];

    vector&lt;int&gt; ans(n);
    rep(i,n) ans[i] = i;
    rep(i,k) {
        bool used[105];
        memset(used,0,sizeof(used));

        rep(j,ans.size()) {
            used[ans[j]] = true;
        }

        vector&lt;edge&gt; es = edges[v[i]];
        vector&lt;int&gt; temp;
        rep(j,es.size()) {
            int f = es[j].from;
            int t = es[j].to;

            if(used[f]) {
                temp.push_back(t);
            }
        }

        sort(temp.begin(),temp.end());
        temp.erase(unique(temp.begin(),temp.end()),temp.end());

        ans.resize(temp.size());
        rep(j,temp.size()) ans[j] = temp[j];
    }

    sort(ans.begin(),ans.end());
    cout &lt;&lt; ans.size() &lt;&lt; endl;
    rep(i,ans.size()) {
        cout &lt;&lt; ans[i] + 1;
        if(i == ans.size()-1) cout &lt;&lt; endl;
        else cout &lt;&lt; " ";
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
