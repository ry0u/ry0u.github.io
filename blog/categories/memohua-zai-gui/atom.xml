<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: メモ化再帰 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/memohua-zai-gui/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-09-03T02:19:57+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JAG Contest 2016 Domestic D インビジブル]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/27/jag-contest-2016-domestic-d-inbiziburu/"/>
    <updated>2016-04-27T23:39:09+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/27/jag-contest-2016-domestic-d-inbiziburu</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article"><h4><a href="http://jag2016-domestic.contest.atcoder.jp/tasks/jag2016secretspring_d">D: インビジブル - JAG Contest 2016 Domestic | AtCoder</a></h4><p>(null)</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

状態を({% m %} a {% em %}のデッキから何枚取ったか， {% m %} b {% em %}のデッキから何枚取ったか，場のスタック，何ターン目，前回のスタックが空の状態でパスをしたかどうか)にしてメモ化再帰．minimaxみたいな感じでプレイヤー {% m %} 1 {% em %}のターンでは {% m %} c - d {% em %}の最大化，プレイヤー {% m %} 2 {% em %}のターンでは {% m %} c - d {% em %}の最小化をした．  

本番では，メモ化するときに，stackの状態を持たねばならないと思っていたが，スタックのサイズだけを持てば良いことに気付けなかった．スタックが空の状態で無くてもパスパスをした時点で終了だと思い込んでいた．

# Code

```cpp
#include <iostream>
#include <sstream>
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
#include <map>
#include <stack>

#define REP(i, k, n) for(int i = k; i < n; i++) 
#define rep(i, n) for(int i = 0; i < n; i++) 
#define INF 1<<30

using namespace std;
typedef pair<int, int> P;

int n, m;
vector<int> a, b;

int f(stack<P> &st) {
	int c = 0, d = 0;
	bool cf = true, df = true;
	while(st.size()) {
		P p = st.top(); st.pop();
		if(p.first == 0) {
			if(p.second == -1) {
				df = false;
			} else if(cf) {
				c += p.second;
			}
		} else {
			if(p.second == -1) {
				cf = false;
			} else if(df) {
				d += p.second;
			}
		}
	}
	return c - d;
}

int memo[55][55][2][2][105];

int dfs(int i, int j, stack<P> st, int turn, bool flag) {
	if(memo[i][j][turn % 2][flag][st.size()] != INF) return memo[i][j][turn % 2][flag][st.size()];

	int ret = 0, size = st.size();
	if(flag) {
		if(turn % 2 == 0) {
			ret = 0;
			if(i != n) {
				st.push(P(0, a[i]));
				ret = max(ret, dfs(i + 1, j, st, turn + 1, false));
				st.pop();
			}
		} else {
			ret = 0;
			if(j != m) {
				st.push(P(1, b[j]));
				ret = min(ret, dfs(i, j + 1, st, turn + 1, false));
				st.pop();
			}
		}
	} else {
		if(turn % 2 == 0) {
			ret = -INF;
			if(i != n) {
				st.push(P(0, a[i]));
				ret = max(ret, dfs(i + 1, j, st, turn + 1, false));
				st.pop();
			}

			bool ch = (st.size() == 0);
			int d = f(st);
			ret = max(ret, dfs(i, j, st, turn + 1, ch) + d);
		} else {
			ret = INF;

			if(j != m) {
				st.push(P(1, b[j]));
				ret = min(ret, dfs(i, j + 1, st, turn + 1, false));
				st.pop();
			}

			bool ch = (st.size() == 0);
			int d = f(st);
			ret = min(ret, dfs(i, j, st, turn + 1, ch) + d);
		}
	}

	return memo[i][j][turn % 2][flag][size] = ret;
}

int main() {
	cin >> n >> m;

	a.resize(n);
	rep(i, n) cin >> a[i];

	b.resize(m);
	rep(i, m) cin >> b[i];

	stack<P> st;
	rep(i, 55) rep(j, 55) rep(k, 2) rep(l, 2) rep(o, 105) memo[i][j][k][l][o] = INF;
	cout << dfs(0, 0, st, 0, false) << endl;
	return 0;
}

```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2369 CatChecker]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/23/aoj2369-catchecker/"/>
    <updated>2016-03-23T20:34:54+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/23/aoj2369-catchecker</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2369">CatChecker | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

区間 {% m %} \[l, r\] {% em %}がねこ鳴き声か探索する．区間の端が {% m %} m {% em %}， {% m %} w {% em %}で真ん中の {% m %} e {% em %}で区切ってみる．メモ化しないとTLEした．逆からやると一意に決まる系かと思ったけどそんなことなかった．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

string s;
int memo[505][505];

bool dfs(int l, int r) {
	if(l > r) return true;
	if(memo[l][r] != -1) return memo[l][r];

	if(s[l] == 'm' && s[r] == 'w') {
		REP(i, l+1, r) {
			if(s[i] == 'e') {
				if(dfs(l+1, i-1) && dfs(i+1, r-1)) {
					return memo[l][r] = true;
				}
			}
		}
	}
	return memo[l][r] = false;
}

int main() {
	cin >> s;
	memset(memo, -1, sizeof(memo));

	if(dfs(0, s.size()-1)) {
		cout << "Cat" << endl;
	} else {
		cout << "Rabbit" << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0615 Cake2]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj0615-cake2/"/>
    <updated>2016-03-18T16:03:17+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj0615-cake2</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0615">Cake 2 | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

左端と右端を持ってdpだろうとずっと考えていたけど全く分からなかった．調べた．

<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://lattemalta.hatenablog.jp/entry/2015/09/07/220749">aoj0615:Cake2 - らての精進日記</a></h4><p>問題文 http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0615</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

非常に分かりやすかった．左端と右端を持つ区間DPを初めて書いた（写経）．バームクーヘンとかの時は円環を配列を繋げて表現する時に2つを繋げれば良かったが，とり方によってどっちにずれるかわからないので，真ん中を基準として左に1個，右に1個つなげる．  

* 区間の偶奇でどちらの順番かがわかる
* 左端から一個取る {% m %} \to \rm{dfs}(l-1, r) + A[l]{% em %} 
* 右端から一個取る {% m %} \to \rm{dfs}(l, r-1) + A[r]{% em %}
* memoに代入するのを忘れない

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<ll,ll> P;

int n;
vector<ll> v;
ll memo[4005][6005];

ll dfs(int l, int r) {
	if(memo[l][r] != -1) return memo[l][r];

	int turn = r - l - 1;

	if(turn == n) return memo[l][r] = 0;
	else if(turn % 2 == 1) {
		if(v[l] < v[r]) {
			return memo[l][r] = dfs(l, r+1);
		} else {
			return memo[l][r] = dfs(l-1, r);
		}
	} else {
		return memo[l][r] = max(dfs(l-1, r) + v[l], dfs(l, r+1) + v[r]);
	}
}

int main() {
	cin >> n;

	v.resize(n*3);
	rep(i, n) { 
		cin >> v[i];
		v[i+n] = v[i];
		v[i+n+n] = v[i];
	}

	ll ans = 0;
	memset(memo, -1, sizeof(memo));

	rep(i, n) {
		ans = max(ans, dfs(i-1+n, i+1+n) + v[i]);
	}

	cout << ans << endl;

	return 0;
}
```
]]></content>
  </entry>
  
</feed>
