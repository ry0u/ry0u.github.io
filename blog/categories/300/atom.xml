<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 300 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/300/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-12-01T23:52:11+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ1251 Pathological Paths]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/26/aoj1251-pathological-paths/"/>
    <updated>2016-03-26T22:12:52+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/26/aoj1251-pathological-paths</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1251">Pathological Paths</a></h4><p>Professor Pathfinder is a distinguished authority on the structure of hyperlinks in the World Wide Web. For establishing his hypotheses, he has been developing software agents, which automatically traverse hyperlinks and analyze the structure of the Web. Today, he has gotten an intriguing idea to improve his software agents.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

木構造でディレクトリ構造を表す．探すパスが両方葉の場合，ノードの番号が一致するかを見る．葉ではなくディレクトリの場合は，自分の子に文字列が"index.html"であり葉であるノードがあるかを見る．ない場合は"not found"で，ある場合はそのノード番号を比較する．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int cnt = 0;

struct Tree {
	string s;
	int id;
	Tree* par;
	vector<Tree*> v;

	Tree(Tree* par, string s, int id) : par(par), s(s), id(id) {}

	void add(int i, vector<string> res) {
		if(i == res.size()) return;

		bool flag = true;
		rep(j, v.size()) {
			if(v[j]->s == res[i]) flag = false;
		}

		if(flag) {
			cnt++;
			Tree *node = new Tree(this, res[i], cnt);
			v.push_back(node);
		}

		rep(j, v.size()) {
			if(v[j]->s == res[i]) {
				v[j]->add(i+1, res);
			}
		}
	}

	Tree* find(int i, vector<string> res) {
		// cout << " -- in find :" << s << endl;
		if(i == res.size()) {
			return this;
		}

		if(res[i] == ".") {
			if(v.size() == 0) return NULL;
			return find(i+1, res);
		} else if(res[i] == "..") {
			if(v.size() == 0) return NULL;
			if(par == NULL) return NULL;
			return par->find(i+1, res);
		} else if(res[i] == "") {
			if(v.size() == 0) return NULL;
			return find(i+1, res);
		} else {
			rep(j, v.size()) {
				if(v[j]->s == res[i]) {
					return v[j]->find(i+1, res);
				}
			}
			return NULL;
		}
	}

};

vector<string> split(const string &str, char delim) {
	vector<string> res;
	size_t current = 0, found;
	while((found = str.find_first_of(delim, current)) != string::npos) {
		res.push_back(string(str, current, found - current));
		current = found + 1;
	}
	res.push_back(string(str, current, str.size() - current));
	return res;
}

int main() {
	int n, m;
	while(cin >> n >> m) {
		if(n == 0 && m == 0) break;

		cnt = 0;
		Tree *root = new Tree(NULL, "root", cnt);

		rep(i, n) {
			string s;
			cin >> s;

			vector<string> ret = split(s, '/');

			root->add(0, vector<string>(ret.begin()+1, ret.end()));
		}

		rep(q, m) {
			string s, t;
			cin >> s >> t;

			vector<string> r = split(s, '/');
			vector<string> r2 = split(t, '/');

			Tree *node = root->find(0, r);
			Tree *node2 = root->find(0, r2);

			// if(node == NULL) cout << " node 1 : null" << endl;
			// if(node2 == NULL) cout << " node 2 : null" << endl;
		
			if(node == NULL || node2 == NULL) {
				cout << "not found" << endl;
			} else {

				Tree *res = NULL;
				if(node->v.size() == 0) {
					res = node;
				} else {
					rep(i, node->v.size()) {
						if(node->v[i]->v.size() == 0 && node->v[i]->s == "index.html") {
							res = node->v[i];
						}
					}
				}

				Tree *res2 = NULL;
				if(node2->v.size() == 0) {
					res2 = node2;
				} else {
					rep(i, node2->v.size()) {
						if(node2->v[i]->v.size() == 0 && node2->v[i]->s == "index.html") {
							res2 = node2->v[i];
						}
					}
				}

				// if(res == NULL) cout << "NULL";
				// else cout << res->s << ", " << res->id;
				//
				// cout << " ";
				//
				// if(res2 == NULL) cout << "NULL";
				// else cout << res2->s << ", " << res2->id;
				//
				// cout << endl;

				if(res == NULL || res2 == NULL) {
					cout << "not found" << endl;
				} else if(res->id == res2->id && res->s == res2->s) {
					cout << "yes" << endl;
				} else {
					cout << "no" << endl;
				}
			}
		}
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1347 Shopping]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/26/aoj1347-shopping/"/>
    <updated>2016-03-26T21:44:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/26/aoj1347-shopping</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1347">Shopping | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

まず最初に，全ての場所に行って帰ってを行うグラフを考える．

{% img /images/AOJ/1347-1.png %}

ここから実際に戻らなければいけない区間を出して

{% img /images/AOJ/1347-2.png %}

その区間でない場所は {% m %} 1 {% em %}本あればいいので {% m %} -2 {% em %}する．

{% img /images/AOJ/1347-3.png %}

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int n, m;
	cin >> n >> m;

	vector<int> c(m), d(m);
	rep(i, m) cin >> c[i] >> d[i];

	int cnt[1005];
	memset(cnt, 0, sizeof(cnt));

	rep(i, m) {
		REP(j, c[i], d[i]) {
			cnt[j]++;
		}
	}

	int ans = 3 * (n + 1);
	rep(i, n + 1) {
		if(cnt[i] == 0) {
			ans -= 2;
		}
	}

	cout << ans << endl;

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1326 Stylish]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/26/aoj1326-stylish/"/>
    <updated>2016-03-26T21:21:31+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/26/aoj1326-stylish</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1326">Stylish</a></h4><p>Stylish is a programming language whose syntax comprises names, that are sequences of Latin alphabet letters, three types of grouping symbols, periods ('.'), and newlines. Grouping symbols, namely round brackets ('(' and ')'), curly brackets ('{' and '}'), and square brackets ('[' and ']'), must match and be nested properly.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

i番目までの括弧の量を先に計算しておく．{% m %} R {% em %}, {% m %} C {% em %}, {% m %} S {% em %}を総当りしてインデントが合う組み合わせを見つける． {% m %} 2 {% em %}つ以上ある場合は {% m %} -1 {% em %}にする．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int n, m;
	while(cin >> n >> m) {
		if(n == 0 && m == 0) break;

		vector<string> v(n), v2(m);
		rep(i, n) cin >> v[i];
		rep(i, m) cin >> v2[i];

		int r[105], c[105], s[105];
		memset(r, 0, sizeof(r));
		memset(c, 0, sizeof(c));
		memset(s, 0, sizeof(s));

		REP(i, 1, n) {
			r[i] = r[i-1];
			c[i] = c[i-1];
			s[i] = s[i-1];
			rep(j, v[i-1].size()) {
				char ch = v[i-1][j];
				if(ch == '(') r[i]++;
				if(ch == ')') r[i]--;
				if(ch == '{') c[i]++;
				if(ch == '}') c[i]--;
				if(ch == '[') s[i]++;
				if(ch == ']') s[i]--;
			}
		}

		int r2[105], c2[105], s2[105];
		memset(r2, 0, sizeof(r2));
		memset(c2, 0, sizeof(c2));
		memset(s2, 0, sizeof(s2));

		REP(i, 1, m) {
			r2[i] = r2[i-1];
			c2[i] = c2[i-1];
			s2[i] = s2[i-1];
			rep(j, v2[i-1].size()) {
				char ch = v2[i-1][j];
				if(ch == '(') r2[i]++;
				if(ch == ')') r2[i]--;
				if(ch == '{') c2[i]++;
				if(ch == '}') c2[i]--;
				if(ch == '[') s2[i]++;
				if(ch == ']') s2[i]--;
			}
		}

		int d[105];
		memset(d, 0, sizeof(d));

		rep(i, n) {
			rep(j, v[i].size()) {
				if(v[i][j] != '.') {
					d[i] = j;
					break;
				}
			}
		}

		vector<int> ans(m);
		rep(i, m) ans[i] = INF;

		REP(i, 1, 21) {
			REP(j, 1, 21) {
				REP(k, 1, 21) {
					bool flag = true;

					rep(l, n) {
						if(d[l] == i * r[l] + j * c[l] + k * s[l]) continue;
						flag = false;
					}

					if(flag) {
						rep(l, m) {
							int d = i * r2[l] + j * c2[l] + k * s2[l];

							if(ans[l] == INF) ans[l] = d;
							else if(ans[l] != d) ans[l] = -1;
						}
					}
				}
			}
		}

		rep(i, m) {
			cout << ans[i];
			if(i == m-1) cout << endl;
			else cout << " ";
		}
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2166 Erratic Sleep Habits]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/24/aoj2166-erratic-sleep-habits/"/>
    <updated>2016-03-24T02:13:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/24/aoj2166-erratic-sleep-habits</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2166">Erratic Sleep Habits</a></h4><p>Peter is a person with erratic sleep habits. He goes to sleep at twelve o'lock every midnight. He gets up just after one hour of sleep on some days; he may even sleep for twenty-three hours on other days. His sleeping duration changes in a cycle, where he always sleeps for only one hour on the first day of the cycle.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

睡眠周期 {% m %} T_i {% em %}が与えられる．カフェインを取ることでこの睡眠周期を最初に戻すことが出来るとき，全ての予定をこなせるカフェインの量の最大値を求める．  
{% math %}
	dp[i][j] := i日目に睡眠周期jの時のカフェインの最小値
{% endmath %}
とした． {% m %} j = 0 {% em %}の場合は {% m %} i-1 {% em %}のどこからでも {% m %} +1 {% em %}(カフェインを取ること)で遷移できて，他の場合は {% m %} T_j {% em %}が {% m %} i {% em %}日目の一番最初の予定より早ければ， {% m %} dp[i-1][j-1] {% em %}より遷移できる．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int t;
	while(cin >> t && t) {

		vector<int> v(t);
		rep(i, t) cin >> v[i];

		int n;
		cin >> n;

		vector<int> d(n), m(n);
		int dm[105], day = 0;
		rep(i, 105) dm[i] = INF;

		rep(i, n) {
			cin >> d[i] >> m[i];
			dm[d[i]-1] = min(dm[d[i]-1], m[i]);
			day = max(day, d[i]);
		}

		int dp[105][35];
		rep(i, 105) rep(j, 35) dp[i][j] = INF;

		dp[0][0] = 0;

		REP(i, 1, day) {
			rep(j, t) {
				if(j == 0) {
					rep(k, t) {
						dp[i][j] = min(dp[i][j], dp[i-1][k] + 1);
					}
					dp[i][j] = min(dp[i][j], dp[i-1][t-1]);
				} else {
					if(v[j] <= dm[i]) {
						dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
					}
				}
			}
		}

		int ans = INF;
		rep(i, t) {
			ans = min(ans, dp[day-1][i]);
		}

		cout << ans << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1327 One-Dimensional Cellular Automaton]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/24/aoj1327-one-dimensional-cellular-automaton/"/>
    <updated>2016-03-24T01:32:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/24/aoj1327-one-dimensional-cellular-automaton</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1327">One-Dimensional Cellular Automaton</a></h4><p>There is a one-dimensional cellular automaton consisting of cells. Cells are numbered from 0 to N − 1. Each cell has a state represented as a non-negative integer less than M. The states of cells evolve through discrete time steps. We denote the state of the i-th cell at time t as S( i, t).</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

{% math %}
	S(i, t+1) = A \cdot S(i-1, t) + B \cdot S(i, t) + C \cdots S(i+1, t) {\rm mod} M
{% endmath %}
をそのままやると {% m %} O(NT) {% em %}となり間に合わない．変換行列を

{% math %}
	\left(
		\begin{array}{ccccc}
			b & c & 0 & 0 & 0 \\
			a & b & c & 0 & 0 \\
			0 & a & b & c & 0 \\
			0 & 0 & a & b & c \\
			0 & 0 & 0 & a & b \\
		\end{array}
	\right) 
{% endmath %}

とする．これの行列の{% m %} (i, j) {% em %}が{% m %} S(j, 0) {% em %}の係数となる．よって

{% math %}
	\left(
		\begin{array}{ccccc}
			b & c & 0 & 0 & 0 \\
			a & b & c & 0 & 0 \\
			0 & a & b & c & 0 \\
			0 & 0 & a & b & c \\
			0 & 0 & 0 & a & b \\
		\end{array}
	\right) ^T
	\left(
		\begin{array}{c}
			S(0, 0) \\
			S(1, 0) \\
			S(2, 0) \\
			S(3, 0) \\
			S(4, 0)
		\end{array}
	\right)
	
{% endmath %}

この変換行列の {% m %} T {% em %}乗は {% m %} logT {% em %}で出来るので {% m %} O(N logT) {% em %}となり間に合う．  
行列累乗の問題を初めて解けた(文字のまま展開していたら気付いた)．非常に嬉しい．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int MOD;

struct Mat {
	vector<vector<ll> > dat;
	int n;

	Mat(int n) : n(n), dat(n, vector<ll>(n)) {}

	Mat(vector<vector<ll> > dat) : n(dat.size()), dat(dat) {}

	Mat I(int n) {
		Mat ret(n);
		rep(i, n) ret.dat[i][i] = 1;
		return ret;
	}

	Mat mul(Mat &b) {
        Mat ret(n);
		rep(i, n) rep(j, n) rep(k, n) (ret.dat[i][j] += dat[i][k] * b.dat[k][j]) %= MOD;
        return ret;
	}

	Mat pow(ll b) {
		Mat ret = I(n);
        for (Mat A = *this; b > 0; A = A.mul(A) , b /= 2) if (b & 1) ret = A.mul(ret);
        return ret;
	}
};

int main() {
	int n, m, a, b, c, t;
	while(cin >> n >> m >> a >> b >> c >> t) {
		if(n == 0 && m == 0 && a == 0 && b == 0 && c == 0 && t == 0) break;

		MOD = m;

		vector<int> s(n);
		rep(i, n) cin >> s[i];

		int s1 = -1, s2 = 0, s3 = 1;
		Mat mat(n);
		rep(i, n) {
			if(s1 >= 0) {
				mat.dat[i][s1] = a;
			}
			mat.dat[i][s2] = b;
			if(s3 < n) {
				mat.dat[i][s3] = c;
			}
			
			s1++; s2++; s3++;
		}

		Mat ret = mat.pow(t);

		rep(i, n) {
			ll sum = 0;
			rep(j, n) {
				sum += s[j] * ret.dat[i][j];
				sum %= MOD;
			}

			cout << sum;

			if(i == n-1) cout << endl;
			else cout << " ";
		}
	}

	return 0;
}
```

]]></content>
  </entry>
  
</feed>
