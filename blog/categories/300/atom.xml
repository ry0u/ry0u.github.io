<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 300 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/300/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-23T20:46:47+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ2369 CatChecker]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/23/aoj2369-catchecker/"/>
    <updated>2016-03-23T20:34:54+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/23/aoj2369-catchecker</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2369">CatChecker | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>区間 <script type="math/tex"> [l, r] </script>がねこ鳴き声か探索する．区間の端が <script type="math/tex"> m </script>， <script type="math/tex"> w </script>で真ん中の <script type="math/tex"> e </script>で区切ってみる．メモ化しないとTLEした．逆からやると一意に決まる系かと思ったけどそんなことなかった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

string s;
int memo[505][505];

bool dfs(int l, int r) {
    if(l &gt; r) return true;
    if(memo[l][r] != -1) return memo[l][r];

    if(s[l] == 'm' &amp;&amp; s[r] == 'w') {
        REP(i, l+1, r) {
            if(s[i] == 'e') {
                if(dfs(l+1, i-1) &amp;&amp; dfs(i+1, r-1)) {
                    return memo[l][r] = true;
                }
            }
        }
    }
    return memo[l][r] = false;
}

int main() {
    cin &gt;&gt; s;
    memset(memo, -1, sizeof(memo));

    if(dfs(0, s.size()-1)) {
        cout &lt;&lt; "Cat" &lt;&lt; endl;
    } else {
        cout &lt;&lt; "Rabbit" &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1305 Membership Management]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/23/aoj1305-membership-management/"/>
    <updated>2016-03-23T20:07:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/23/aoj1305-membership-management</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1305">Membership Management</a></h4><p>Peter is a senior manager of Agile Change Management (ACM) Inc., where each employee is a member of one or more task groups. Since ACM is agile, task groups are often reorganized and their members frequently change, so membership management is his constant headache.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>group1のmenberを順番にstackに入れていく．menberがgroupの時は，そのgroupを全てstackに入れる．重複がないように確定したメンバーはsetに突っ込む．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;stack&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

vector&lt;string&gt; split(const string &amp;str, char delim) {
    vector&lt;string&gt; res;
    size_t current = 0, found;
    while((found = str.find_first_of(delim, current)) != string::npos) {
        res.push_back(string(str, current, found - current));
        current = found + 1;
    }
    res.push_back(string(str, current, str.size() - current));
    return res;
}

int main() {
    int n;
    while(cin &gt;&gt; n &amp;&amp; n) {
        vector&lt;string&gt; s(n);
        rep(i, n) cin &gt;&gt; s[i];

        map&lt;string, set&lt;string&gt; &gt; m;
        map&lt;string, int&gt; id;
        vector&lt;string&gt; res[n];
        rep(i, n) {
            vector&lt;string&gt; ret = split(s[i], ':');
            id[ret[0]] = i;
            string t = "";
            rep(j, ret[1].size()) {
                if(ret[1][j] == ',' || ret[1][j] == '.') {
                    m[ret[0]].insert(t);
                    res[i].push_back(t);
                    t = "";
                } else {
                    t += ret[1][j];
                }
            }
        }

        set&lt;string&gt; S;
        stack&lt;string&gt; st;
        bool used[105];
        memset(used, 0, sizeof(used));
        used[0] = true;

        rep(i, res[0].size()) {
            st.push(res[0][i]);

            while(st.size()) {
                string tp = st.top();
                st.pop();

                if(m.count(tp) == 0) {
                    S.insert(tp);
                } else if(!used[id[tp]]){
                    used[ id[tp] ] = true;

                    set&lt;string&gt;::iterator ite;
                    for(ite = m[tp].begin(); ite != m[tp].end(); ite++) {
                        st.push(*ite);
                    }
                }
            }
        }

        cout &lt;&lt; S.size() &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2021 Princess in Danger]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/23/aoj2021-princess-in-danger/"/>
    <updated>2016-03-23T19:48:34+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/23/aoj2021-princess-in-danger</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2021">Princess in Danger | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>状態を <script type="math/tex"> (cost, 残り時間, 番号) </script>としてdijkstra．現在の状態の残り時間のほうが辺のコストより大きい時に，次の町に行くことが可能．冷凍施設にいるときは， 現在の残り時間から<script type="math/tex"> M </script>まで回復出来るので <script type="math/tex"> 1 </script>分ずつ試す．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;
typedef pair&lt;P, int&gt; PI;
typedef pair&lt;P, P &gt; PP;

struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

int n, m, l, k, a, h;
vector&lt;edge&gt; G[105];
int d[105][105];
bool L[105];

void dijkstra(int s) {
    priority_queue&lt;PI, vector&lt;PI&gt;, greater&lt;PI&gt; &gt; que;
    rep(i, 105) {
        rep(j, 105) {
            d[i][j] = INF;
        }
    }

    d[s][m] = 0;
    que.push(PI(P(0, m), s));

    while(que.size()) {
        PI p = que.top();
        que.pop();

        int cost = p.first.first;
        int t = p.first.second;
        int v = p.second;
        if(d[v][t] &lt; cost) continue;

        if(L[v]) {
            REP(i, t+1, m+1) {
                if(d[v][i] &gt; d[v][t] + (i - t)) {
                    d[v][i] = d[v][t] + (i - t);
                    que.push(PI(P(d[v][i], i), v) );
                }
            }
        }

        rep(i, G[v].size()) {
            edge e = G[v][i];
            int nt = t - e.cost;
            if(nt &gt;= 0 &amp;&amp; d[e.to][nt] &gt; d[v][t] + e.cost) {
                d[e.to][nt] = d[v][t] + e.cost;
                que.push(PI(P(d[e.to][nt], nt), e.to));
            }
        }
    }
}


int main() {
    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; k &gt;&gt; a &gt;&gt; h) {
        if(n == 0 &amp;&amp; m == 0 &amp;&amp; l == 0 &amp;&amp; k == 0 &amp;&amp; a == 0 &amp;&amp; h == 0) break;

        rep(i, 105) G[i].clear();
        memset(L, 0, sizeof(L));

        rep(i, l) {
            int x;
            cin &gt;&gt; x;
            L[x] = true;
        }

        rep(i, k) {
            int s, t, c;
            cin &gt;&gt; s &gt;&gt; t &gt;&gt; c;
            G[s].push_back(edge(t, c));
            G[t].push_back(edge(s, c));
        }

        dijkstra(a);

        int ans = INF;
        rep(i, m + 1) {
            ans = min(ans, d[h][i]);
        }

        if(ans == INF) cout &lt;&lt; "Help!" &lt;&lt; endl;
        else cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2002 X-Ray Screening System]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/23/aoj2002-x-ray-screening-system/"/>
    <updated>2016-03-23T19:25:35+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/23/aoj2002-x-ray-screening-system</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2002">X-Ray Screening System | Aizu Online Judge</a></h4><p>上記の調査結果をふまえて，以下のような手荷物検査のためのモデルを考案した．それぞれの手荷物は X 線に対して透明である直方体の容器だとみなす．その中には X 線に対して不透明である複数の品物が入っている．ここで，直方体の 3 辺を x 軸，y 軸，z 軸とする座標系を考え，x 軸と平行な方向に X 線を照射して，y-z 平面に投影された画像を撮影する．撮影された画像は適当な大きさの格子に分割され，画像解析によって，それぞれの格子領域に映っている品物の材質が推定される．この会社には非常に高度の解析技術があり，材質の詳細な違いすらも解析することが可能であることから，品物の材質は互いに異なると考えることができる．なお，複数の品物が x 軸方向に関して重なっているときは，それぞれの格子領域について最も手前にある，すなわち x 座標が最小である品物の材質が得られる．また，2 つ以上の品物の x 座標が等しいことはないと仮定する．</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>もっとも手前にある品物から順番に処理していく．長方形なので，一番左上<script type="math/tex"> (sx, sy) </script>と右下 <script type="math/tex"> (gx, gy) </script>を持っておき， <script type="math/tex"> (sx, sy) </script>， <script type="math/tex"> (gx, sy) </script>， <script type="math/tex"> (sx, gy) </script>， <script type="math/tex"> (gx, gy) </script>の4角形全てに同じ品物の材質，または前面に他の品物がある時に埋めた．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int w, h;
int sy, sx, gy, gx;
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1};

bool can(int y,int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}

vector&lt;string&gt; s;
char c;
bool used[55][55], visited[55][55];

bool check() {
    REP(i, sy, gy+1){
        REP(j, sx, gx+1) {
            if(s[i][j] == c || used[i][j]) continue;
            return false;
        }
    }
    return true;
}

void f() {
    REP(i, sy, gy+1) {
        REP(j, sx, gx+1) {
            used[i][j] = true;
        }
    }
}

int main() {
    int n;
    cin &gt;&gt; n;

    rep(q, n) {
        cin &gt;&gt; h &gt;&gt; w;
        s.resize(h);
        rep(i, h) cin &gt;&gt; s[i];

        memset(used, 0, sizeof(used));
        set&lt;char&gt; S;

        bool flag = true, update = true;
        while(update) {
            update = false;
            rep(i, h) {
                rep(j, w) {
                    if(s[i][j] == '.') continue;

                    if(used[i][j]) continue;

                    sy = i;
                    sx = j;
                    gy = i;
                    gx = j;
                    c = s[i][j];
                    memset(visited, 0, sizeof(visited));

                    rep(k, h) {
                        rep(l, w) {
                            if(s[k][l] == c) {
                                sy = min(sy, k);
                                sx = min(sx, l);
                                gy = max(gy, k);
                                gx = max(gx, l);
                            }
                        }
                    }

                    if(S.find(c) == S.end() &amp;&amp; check()) {
                        f();
                        S.insert(c);
                        update = true;
                    }
                }
            }
        }

        rep(i, h) {
            rep(j, w) {
                if(used[i][j]) continue;
                if(s[i][j] == '.') continue;
                flag = false;
            }
        }

        if(flag) cout &lt;&lt; "SAFE" &lt;&lt; endl;
        else cout &lt;&lt; "SUSPICIOUS" &lt;&lt; endl;

    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1188 Hierarchical Democracy]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/23/aoj1188-hierarchical-democracy/"/>
    <updated>2016-03-23T18:25:06+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/23/aoj1188-hierarchical-democracy</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1188">Hierarchical Democracy</a></h4><p>The presidential election in Republic of Democratia is carried out through multiple stages as follows. There are exactly two presidential candidates. At the first stage, eligible voters go to the polls of his/her electoral district. The winner of the district is the candidate who takes a majority of the votes.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>木として考える．葉にその区画に勝つための最小の値， <script type="math/tex"> \frac{値}{2} + 1 </script>を入れる．子の数の半分，小さい順に取っていく．最後に根の値が最小値になっているはず．</p>

<p><img src="/images/AOJ/1188-1.png">
<img src="/images/AOJ/1188-2.png"></p>

<p><img src="/images/AOJ/1188-3.png"></p>

<p>子の階層から小さい順に取りたいので，priority_queueを利用した．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; que[100005];

int main() {
    int n;
    cin &gt;&gt; n;

    rep(q, n) {
        rep(i, 100005) {
            while(que[i].size()) que[i].pop();
        }

        string s;
        cin &gt;&gt; s;

        int dep = 0;
        rep(i, s.size()) {

            if(s[i] == '[') {
                if(s[i+1] == '[') {
                    dep++;
                } else {
                    stringstream ss;
                    REP(j, i+1, s.size()) {
                        if('0' &lt;= s[j] &amp;&amp; s[j] &lt;= '9') {
                            ss &lt;&lt; s[j];
                            i++;
                        } else {
                            i++;
                            break;
                        }
                    }

                    ll x;
                    ss &gt;&gt; x;

                    x = x / 2 + 1;
                    que[dep].push(x);
                }
            } else if(s[i] == ']') {
                int m = que[dep].size();
                ll sum = 0;

                rep(j, m/2 + 1) {
                    sum += que[dep].top();
                    que[dep].pop();
                }

                que[dep-1].push(sum);

                while(que[dep].size()) {
                    que[dep].pop();
                }

                dep--;
            }

        }

        cout &lt;&lt; que[0].top() &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
