<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 探索 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/tan-suo/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-10T01:42:35+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM315 D1M SillySudoku]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/06/srm315-d1m-sillysudoku/"/>
    <updated>2016-10-06T00:14:22+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/06/srm315-d1m-sillysudoku</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6629&rd=9995">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

図にあるとおりに，$A$, $B$, $C$, $D$の各枠に$1$, $2$, $3$, $4$の数字を入れて，縦横数字の重なりが無いパターンはいくつあるか．これは$4\times 4$なので，愚直にシミュレーションできる．基本的に何も数字が与えられなければ，$1 \sim 4$の全て入る可能性がある．与えられた数字からそれを省いてシミュレーションしていく．$-$のマスに入る可能性のある数字を試していき，$-$にも関わらず入る数字が無くなければそこで終了．最後まで終わった時に，完成したものが正しいものかどうか判定してカウントした．  

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int ans = 0;
vector<P> v;

int dy[4] = {0, 0, 2, 2};
int dx[4] = {0, 2, 0, 2};
int ID[4][4] = {0};

void dfs(int id, set<int> st[4][4], vector<string> s) {
	if(id == v.size()) {
		bool ok = true;
		rep(t, 4) {
			set<int> ch;
			REP(i, dy[t], dy[t] + 2) {
				REP(j, dx[t], dx[t] + 2) {
					ch.insert(s[i][j]);
				}
			}

			if(ch.size() == 4) continue;
			ok = false;
		}

		rep(i, 4) {
			rep(j, 4) {
				set<int> ch;
				rep(y, 4) {
					rep(x, 4) {
						if(y == i) ch.insert(s[y][x]);
					}
				}

				if(ch.size() != 4) ok = false;

				ch.clear();
				rep(y, 4) {
					rep(x, 4) {
						if(x == j) ch.insert(s[y][x]);
					}
				}

				if(ch.size() != 4) ok = false;
			}
		}

		if(ok) {
			ans++;
		}
		return;
	}

	int y = v[id].first;
	int x = v[id].second;

	if(st[y][x].size() == 0) return;

	set<int> tmp[4][4];
	rep(i, 4) rep(j, 4) tmp[i][j] = st[i][j];

	vector<string> res = s;

	each(it, st[y][x]) {
		int d = *it;
		vector<P> pre;
		res[y][x] = char('0' + *it);

		rep(i, 4) {
			rep(j, 4) {
				if(i == y || j == x) {
					if(tmp[i][j].find(d) == tmp[i][j].end()) continue;
					tmp[i][j].erase(d);
					pre.push_back(mp(i, j));
				}
			}
		}

		int t = ID[y][x];
		REP(i, dy[t], dy[t] + 2) {
			REP(j, dx[t], dx[t] + 2) {
				if(tmp[i][j].find(d) == tmp[i][j].end()) continue;
				tmp[i][j].erase(d);
				pre.push_back(mp(i, j));
			}
		}

		dfs(id + 1, tmp, res);
		res[y][x] = '-';

		rep(i, pre.size()) {
			tmp[pre[i].first][pre[i].second].insert(*it);
		}
	}
}

class SillySudoku {

    public:

    int countWays(vector <string> board) {
		int n = 4;
		set<int> st[4][4];

		v.clear();
		rep(i, n) {
			rep(j, n) {
				rep(k, n) {
					st[i][j].insert(k+1);
				}
			}
		}

		bool flag = false;

		rep(t, 4) {
			set<int> del;
			REP(i, dy[t], dy[t] + 2) {
				REP(j, dx[t], dx[t] + 2) {
					ID[i][j] = t;
					if(board[i][j] == '-') {
						v.push_back(mp(i, j));
						continue;
					}

					int d = int(board[i][j] - '0');
					del.insert(d);
				}
			}

			
			REP(i, dy[t], dy[t] + 2) {
				REP(j, dx[t], dx[t] + 2) {
					each(it, del) {
						if(st[i][j].find(*it) == st[i][j].end()) continue;
						st[i][j].erase(*it);
					}
				}
			}
		}

		rep(i, 4) {
			rep(j, 4) {
				if(board[i][j] == '-') continue;
				int d = int(board[i][j] - '0');
				rep(y, 4) {
					rep(x, 4) {
						if(y == i || x == j) {
							if(st[y][x].find(d) == st[y][x].end()) continue;
							st[y][x].erase(d);
						}
					}
				}
			}
		}

		if(flag) {
			return 0;
		}

		ans = 0;
		dfs(0, st, board);
		return ans;
    }
};
```
]]></content>
  </entry>
  
</feed>
