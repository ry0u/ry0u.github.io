<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: メモ化再起 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/memohua-zai-qi/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-10T01:42:35+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM334 D1M-D2H ExtendedHappyNumbers]]></title>
    <link href="http://ry0u.github.io/blog/2017/02/03/srm334-d1m-d2h-extendedhappynumbers/"/>
    <updated>2017-02-03T00:18:35+09:00</updated>
    <id>http://ry0u.github.io/blog/2017/02/03/srm334-d1m-d2h-extendedhappynumbers</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7244&rd=10658">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$S\_K(N)$は$N$の各桁を$K$乗した和と定義される．$S\_2(65) = 6 ^2 + 5 ^2 = 61$である．$N$に対する数列は

$$
	[N, S\_K(N), S\_K (S\_K (N) ), ...]
$$

と定義される．$N$, $K$が与えられた時の$happiness$は数列の中の最小値である．$A, B, K$が与えられるので，$A \sim B$の各$happiness$の和を求める．

---

$A \sim B$のそれぞれの数について数列を求めるが，別の数列を求めていたとしても同じ数が途中に出現すればそれ以降は同じになるので，これをメモ化する．内容はその後の最小値である．最大値は$N = 999999, K = 6$の$2125764$であるが十分に余裕を持って配列を持った．後はそれぞれについて$happiness$を求め，その和を答える．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
#include <set>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

ll memo[5000005], k;

ll f(ll x) {
	ll ret = 0;
	while(x) {
		ll y = (x % 10), t = 1;
		rep(i, k) {
			t *= y;
		}
		ret += t;
		x /= 10;
	}
	return ret;
}

ll dfs(ll x) {
	if(memo[x] != -1) {
		if(memo[x] == INF) {
			ll y = x, res = x;
			while(true) {
				y = f(y);
				res = min(res, y);
				if(y == x) break;
			}
			return memo[x] = res;
		} else return memo[x];
	}

	memo[x] = INF;
	ll res = min(x, dfs( f(x)) );
	return memo[x] = res;
}

class ExtendedHappyNumbers {

    public:

    long long calcTheSum(int A, int B, int K) {
		ll ans = 0;
		memset(memo, -1, sizeof(memo));
		k = K;

		REP(i, A, B + 1) {
			ans += dfs(i);
		}

		return ans;
    }
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM331 D2H ChrismasTree]]></title>
    <link href="http://ry0u.github.io/blog/2016/12/04/srm331-d2h-chrismastree/"/>
    <updated>2016-12-04T00:09:28+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/12/04/srm331-d2h-chrismastree</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=7261&rd=10011">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>
<!-- more -->

$N$段目に$N$個のノードがあり，これを$R, G, B$の三色に乗り分けたい．各段には色が同じ数ではないといけない．その段に無い色はカウントしない．方法としては，一色に塗るか，二色に塗るか，三色に塗るかがある．

* 一色の場合，${}\_n C\_n$
* 二色の場合，${}\_n C\_{\frac{n}{2}} \times {}\_{\frac{n}{2}} C \_{\frac{n}{2}}$
* 三色の場合，${}\_n C\_{\frac{n}{3}} \times {}\_{\frac{2*n}{3}} C \_{\frac{n}{3}} \times {}\_{\frac{n}{3}} C \_{\frac{n}{3}}$

通り選び方があるのでかける．状態を$i$段目で各色が何色残っているかでメモ化した．

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair
#define MOD 1000000007

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

int n;
ll dp[12][51][51][51];

ll C[2005][2005];
void combination(int size) {
	for (int i = 0; i < size; i++) C[i][0] = 1LL;
	for (int i = 1; i < size; i++) {
		for (int j = 1; j <= i; j++) {
			C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
		}
	}
}

ll dfs(int dep, int r, int g, int b) {
	if(dp[dep][r][g][b] != -1) return dp[dep][r][g][b];
	if(dep == n + 1) {
		return dp[dep][r][g][b] = 1;
	}

	ll ret = 0;
	if(r - dep >= 0) {
		ret += dfs(dep + 1, r - dep, g, b);
	}
	if(g - dep >= 0) {
		ret += dfs(dep + 1, r, g - dep, b);
	}
	if(b - dep >= 0) {
		ret += dfs(dep + 1, r, g, b - dep);
	}

	if(dep % 2 == 0) {
		if(r - dep / 2 >= 0 && g - dep / 2 >= 0) {
			ret += dfs(dep + 1, r - dep / 2, g - dep / 2, b) * C[dep][dep/2];
		}
		if(g - dep / 2 >= 0 && b - dep / 2 >= 0) {
			ret += dfs(dep + 1, r, g - dep / 2, b - dep / 2) * C[dep][dep/2];
		}
		if(r - dep / 2 >= 0 && b - dep / 2 >= 0) {
			ret += dfs(dep + 1, r - dep / 2, g, b - dep / 2) * C[dep][dep/2];
		}
	}

	if(dep % 3 == 0) {
		if(r - dep / 3 >= 0 && g - dep / 3 >= 0 && b - dep / 3 >= 0) {
			ret += dfs(dep + 1, r - dep / 3, g - dep / 3, b - dep / 3) * C[dep][dep/3] * C[dep - dep / 3][dep/3];
		}
	}

	return dp[dep][r][g][b] = ret;
}

class ChristmasTree {
	public:
	long long decorationWays(int N, int red, int green, int blue) {
		n = N;
		combination(55);
		memset(dp, -1, sizeof(dp));

		return dfs(1, red, green, blue);
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM301 D2H CorrectingParenthesization]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/19/srm301-d2h-correctingparenthesization/"/>
    <updated>2016-08-19T18:27:02+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/19/srm301-d2h-correctingparenthesization</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6221&rd=9822">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$(, ), [, ], \\{, \\}$で構成される文字列を，$well\ formed$にするために，最小何回文字を変えることでできるか．$well\ formed$は以下のように定義される．


* 空文字列は$well\ formed$
* $s$を$well\ formed$とした時に，$(s)$，$[s]$，$\\{s\\}$もまた$well\ formed$
* $s, t$を$well\ formed$とした時，それを連結した文字列$st$も$well\ formed$

---

$$
	dp[l][r] := 区間[l, r)をwell\ formedにするための最小回数
$$
とした．$2$番目の条件として区間$[l, r)$を見る場合，$s[l]$と$s[r-1]$が括弧として成立している場合はそのまま，片方違う場合は$+1$，それ以外は$+2$，して括弧を外す(区間$[l+1, r-1)$を見る)．  
$3$番目の条件として，連結しても良いので，分ける場所を全探索する．必ず偶数長になるため，奇数長となる切り方はしないようにする．

# Code

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

int dp[55][55];
string s = "";

int f(int l, int r) {
	char a = s[l], b = s[r-1];
	if(a == '(' && b == ')') return 0;
	if(a == '{' && b == '}') return 0;
	if(a == '[' && b == ']') return 0;

	if(a == '(' || b == ')') return 1;
	if(a == '{' || b == '}') return 1;
	if(a == '[' || b == ']') return 1;

	return 2;
}

int dfs(int l, int r) {
	if(dp[l][r] != INF) return dp[l][r];
	if(l == r) return 0;
	int ret = INF, x = f(l, r);

	if(x == 0) ret = min(ret, dfs(l+1, r-1));
	else if(x == 1) ret = min(ret, dfs(l+1, r-1) + 1);
	else ret = min(ret, dfs(l+1, r-1) + 2);

	REP(i, l+1, r) {
		if((i - l) % 2 == 0) {
			ret = min(ret, dfs(l, i) + dfs(i, r));
		}
	}

	return dp[l][r] = ret;
}

class CorrectingParenthesization {
	public:
	int getMinErrors(string _s) {
		s = _s;
		int n = s.size();
		rep(i, 55) rep(j, 55) dp[i][j] = INF;

		return dfs(0, n);
	}
};
```


]]></content>
  </entry>
  
</feed>
