<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: メモ化再起 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/memohua-zai-qi/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-09-03T02:19:57+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM301 D2H CorrectingParenthesization]]></title>
    <link href="http://ry0u.github.io/blog/2016/08/19/srm301-d2h-correctingparenthesization/"/>
    <updated>2016-08-19T18:27:02+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/08/19/srm301-d2h-correctingparenthesization</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6221&rd=9822">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$(, ), [, ], \\{, \\}$で構成される文字列を，$well\ formed$にするために，最小何回文字を変えることでできるか．$well\ formed$は以下のように定義される．


* 空文字列は$well\ formed$
* $s$を$well\ formed$とした時に，$(s)$，$[s]$，$\\{s\\}$もまた$well\ formed$
* $s, t$を$well\ formed$とした時，それを連結した文字列$st$も$well\ formed$

---

$$
	dp[l][r] := 区間[l, r)をwell\ formedにするための最小回数
$$
とした．$2$番目の条件として区間$[l, r)$を見る場合，$s[l]$と$s[r-1]$が括弧として成立している場合はそのまま，片方違う場合は$+1$，それ以外は$+2$，して括弧を外す(区間$[l+1, r-1)$を見る)．  
$3$番目の条件として，連結しても良いので，分ける場所を全探索する．必ず偶数長になるため，奇数長となる切り方はしないようにする．

# Code

```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

int dp[55][55];
string s = "";

int f(int l, int r) {
	char a = s[l], b = s[r-1];
	if(a == '(' && b == ')') return 0;
	if(a == '{' && b == '}') return 0;
	if(a == '[' && b == ']') return 0;

	if(a == '(' || b == ')') return 1;
	if(a == '{' || b == '}') return 1;
	if(a == '[' || b == ']') return 1;

	return 2;
}

int dfs(int l, int r) {
	if(dp[l][r] != INF) return dp[l][r];
	if(l == r) return 0;
	int ret = INF, x = f(l, r);

	if(x == 0) ret = min(ret, dfs(l+1, r-1));
	else if(x == 1) ret = min(ret, dfs(l+1, r-1) + 1);
	else ret = min(ret, dfs(l+1, r-1) + 2);

	REP(i, l+1, r) {
		if((i - l) % 2 == 0) {
			ret = min(ret, dfs(l, i) + dfs(i, r));
		}
	}

	return dp[l][r] = ret;
}

class CorrectingParenthesization {
	public:
	int getMinErrors(string _s) {
		s = _s;
		int n = s.size();
		rep(i, 55) rep(j, 55) dp[i][j] = INF;

		return dfs(0, n);
	}
};
```


]]></content>
  </entry>
  
</feed>
