<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lca | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/lca/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-05-12T01:24:24+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ABC014D 閉路]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/03/abc014d-bi-lu/"/>
    <updated>2016-04-03T18:09:24+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/03/abc014d-bi-lu</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://abc014.contest.atcoder.jp/tasks/abc014_4">D: 閉路 - AtCoder Beginner Contest 014 | AtCoder</a></h4><p>(null)</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>木に <script type="math/tex"> 1 </script>本付け加えて出来る閉路は，つなげる <script type="math/tex"> 2 </script>点とその <script type="math/tex"> 2 </script>点の最小共通祖先で出来る三角形になるはずである．よって， <script type="math/tex"> LCA(a, b) </script>を求めた後に，その三角形の長さを出力した．長さは <script type="math/tex"> LCA </script>を求める際に深さが出ているので，そこから出せる．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

vector&lt;int&gt; G[100005];
int root;

int parent[20][100005];
int depth[100005];

void dfs(int v, int p, int d) {
    parent[0][v] = p;
    depth[v] = d;
    rep(i, G[v].size()) {
        if(G[v][i] != p) dfs(G[v][i], v, d+1);
    }
}

void init(int V) {
    dfs(root, -1, 0);
    for(int k = 0; k + 1 &lt; 20; k++) {
        rep(v, V) {
            if(parent[k][v] &lt; 0) parent[k + 1][v] = -1;
            else parent[k + 1][v]= parent[k][parent[k][v]];
        }
    }
}

int lca(int u, int v) {
    if(depth[u] &gt; depth[v]) swap(u, v);
    rep(k, 20) {
        if((depth[v] - depth[u]) &gt;&gt; k &amp; 1) {
            v = parent[k][v];
        }
    }
    if(u == v) return u;
    for(int k = 20 - 1; k &gt;= 0; k--) {
        if(parent[k][u] != parent[k][v]) {
            u = parent[k][u];
            v = parent[k][v];
        }
    }
    return parent[0][u];
}

int main() {
    int n;
    cin &gt;&gt; n;

    rep(i, n-1) {
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;

        x--; y--;
        G[x].push_back(y);
        G[y].push_back(x);
    }

    root = 0;
    init(n);

    int Q;
    cin &gt;&gt; Q;

    rep(q, Q) {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;

        a--; b--;

        int par = lca(a, b);

        cout &lt;&lt; (depth[a] - depth[par]) + (depth[b] - depth[par]) + 1 &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
