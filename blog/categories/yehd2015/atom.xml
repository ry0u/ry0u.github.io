<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: yehd2015 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/yehd2015/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2015-12-21T00:10:56+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Year End's Hack Day 2015参加記]]></title>
    <link href="http://ry0u.github.io/blog/2015/12/20/year-ends-hack-day-2015can-jia-ji/"/>
    <updated>2015-12-20T23:02:45+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/12/20/year-ends-hack-day-2015can-jia-ji</id>
    <content type="html"><![CDATA[<p>明治大学NCC主催 Year End&rsquo;s Hack Day 2015に参加しました<br/>
<a href="http://eventdots.jp/event/576488">http://eventdots.jp/event/576488</a></p>

<p>むっちゃ適当に箇条書き．</p>

<ul>
<li>会場が広いし綺麗で最高だった．</li>
<li>開始後，CTFの問題を少し見るも，何も出来ず</li>
<li>競プロでWAをたくさん生やす</li>
<li>最終scoreは2930（競プロ問題の配点が高すぎた?）</li>
<li>解説の時間が短かったのがちょっと残念</li>
<li>CTFの解説は何を言ってるのかワケワカメ状態．精進したい</li>
<li>懇親会が最高and最高</li>
</ul>


<p>参加者の方々，特に運営の方々はお疲れ様でした．非常に楽しいイベントでした．ありがとうございました．</p>

<p>以下，問題とコード</p>

<h2>A : クリスマス</h2>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    ll a, b;
    cin &gt;&gt; a &gt;&gt; b;

    if(a &lt;= b) {
        cout &lt;&lt; 1 &lt;&lt; endl;
        return 0;
    }

    ll ans =  a / b;

    if(a % b == 0) {
        cout &lt;&lt; ans &lt;&lt; endl;
    } else {
        cout &lt;&lt; ans + 1 &lt;&lt; endl;
    }

    return 0;
}
</code></pre>

<h2>B : Decode Me</h2>

<p>問題名は果たしてこれであっているのでしょうか．まず問題文に辿りつけずﾁｰﾝ．</p>

<h2>C : 優勝者</h2>

<p>それぞれソート</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;pair&lt;int, string&gt; &gt; a, b, c;

    rep(i, n) {
        string s;
        int d, e;

        cin &gt;&gt; s &gt;&gt; d &gt;&gt; e;

        if(d == 0) {
            bool flag = false;
            rep(j, a.size()) {
                if(a[j].second == s) {
                    flag = true;
                    a[j].first += e;
                    break;
                }
            }

            if(!flag) a.push_back(make_pair(e, s));
        } else if(d == 1) {
            bool flag = false;
            rep(j, b.size()) {
                if(b[j].second == s) {
                    flag = true;
                    b[j].first += e;
                }
            }

            if(!flag) b.push_back(make_pair(e, s));
        }

        bool flag = false;
        rep(j, c.size()) {
            if(c[j].second == s) {
                flag = true;
                c[j].first += e;
            }
        }
        if(!flag) c.push_back(make_pair(e, s));
    }

    sort(a.rbegin(), a.rend());
    sort(b.rbegin(), b.rend());
    sort(c.rbegin(), c.rend());

    if(a.size() == 0) cout &lt;&lt; -1 &lt;&lt; endl;
    else cout &lt;&lt; a[0].second &lt;&lt; " " &lt;&lt; a[0].first &lt;&lt; endl;

    if(b.size() == 0) cout &lt;&lt; -1 &lt;&lt; endl;
    else cout &lt;&lt; b[0].second &lt;&lt; " " &lt;&lt; b[0].first &lt;&lt; endl;

    if(c.size() == 0) cout &lt;&lt; -1 &lt;&lt; endl;
    else cout &lt;&lt; c[0].second &lt;&lt; " " &lt;&lt; c[0].first &lt;&lt; endl;

    return 0;
}
</code></pre>

<h2>D : ナイト</h2>

<p>場合分け．<script type="math/tex"> N  = 4</script>の時の正しい値が出せなくてWAをたくさん生やした</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    if(n == 1) {
        cout &lt;&lt; 0 &lt;&lt; endl;
    } else if(n == 2 || n == 3) {
        cout &lt;&lt; -1 &lt;&lt; endl;
    } else if(n == 4) {
        cout &lt;&lt; 16 &lt;&lt; endl;
    } else cout &lt;&lt; n * n - 1 &lt;&lt; endl;

    return 0;
}
</code></pre>

<h2>E : 1cm = 1cm</h2>

<p>まずlcm取ったのを約数列挙して，その約数同士のlcmが一致するか見た．重複がないようにsetにぶっこんだ．</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll lcm(ll m,ll n) {
    if(m == 0 || n == 0) return 0;
    return ((m / __gcd(m,n)) * n);
}

vector&lt;ll&gt; divisor(ll n) {
    vector&lt;ll&gt; res;
    for(ll i = 2; i*i &lt;= n; i++) {
        if(n % i == 0) {
            res.push_back(i);
            if(i != n/i) res.push_back(n/i);
        }
    }
    return res;
}

int main() {
    ll a, b;
    cin &gt;&gt; a &gt;&gt; b;

    ll d = lcm(a, b);
    vector&lt;ll&gt; v = divisor(d);

    v.push_back(1);
    v.push_back(d);

    sort(v.begin(), v.end());
    set&lt;ll&gt; st;

    ll ans = 0;
    rep(i, v.size()) {
        rep(j, v.size()) {
            ll e = lcm(v[i], v[j]);
            if(st.find(e) == st.end()) {
                if(d == e) ans++;
            }

            if(v[i] == v[j]) {
                st.insert(v[i]);
            }
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>

<h2>F : TomoriNao</h2>

<p>コピペしたら問題文が見れた．結局カットした木の葉を数えないようにすればよい．根が複数あることに気づかず，これもWAを生やした．</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

vector&lt;int&gt; G[100005];
vector&lt;int&gt; roots;
bool used[100005];

int ans = 0;
void dfs(int cur) {
    if(!used[cur] &amp;&amp; G[cur].size() != 0) {
        ans++;
    }

    used[cur] = true;
    rep(i, G[cur].size()) {
        if(!used[G[cur][i]]) {
            dfs(G[cur][i]);
        }
    }
}

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; v(n);
    rep(i, n) cin &gt;&gt; v[i];

    int k;
    cin &gt;&gt; k;

    rep(i, n) {
        if(v[i] == -1) {
            roots.push_back(i);
        } else {
            if(v[i] == k) continue;
            G[v[i]].push_back(i);
        }
    }

    memset(used, 0, sizeof(used));

    rep(i, roots.size()) {
        dfs(roots[i]);
    }

    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>

<h2>G : RGB-Query</h2>

<p>愚直にやったらダメなんだろうなとか思いつつ出したら（出すな）ACが取れた．解説でも愚直にやると間に合わなくて&hellip;とか言ってし，どうなんですか</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;

int R[100005],G[100005],B[100005],P[100005];

int main() {
    int n;
    cin &gt;&gt; n;

    rep(i, n) {
        cin &gt;&gt; R[i] &gt;&gt; G[i] &gt;&gt; B[i] &gt;&gt; P[i];
    }

    int q;
    cin &gt;&gt; q;

    rep(i, q) {
        int a, b, c, d, e, f;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f;
        int cnt = 0;

        rep(j, n) {
            if(a &lt;= R[j] &amp;&amp; R[j] &lt;= b &amp;&amp; c &lt;= G[j] &amp;&amp; G[j] &lt;= d &amp;&amp; e &lt;= B[j] &amp;&amp; B[j] &lt;= f) {
                cnt += P[j];
            }
        }

        cout &lt;&lt; cnt &lt;&lt; endl;
    }

    return 0;
}
</code></pre>

<h2>H : 逆転時計</h2>

<p>終了時間する時間が早い順にとる区間スケジューリング．これをm個超えるまで取り続ければ終わり．</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;P&gt; v(n);
    rep(i, n) {
        cin &gt;&gt; v[i].second &gt;&gt; v[i].first;
    }

    sort(v.begin(), v.end());

    bool used[10005];
    memset(used, 0, sizeof(used));

    int res = 0;
    int l = -1, r = -1;
    int ans = 0;

    while(true) {
        bool flag = true;
        rep(i, n) {
            if(!used[i]) flag = false;
        }

        if(flag) break;

        int r = -1;
        rep(i, n) {
            if(used[i]) continue;

            if(r &lt;= v[i].second) {
                r = v[i].first;
                res++;
                used[i] = true;
            }
        }

        ans++;

        if(res &gt;= m) break;
    }

    if(res &gt;= m) {
        cout &lt;&lt; ans-1 &lt;&lt; endl;
    } else {
        cout &lt;&lt; -1 &lt;&lt; endl;
    }

    return 0;
}
</code></pre>

<h2>I : ナイト再び</h2>

<p>状態を[x][y][手]で持った幅優先じゃだめなの?　よく分からず．<strong>AC取れてません</strong></p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll d[15][15][1005];
bool Q[15][15][1005];
int n, m;

int dx[8] = {+1,+2,+2,+1, -1,-2,-2,-1};
int dy[8] = {+2,+1,-1,-2, -2,-1,+1,+2};

bool can(int x, int y) {
    if(0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n) return true;
    return false;
}

int main() {
    cin &gt;&gt; n &gt;&gt; m;

    int sx, sy, gx, gy;
    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; gx &gt;&gt; gy;

    memset(d, 0, sizeof(d));
    memset(Q, 0, sizeof(Q));

    queue&lt;pair&lt;P, int&gt; &gt; que;
    que.push(mp(mp(sx, sy), 0));

    d[sx][sy][0] = 1;
    Q[sx][sy][0] = true;

    while(que.size()) {
        P p = que.front().first;
        int t = que.front().second;

        int x = p.first;
        int y = p.second;

        que.pop();
        Q[x][y][t] = false;

        if(t &gt;= m) continue;

        rep(i, 8) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if(can(nx, ny)) {
                d[nx][ny][t+1] += d[x][y][t];
                d[nx][ny][t+1] %= 1000000007;
                if(!Q[nx][ny][t+1]) {
                    que.push(mp(mp(nx, ny), t+1));
                    Q[nx][ny][t+1] = true;
                }
            }
        }
    }

    cout &lt;&lt; d[gx][gy][m] &lt;&lt; endl;

    return 0;
}
</code></pre>

<h2>J : 気まぐれ勇者</h2>

<p>逆からdijkstra．遷移先が<script type="math/tex"> V_i </script>を超えないようにする．</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[105];
int d[105];
int val[105];

void dijkstra(int s,int n) {
    priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; que;
    fill(d,d+n,INF);

    d[s] = 0;
    que.push(P(0,s));

    while(que.size()) {
        P p = que.top();
        que.pop();

        int v = p.second;
        if(d[v] &lt; p.first) continue;

        rep(i,G[v].size()) {
            edge e = G[v][i];
            int ncost = d[v] + e.cost;
            if(d[e.to] &gt; ncost &amp;&amp; val[e.to] &gt;= ncost) {
                d[e.to] = ncost;
                que.push(P(d[e.to],e.to));
            }
        }
    }
}

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    memset(d, 0, sizeof(d));
    memset(val, 0, sizeof(val));

    rep(i, n) cin &gt;&gt; val[i];
    rep(i, m) {
        int s, t, cost;
        cin &gt;&gt; s &gt;&gt; t &gt;&gt; cost;

        G[t].push_back(edge(s, cost));
    }

    int s, t;
    cin &gt;&gt; s &gt;&gt; t;

    dijkstra(t, n);

    if(d[s] == INF) cout &lt;&lt; "NO" &lt;&lt; endl;
    else cout &lt;&lt; "YES" &lt;&lt; endl;

    return 0;
}
</code></pre>

<h2>K : Non-decreasing Sequence of Longest Increasing Subsequence</h2>

<p>最初にlisを求める．大きい値から右にずらしていくが，その時にlisに含まれていない場合は追加して+1．含まれている場合はそのまま．これを繰り返す．</p>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

vector&lt;int&gt; lis(int n, vector&lt;int&gt; v) {
    vector&lt;int&gt; res(n);
    rep(i, n) res[i] = INF;

    rep(i, n) {
        *lower_bound(res.begin(), res.end(), v[i]) = v[i];
    }

    return res;
}

int main() {
    int n;
    cin &gt;&gt; n;

    vector&lt;int&gt; v(n);
    rep(i, n) cin &gt;&gt; v[i];

    vector&lt;int&gt; res = lis(n, v);
    sort(v.rbegin(), v.rend());

    int ans = 0;
    set&lt;int&gt; st;
    rep(i, n) {
        if(res[i] == INF) continue;
        ans++;
        st.insert(res[i]);
    }

    cout &lt;&lt; ans &lt;&lt; endl;
    rep(i, n) {
        if(st.find(v[i]) == st.end()) {
            ans++;
            *lower_bound(res.begin(), res.end(), v[i]) = v[i];
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
