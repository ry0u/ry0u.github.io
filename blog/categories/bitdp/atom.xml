<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: bitdp | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/bitdp/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2017-02-10T01:42:35+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SRM317 D2H OrdringCount]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/26/srm317-d2h-ordringcount/"/>
    <updated>2016-10-26T15:18:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/26/srm317-d2h-ordringcount</id>
    <content type="html"><![CDATA[<!-- more -->

グラフが与えられるのでトポロジカル順序の個数を答える．  
逆から考えていく．トポロジカル順序として一番最後となるのは，出次数が0のノードとなる．既に決めた頂点数集合$S$をbitとして持ち，

$$
	dp[S] := 頂点集合Sをトポロジカルソートする方法の数
$$

とする．逆から見て，この頂点集合$S$の次に選べるものは，頂点の隣接しているのものが頂点集合の中に既に含まれているか，隣接しているノードが無いかのどちらかである．最終的に$dp[(1<<n)-1]$が答えとなる．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

ll dp[1<<21];

class OrderingCount {
	public:
	long long countOrderings(vector <string> req) {
		int n = req.size();

		memset(dp, 0, sizeof(dp));
		dp[0] = 1;

		rep(i, 1<<n) {
			rep(j, n) {
				if(i & (1 << j)) continue;

				bool flag = true;
				rep(k, n) {
					if(i & (1 << k)) continue;
					if(req[j][k] == 'Y') flag = false;
				}

				if(flag) {
					dp[i | (1 << j)] += dp[i];
				}
			}
		}

		return dp[(1<<n)-1];
	}
};
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SRM314 D1M-D2H GrasslandFencer]]></title>
    <link href="http://ry0u.github.io/blog/2016/10/06/srm314-d1m-d2h-grasslandfencer/"/>
    <updated>2016-10-06T00:03:51+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/10/06/srm314-d1m-d2h-grasslandfencer</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="https://community.topcoder.com/stat?c=problem_statement&pm=6467&rd=9994">TopCoder Statistics - Problem Statement</a></h4><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2010, TopCoder, Inc. All rights reserved.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

辺が$n$本与えられるので，その辺の中で三角形を作り，その面積の合計を最大化する．辺の最大数が$16$と小さいので，辺を使ったか使っていないかの情報をbitで持つ．

$$
	dp[S] := 状態Sでの面積の最大値
$$

として動的計画法．現在見ている状態から，三角形を全探索し，まだ使っていない辺で構成されている場合にchmaxをする．三角形の条件，面積の求め方は問題ページに書いてあって優しさを感じた．

# Code
```cpp
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1<<30
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int, int> P;

double f(double a, double b, double c) {
	double p = (a + b + c) / 2;
	return sqrt(p * (p - a) * (p - b) * (p - c));
}

double dp[1 << 20];

class GrasslandFencer {
	public:
	double maximalFencedArea(vector <int> fences) {
		int n = fences.size();
		sort(fences.begin(), fences.end());

		memset(dp, 0, sizeof(dp));

		rep(bit, 1<<n) {
			rep(i, n) {
				REP(j, i+1, n) {
					REP(k, j+1, n) {
						double a = fences[i];
						double b = fences[j];
						double c = fences[k];

						if(a + b <= c) continue;

						int state = 0;
						state |= (1 << i);
						state |= (1 << j);
						state |= (1 << k);

						if(bit & state) continue;

						dp[bit | state] = max(dp[bit | state], dp[bit] + f(a, b, c));
					}
				}
			}
		}

		double ans = 0;
		rep(bit, 1<<n) {
			ans = max(ans, dp[bit]);
		}

		return ans;
	}
};
```
]]></content>
  </entry>
  
</feed>
