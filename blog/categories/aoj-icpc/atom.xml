<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: aoj-icpc | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/aoj-icpc/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-24T02:26:22+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ2166 Erratic Sleep Habits]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/24/aoj2166-erratic-sleep-habits/"/>
    <updated>2016-03-24T02:13:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/24/aoj2166-erratic-sleep-habits</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2166">Erratic Sleep Habits</a></h4><p>Peter is a person with erratic sleep habits. He goes to sleep at twelve o'lock every midnight. He gets up just after one hour of sleep on some days; he may even sleep for twenty-three hours on other days. His sleeping duration changes in a cycle, where he always sleeps for only one hour on the first day of the cycle.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>睡眠周期 {% m %} T_i {% em %}が与えられる．カフェインを取ることでこの睡眠周期を最初に戻すことが出来るとき，全ての予定をこなせるカフェインの量の最大値を求める．<br/>
{% math %}
    dp[i][j] := i日目に睡眠周期jの時のカフェインの最小値
{% endmath %}
とした． {% m %} j = 0 {% em %}の場合は {% m %} i-1 {% em %}のどこからでも {% m %} +1 {% em %}(カフェインを取ること)で遷移できて，他の場合は {% m %} T_j {% em %}が {% m %} i {% em %}日目の一番最初の予定より早ければ， {% m %} dp[i-1][j-1] {% em %}より遷移できる．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int t;
    while(cin &gt;&gt; t &amp;&amp; t) {

        vector&lt;int&gt; v(t);
        rep(i, t) cin &gt;&gt; v[i];

        int n;
        cin &gt;&gt; n;

        vector&lt;int&gt; d(n), m(n);
        int dm[105], day = 0;
        rep(i, 105) dm[i] = INF;

        rep(i, n) {
            cin &gt;&gt; d[i] &gt;&gt; m[i];
            dm[d[i]-1] = min(dm[d[i]-1], m[i]);
            day = max(day, d[i]);
        }

        int dp[105][35];
        rep(i, 105) rep(j, 35) dp[i][j] = INF;

        dp[0][0] = 0;

        REP(i, 1, day) {
            rep(j, t) {
                if(j == 0) {
                    rep(k, t) {
                        dp[i][j] = min(dp[i][j], dp[i-1][k] + 1);
                    }
                    dp[i][j] = min(dp[i][j], dp[i-1][t-1]);
                } else {
                    if(v[j] &lt;= dm[i]) {
                        dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
                    }
                }
            }
        }

        int ans = INF;
        rep(i, t) {
            ans = min(ans, dp[day-1][i]);
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1327 One-Dimensional Cellular Automaton]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/24/aoj1327-one-dimensional-cellular-automaton/"/>
    <updated>2016-03-24T01:32:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/24/aoj1327-one-dimensional-cellular-automaton</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1327">One-Dimensional Cellular Automaton</a></h4><p>There is a one-dimensional cellular automaton consisting of cells. Cells are numbered from 0 to N − 1. Each cell has a state represented as a non-negative integer less than M. The states of cells evolve through discrete time steps. We denote the state of the i-th cell at time t as S( i, t).</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>{% math %}
    S(i, t+1) = A \cdot S(i-1, t) + B \cdot S(i, t) + C \cdots S(i+1, t) {\rm mod} M
{% endmath %}
をそのままやると {% m %} O(NT) {% em %}となり間に合わない．変換行列を</p>

<p>{% math %}
    \left(
        \begin{array}{ccccc}
            b &amp; c &amp; 0 &amp; 0 &amp; 0 \
            a &amp; b &amp; c &amp; 0 &amp; 0 \
            0 &amp; a &amp; b &amp; c &amp; 0 \
            0 &amp; 0 &amp; a &amp; b &amp; c \
            0 &amp; 0 &amp; 0 &amp; a &amp; b \
        \end{array}
    \right)
{% endmath %}</p>

<p>とする．これの行列の{% m %} (i, j) {% em %}が{% m %} S(j, 0) {% em %}の係数となる．よって</p>

<p>{% math %}
    \left(
        \begin{array}{ccccc}
            b &amp; c &amp; 0 &amp; 0 &amp; 0 \
            a &amp; b &amp; c &amp; 0 &amp; 0 \
            0 &amp; a &amp; b &amp; c &amp; 0 \
            0 &amp; 0 &amp; a &amp; b &amp; c \
            0 &amp; 0 &amp; 0 &amp; a &amp; b \
        \end{array}
    \right) ^T
    \left(
        \begin{array}{c}
            S(0, 0) \
            S(1, 0) \
            S(2, 0) \
            S(3, 0) \
            S(4, 0)
        \end{array}
    \right)</p>

<p>{% endmath %}</p>

<p>この変換行列の {% m %} T {% em %}乗は {% m %} logT {% em %}で出来るので {% m %} O(N logT) {% em %}となり間に合う．<br/>
行列累乗の問題を初めて解けた(文字のまま展開していたら気付いた)．非常に嬉しい．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int MOD;

struct Mat {
    vector&lt;vector&lt;ll&gt; &gt; dat;
    int n;

    Mat(int n) : n(n), dat(n, vector&lt;ll&gt;(n)) {}

    Mat(vector&lt;vector&lt;ll&gt; &gt; dat) : n(dat.size()), dat(dat) {}

    Mat I(int n) {
        Mat ret(n);
        rep(i, n) ret.dat[i][i] = 1;
        return ret;
    }

    Mat mul(Mat &amp;b) {
        Mat ret(n);
        rep(i, n) rep(j, n) rep(k, n) (ret.dat[i][j] += dat[i][k] * b.dat[k][j]) %= MOD;
        return ret;
    }

    Mat pow(ll b) {
        Mat ret = I(n);
        for (Mat A = *this; b &gt; 0; A = A.mul(A) , b /= 2) if (b &amp; 1) ret = A.mul(ret);
        return ret;
    }
};

int main() {
    int n, m, a, b, c, t;
    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; t) {
        if(n == 0 &amp;&amp; m == 0 &amp;&amp; a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0 &amp;&amp; t == 0) break;

        MOD = m;

        vector&lt;int&gt; s(n);
        rep(i, n) cin &gt;&gt; s[i];

        int s1 = -1, s2 = 0, s3 = 1;
        Mat mat(n);
        rep(i, n) {
            if(s1 &gt;= 0) {
                mat.dat[i][s1] = a;
            }
            mat.dat[i][s2] = b;
            if(s3 &lt; n) {
                mat.dat[i][s3] = c;
            }

            s1++; s2++; s3++;
        }

        Mat ret = mat.pow(t);

        rep(i, n) {
            ll sum = 0;
            rep(j, n) {
                sum += s[j] * ret.dat[i][j];
                sum %= MOD;
            }

            cout &lt;&lt; sum;

            if(i == n-1) cout &lt;&lt; endl;
            else cout &lt;&lt; " ";
        }
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1248 The Balance]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/24/aoj1248-the-balance/"/>
    <updated>2016-03-24T01:23:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/24/aoj1248-the-balance</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1248">The Balance</a></h4><p>Ms. Iyo Kiffa-Australis has a balance and only two kinds of weights to measure a dose of medicine. For example, to measure 200mg of aspirin using 300mg weights and 700mg weights, she can put one 700mg weight on the side of the medicine and three 300mg weights on the opposite side (Figure 1).</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>重り {% m %} a {% em %}を使う量を決めると重り{% m %} b {% em %}を使う量が決まる．また重り {% m %} b {% em %}を決めると重り{% m %} a {% em %}を使う量が決まる．それぞれ使う量を全探索してどちらも使う量が非負整数の時に量の和，重さの和の最小を答える．上限を何も考えずに {% m %} 500000 {% em %}まで回したらオーバーフローで死んだ(完)． {% m %} \max{d} {% em %}までで良かった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int a, b, d;
    while(cin &gt;&gt; a &gt;&gt; b &gt;&gt; d) {
        if(a == 0 &amp;&amp; b == 0 &amp;&amp; d == 0) break;

        int g = __gcd(a, b);
        a /= g;
        b /= g;
        d /= g;

        int x = INF, y = INF, sum = INF, prod = INF;

        for(int i = 0; i &lt; 50000; i++ ) { 
            int c = d - a * i;
            if(abs(c) % b == 0) {
                int j = abs(c / b);

                if(i + j &lt; sum) {
                    sum = i + j;
                    prod = a*i + b*j;
                    x = i;
                    y = j;
                } else if(i + j == sum &amp;&amp; a*i + b*j &lt; prod) {
                    sum = i + j;
                    prod = a*i + b*j;
                    x = i;
                    y = j;
                }
            }
        }

        for(int j = 0; j &lt; 50000; j++) {
            int c = d - b * j;
            if(abs(c) % a == 0) {
                int i = abs(c / a);
                if(i + j &lt; sum) {
                    sum = i + j;
                    prod = a*i + b*j;
                    x = i;
                    y = j;
                } else if(i + j == sum &amp;&amp; a*i + b*j &lt; prod) {
                    sum = i + j;
                    prod = a*i + b*j;
                    x = i;
                    y = j;
                }
            }
        }

        cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1194 Vampire]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/24/aoj1194-vampire/"/>
    <updated>2016-03-24T00:28:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/24/aoj1194-vampire</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1194">Vampire</a></h4><p>Mr. C is a vampire. If he is exposed to the sunlight directly, he turns into ash. Nevertheless, last night, he attended to the meeting of Immortal and Corpse Programmers Circle, and he has to go home in the near dawn.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>ある点 {% m %} (x, y) {% em %}を端として決めると距離が決まる．Sample Input3を考えると下図のケースが最大である．<br/>
{% img /images/AOJ/1194.png %}</p>

<p>緑の線の長さは {% m %} {\rm sqrt} (r ^2 - x ^2) {% em %}になるので，求めたい赤の線の長さが {% m %} r + y - {\rm sqrt}(r ^2 - x ^2) {% em %}となる．建物が重なっている場所は一番大きい所を見て， {% m %} {\rm min}(H[i-1], H[i]) {% em %}が建物の角となり，その点を端として決めて一番短いものを答える．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int r, n;
    while(cin &gt;&gt; r &gt;&gt; n) {

        if(r == 0 &amp;&amp; n == 0) break;

        vector&lt;pair&lt;int, P&gt; &gt; v(n);
        rep(i, n) cin &gt;&gt; v[i].second.first &gt;&gt; v[i].second.second &gt;&gt; v[i].first;

        int H[60], GETA = 30;
        memset(H, 0, sizeof(H));

        rep(i, n) {
            int h = v[i].first, x1 = v[i].second.first, x2 = v[i].second.second;

            REP(j, x1, x2) {
                H[j + GETA] = max(H[j + GETA], h);
            }
        }

        double ans = INF;
        REP(i, -r+1, r) {
            double res = r + min(H[i + GETA], H[i - 1 + GETA]);
            ans = min(ans, res - sqrt(r*r - i*i));
        }

        cout &lt;&lt; fixed;
        cout.precision(4);
        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1315 Gift from the Goddess of Programming]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/23/aoj1315-gift-from-the-goddess-of-programming/"/>
    <updated>2016-03-23T21:21:54+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/23/aoj1315-gift-from-the-goddess-of-programming</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1315">Gift from the Goddess of Programming</a></h4><p>The goddess of programming is reviewing a thick logbook, which is a yearly record of visitors to her holy altar of programming. The logbook also records her visits at the altar. The altar attracts programmers from all over the world because one visitor is chosen every year and endowed with a gift of miracle programming power by the goddess.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>女神と被っている時間をそれぞれ出して，最大値を出力する．同じ日にちかどうか，時間がどう被っているかを注意しながらやったがバグを何個もしまった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

vector&lt;string&gt; split(const string &amp;str, char delim) {
    vector&lt;string&gt; res;
    size_t current = 0, found;
    while((found = str.find_first_of(delim, current)) != string::npos) {
        res.push_back(string(str, current, found - current));
        current = found + 1;
    }
    res.push_back(string(str, current, str.size() - current));
    return res;
}


// s1 - s2
int f(string s1, string s2) {
    int a = (s1[0] - '0') * 10 + (s1[1] - '0');
    int b = (s1[3] - '0') * 10 + (s1[4] - '0');
    int c = (s2[0] - '0') * 10 + (s2[1] - '0');
    int d = (s2[3] - '0') * 10 + (s2[4] - '0');

    if(a == c) {
        return b - d;
    } else {
        return (a - (c + 1)) * 60 + (60 - d) + b;
    }
}

int main() {
    int n;
    while(cin &gt;&gt; n &amp;&amp; n) {

        map&lt;string, vector&lt;pair&lt;string, string&gt; &gt; &gt; IN, OUT;

        rep(i, n) {
            string a, b, c, d;
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;

            if(c == "I") {
                IN[d].push_back(mp(a, b));
            } else {
                OUT[d].push_back(mp(a, b));
            }
        }

        int ans = 0;
        vector&lt;pair&lt;string, string&gt; &gt; gin = IN["000"];
        vector&lt;pair&lt;string, string&gt; &gt; gout = OUT["000"];


        map&lt;string, vector&lt;pair&lt;string, string&gt; &gt; &gt;::iterator in, out;
        for(in = IN.begin(), out = OUT.begin(); in != IN.end() &amp;&amp; out != OUT.end(); in++, out++) {
            if(in-&gt;first == "000") continue;

            vector&lt;pair&lt;string, string &gt; &gt; v = in-&gt;second;
            vector&lt;pair&lt;string, string &gt; &gt; v2 = out-&gt;second;

            int res = 0;
            rep(i, v.size()) {
                rep(j, gin.size()) {
                    if(v[i].first != gin[j].first) continue;

                    string a = v[i].second, b = v2[i].second, c = gin[j].second, d = gout[j].second;
                    if(c &lt;= a &amp;&amp; b &lt;= d) {
                        res += f(b, a);
                    } else if(a &lt;= c &amp;&amp; d &lt;= b) {
                        res += f(d, c);
                    } else if(c &lt;= a &amp;&amp; a &lt;= d &amp;&amp; d &lt;= b) {
                        res += f(d, a);
                    } else if(a &lt;= c &amp;&amp; c &lt;= b &amp;&amp; b &lt;= d) {
                        res += f(b, c);
                    }
                }
            }

            ans = max(ans, res);
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
