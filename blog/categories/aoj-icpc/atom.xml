<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: aoj-icpc | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/aoj-icpc/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-23T21:16:20+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ1306 Balloon Collecting]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/23/aoj1306-balloon-collecting/"/>
    <updated>2016-03-23T21:01:17+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/23/aoj1306-balloon-collecting</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1306">Balloon Collecting</a></h4><p>"Balloons should be captured efficiently", the game designer says. He is designing an oldfashioned game with two dimensional graphics. In the game, balloons fall onto the ground one after another, and the player manipulates a robot vehicle on the ground to capture the balloons.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>動的計画法．</p>

<p><script type="math/tex; mode=display">
    dp[i][j] := i個目の風船をj個集めた時の時間の最小値
</script></p>

<p>として， <script type="math/tex"> j \leq 3 </script>の時に風船を取りに行って間に合うならば <script type="math/tex"> dp[i+1][j+1] </script>に遷移可能， 今ある風船を家に置きに行って，次の風船を取りに言って間に合うならば <script type="math/tex"> dp[i+1][1] </script>に遷移可能．<br/>
間に合うかどうかは，そのまま次のを取る<script type="math/tex">\to abs (p[i+1] - p[i]) \cdot (j + 1) </script>，家に置きに行って風船を次の風船を取る<script type="math/tex"> \to p[i] \cdot (j+1) + p[i+1] </script>が， <script type="math/tex"> t[i+1] - t[i] </script>より小さければ良い．<br/>
家に帰る，と次の風船を取りに行くを別々に考えていてどういう遷移か分からずめちゃくちゃ時間を溶かした．こういう考え方がすぐに出来るようになりたい．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int dp[50][4];

int main() {
    int n;
    while(cin &gt;&gt; n &amp;&amp; n) {

        vector&lt;int&gt; p(n + 1), t(n + 1);
        rep(i, n) cin &gt;&gt; p[i + 1] &gt;&gt; t[i + 1];

        rep(i, 50) rep(j, 4) dp[i][j] = INF;

        int id = -1;
        dp[0][0] = 0;
        rep(i, n) {
            int d = abs(p[i+1] - p[i]);
            bool flag = true;

            rep(j, 4) {
                if(dp[i][j] == INF) continue;

                if(j &lt; 3 &amp;&amp; d * (j + 1) &lt;= t[i+1] - t[i]) {
                    flag = false;
                    dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j] + d);
                }

                if(p[i] * (j + 1) + p[i+1] &lt;= t[i+1] - t[i]) {
                    flag = false;
                    dp[i+1][1] = min(dp[i+1][1], dp[i][j] + p[i] + p[i+1]);
                }
            }

            if(flag) {
                id = i+1;
                break;
            }
        }

        if(id != -1) cout &lt;&lt; "NG " &lt;&lt; id &lt;&lt; endl;
        else {
            int ans = INF;
            rep(j, 4) {
                ans = min(ans, dp[n][j] + p[n]);
            }
            cout &lt;&lt; "OK " &lt;&lt; ans &lt;&lt; endl;
        }
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1296 Repeated Substitution with Sed]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/23/aoj1296-repeated-substitution-with-sed/"/>
    <updated>2016-03-23T20:48:42+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/23/aoj1296-repeated-substitution-with-sed</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1296">Repeated Substitution with Sed</a></h4><p>Do you know "sed," a tool provided with Unix? Its most popular use is to substitute every occurrence of a string contained in the input string (actually each input line) with another string β. More precisely, it proceeds as follows. Within the input string, every non-overlapping (but possibly adjacent) occurrences of α are marked.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>文字列から <script type="math/tex"> \alpha_i </script>の文字列を探して置換を繰り返す．探すのはstring::find, 置換はstring::replaceを使用して楽をした．幅優先で文字列が <script type="math/tex"> \delta </script>になったら変更回数を答える．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    while(cin &gt;&gt; n &amp;&amp; n) {
        vector&lt;string&gt; v(n), v2(n);
        rep(i, n) cin &gt;&gt; v[i] &gt;&gt; v2[i];

        string s, t;
        cin &gt;&gt; s &gt;&gt; t;

        queue&lt;pair&lt;string, int&gt; &gt; que;
        que.push(mp(s, 0));
        int ans = -1;

        while(que.size()) {
            pair&lt;string, int&gt; p = que.front();
            que.pop();

            if(p.first == t) {
                ans = p.second;
                break;
            }

            rep(i, n) {
                bool flag = false;
                string s2 = p.first;
                string::size_type id = s2.find(v[i]);
                while(id != string::npos) {
                    flag = true;
                    s2.replace(id, v[i].size(), v2[i]);
                    id = s2.find(v[i], id + v2[i].size());
                }

                if(flag &amp;&amp; s2.size() &lt;= t.size()) {
                    que.push(mp(s2, p.second + 1));
                }
            }
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2369 CatChecker]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/23/aoj2369-catchecker/"/>
    <updated>2016-03-23T20:34:54+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/23/aoj2369-catchecker</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2369">CatChecker | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>区間 <script type="math/tex"> [l, r] </script>がねこ鳴き声か探索する．区間の端が <script type="math/tex"> m </script>， <script type="math/tex"> w </script>で真ん中の <script type="math/tex"> e </script>で区切ってみる．メモ化しないとTLEした．逆からやると一意に決まる系かと思ったけどそんなことなかった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

string s;
int memo[505][505];

bool dfs(int l, int r) {
    if(l &gt; r) return true;
    if(memo[l][r] != -1) return memo[l][r];

    if(s[l] == 'm' &amp;&amp; s[r] == 'w') {
        REP(i, l+1, r) {
            if(s[i] == 'e') {
                if(dfs(l+1, i-1) &amp;&amp; dfs(i+1, r-1)) {
                    return memo[l][r] = true;
                }
            }
        }
    }
    return memo[l][r] = false;
}

int main() {
    cin &gt;&gt; s;
    memset(memo, -1, sizeof(memo));

    if(dfs(0, s.size()-1)) {
        cout &lt;&lt; "Cat" &lt;&lt; endl;
    } else {
        cout &lt;&lt; "Rabbit" &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1305 Membership Management]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/23/aoj1305-membership-management/"/>
    <updated>2016-03-23T20:07:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/23/aoj1305-membership-management</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1305">Membership Management</a></h4><p>Peter is a senior manager of Agile Change Management (ACM) Inc., where each employee is a member of one or more task groups. Since ACM is agile, task groups are often reorganized and their members frequently change, so membership management is his constant headache.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>group1のmenberを順番にstackに入れていく．menberがgroupの時は，そのgroupを全てstackに入れる．重複がないように確定したメンバーはsetに突っ込む．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;stack&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

vector&lt;string&gt; split(const string &amp;str, char delim) {
    vector&lt;string&gt; res;
    size_t current = 0, found;
    while((found = str.find_first_of(delim, current)) != string::npos) {
        res.push_back(string(str, current, found - current));
        current = found + 1;
    }
    res.push_back(string(str, current, str.size() - current));
    return res;
}

int main() {
    int n;
    while(cin &gt;&gt; n &amp;&amp; n) {
        vector&lt;string&gt; s(n);
        rep(i, n) cin &gt;&gt; s[i];

        map&lt;string, set&lt;string&gt; &gt; m;
        map&lt;string, int&gt; id;
        vector&lt;string&gt; res[n];
        rep(i, n) {
            vector&lt;string&gt; ret = split(s[i], ':');
            id[ret[0]] = i;
            string t = "";
            rep(j, ret[1].size()) {
                if(ret[1][j] == ',' || ret[1][j] == '.') {
                    m[ret[0]].insert(t);
                    res[i].push_back(t);
                    t = "";
                } else {
                    t += ret[1][j];
                }
            }
        }

        set&lt;string&gt; S;
        stack&lt;string&gt; st;
        bool used[105];
        memset(used, 0, sizeof(used));
        used[0] = true;

        rep(i, res[0].size()) {
            st.push(res[0][i]);

            while(st.size()) {
                string tp = st.top();
                st.pop();

                if(m.count(tp) == 0) {
                    S.insert(tp);
                } else if(!used[id[tp]]){
                    used[ id[tp] ] = true;

                    set&lt;string&gt;::iterator ite;
                    for(ite = m[tp].begin(); ite != m[tp].end(); ite++) {
                        st.push(*ite);
                    }
                }
            }
        }

        cout &lt;&lt; S.size() &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2021 Princess in Danger]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/23/aoj2021-princess-in-danger/"/>
    <updated>2016-03-23T19:48:34+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/23/aoj2021-princess-in-danger</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2021">Princess in Danger | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>状態を <script type="math/tex"> (cost, 残り時間, 番号) </script>としてdijkstra．現在の状態の残り時間のほうが辺のコストより大きい時に，次の町に行くことが可能．冷凍施設にいるときは， 現在の残り時間から<script type="math/tex"> M </script>まで回復出来るので <script type="math/tex"> 1 </script>分ずつ試す．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;
typedef pair&lt;P, int&gt; PI;
typedef pair&lt;P, P &gt; PP;

struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

int n, m, l, k, a, h;
vector&lt;edge&gt; G[105];
int d[105][105];
bool L[105];

void dijkstra(int s) {
    priority_queue&lt;PI, vector&lt;PI&gt;, greater&lt;PI&gt; &gt; que;
    rep(i, 105) {
        rep(j, 105) {
            d[i][j] = INF;
        }
    }

    d[s][m] = 0;
    que.push(PI(P(0, m), s));

    while(que.size()) {
        PI p = que.top();
        que.pop();

        int cost = p.first.first;
        int t = p.first.second;
        int v = p.second;
        if(d[v][t] &lt; cost) continue;

        if(L[v]) {
            REP(i, t+1, m+1) {
                if(d[v][i] &gt; d[v][t] + (i - t)) {
                    d[v][i] = d[v][t] + (i - t);
                    que.push(PI(P(d[v][i], i), v) );
                }
            }
        }

        rep(i, G[v].size()) {
            edge e = G[v][i];
            int nt = t - e.cost;
            if(nt &gt;= 0 &amp;&amp; d[e.to][nt] &gt; d[v][t] + e.cost) {
                d[e.to][nt] = d[v][t] + e.cost;
                que.push(PI(P(d[e.to][nt], nt), e.to));
            }
        }
    }
}


int main() {
    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; l &gt;&gt; k &gt;&gt; a &gt;&gt; h) {
        if(n == 0 &amp;&amp; m == 0 &amp;&amp; l == 0 &amp;&amp; k == 0 &amp;&amp; a == 0 &amp;&amp; h == 0) break;

        rep(i, 105) G[i].clear();
        memset(L, 0, sizeof(L));

        rep(i, l) {
            int x;
            cin &gt;&gt; x;
            L[x] = true;
        }

        rep(i, k) {
            int s, t, c;
            cin &gt;&gt; s &gt;&gt; t &gt;&gt; c;
            G[s].push_back(edge(t, c));
            G[t].push_back(edge(s, c));
        }

        dijkstra(a);

        int ans = INF;
        rep(i, m + 1) {
            ans = min(ans, d[h][i]);
        }

        if(ans == INF) cout &lt;&lt; "Help!" &lt;&lt; endl;
        else cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
