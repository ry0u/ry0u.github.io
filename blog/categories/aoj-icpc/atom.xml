<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: aoj-icpc | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/aoj-icpc/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-04-18T23:46:17+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ1174 Identically Colored Panels Connection]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/18/aoj1174-identically-colored-panels-connection/"/>
    <updated>2016-04-18T23:00:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/18/aoj1174-identically-colored-panels-connection</id>
    <content type="html"><![CDATA[<p><a class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article" href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1174">Identically Colored Panels Connection</a></p>

<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>塗る色を決めて順番に塗っていく． それぞれ</p>

<ul>
<li><script type="math/tex"> rec </script> : 始点から探索して<script type="math/tex"> c </script>と同じパネルが何色あるか</li>
<li><script type="math/tex"> dfs </script> : 始点から探索して<script type="math/tex"> target </script>の色を <script type="math/tex"> change </script>にする．</li>
<li><script type="math/tex"> func </script> : <script type="math/tex"> i </script>回塗った状態． 最終的に<script type="math/tex"> 5 </script>回塗った回数を答えるが，最後に <script type="math/tex"> c </script>に塗り替えた場合なので，<script type="math/tex"> 4 </script>回塗った後に <script type="math/tex"> c </script>に塗って <script type="math/tex"> rec </script>を呼ぶ．</li>
</ul>


<blockquote><p>ただし，電極は左上角のパネルに固定されていることとする．</p></blockquote>

<p>の文を見逃していて，塗り始める場所を全探索していてSampleがずっと合わなかった&hellip;<br/>
全体的に辛い</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int h, w, c;
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1};

bool can(int y,int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}

int cnt = 0, sy = 0, sx = 0;
bool used[10][10];
vector&lt; vector&lt;int&gt; &gt; v;

void rec(int y, int x) {
    used[y][x] = true;
    cnt++;

    rep(i, 4) {
        int ny = y + dy[i];
        int nx = x + dx[i];

        if(can(ny, nx) &amp;&amp; !used[ny][nx] &amp;&amp; v[ny][nx] == c) {
            rec(ny, nx);
        }
    }
}

int target, change;

void dfs(int y, int x) {
    v[y][x] = change;
    rep(i, 4) {
        int ny = y + dy[i];
        int nx = x + dx[i];

        if(can(ny, nx) &amp;&amp; v[ny][nx] == target) {
            dfs(ny, nx);
        }
    }
}

int ans = 0;
void func(vector&lt; vector&lt;int&gt; &gt; t, int id) {
    // cout &lt;&lt; " ------ func ---- :" &lt;&lt; id &lt;&lt; endl;
    // rep(i, h) {
    //  rep(j, w) cout &lt;&lt; t[i][j] &lt;&lt; " ";
    //  cout &lt;&lt; endl;
    // }
    if(id == 4) {
        v = t;
        target = t[sy][sx];

        if(target == c) return;
        change = c;
        dfs(sy, sx);

        cnt = 0;
        memset(used, 0, sizeof(used));
        rec(sy, sx);
        ans = max(ans, cnt);
        return;
    }

    REP(i, 1, 7) {
        if(i == t[sy][sx]) continue;
        v = t;
        target = t[sy][sx]; change = i;
        dfs(sy, sx);
        func(v, id + 1);
    }
}

int main() {
    while(cin &gt;&gt; h &gt;&gt; w &gt;&gt; c) {
        if(h == 0 &amp;&amp; w == 0 &amp;&amp; c == 0) break;

        v.resize(h);
        rep(i, h) {
            v[i].resize(w);
            rep(j, w) cin &gt;&gt; v[i][j];
        }

        ans = 0;
        func(v, 0);

        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1251 Pathological Paths]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/26/aoj1251-pathological-paths/"/>
    <updated>2016-03-26T22:12:52+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/26/aoj1251-pathological-paths</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1251">Pathological Paths</a></h4><p>Professor Pathfinder is a distinguished authority on the structure of hyperlinks in the World Wide Web. For establishing his hypotheses, he has been developing software agents, which automatically traverse hyperlinks and analyze the structure of the Web. Today, he has gotten an intriguing idea to improve his software agents.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>木構造でディレクトリ構造を表す．探すパスが両方葉の場合，ノードの番号が一致するかを見る．葉ではなくディレクトリの場合は，自分の子に文字列が"index.html"であり葉であるノードがあるかを見る．ない場合は"not found"で，ある場合はそのノード番号を比較する．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int cnt = 0;

struct Tree {
    string s;
    int id;
    Tree* par;
    vector&lt;Tree*&gt; v;

    Tree(Tree* par, string s, int id) : par(par), s(s), id(id) {}

    void add(int i, vector&lt;string&gt; res) {
        if(i == res.size()) return;

        bool flag = true;
        rep(j, v.size()) {
            if(v[j]-&gt;s == res[i]) flag = false;
        }

        if(flag) {
            cnt++;
            Tree *node = new Tree(this, res[i], cnt);
            v.push_back(node);
        }

        rep(j, v.size()) {
            if(v[j]-&gt;s == res[i]) {
                v[j]-&gt;add(i+1, res);
            }
        }
    }

    Tree* find(int i, vector&lt;string&gt; res) {
        // cout &lt;&lt; " -- in find :" &lt;&lt; s &lt;&lt; endl;
        if(i == res.size()) {
            return this;
        }

        if(res[i] == ".") {
            if(v.size() == 0) return NULL;
            return find(i+1, res);
        } else if(res[i] == "..") {
            if(v.size() == 0) return NULL;
            if(par == NULL) return NULL;
            return par-&gt;find(i+1, res);
        } else if(res[i] == "") {
            if(v.size() == 0) return NULL;
            return find(i+1, res);
        } else {
            rep(j, v.size()) {
                if(v[j]-&gt;s == res[i]) {
                    return v[j]-&gt;find(i+1, res);
                }
            }
            return NULL;
        }
    }

};

vector&lt;string&gt; split(const string &amp;str, char delim) {
    vector&lt;string&gt; res;
    size_t current = 0, found;
    while((found = str.find_first_of(delim, current)) != string::npos) {
        res.push_back(string(str, current, found - current));
        current = found + 1;
    }
    res.push_back(string(str, current, str.size() - current));
    return res;
}

int main() {
    int n, m;
    while(cin &gt;&gt; n &gt;&gt; m) {
        if(n == 0 &amp;&amp; m == 0) break;

        cnt = 0;
        Tree *root = new Tree(NULL, "root", cnt);

        rep(i, n) {
            string s;
            cin &gt;&gt; s;

            vector&lt;string&gt; ret = split(s, '/');

            root-&gt;add(0, vector&lt;string&gt;(ret.begin()+1, ret.end()));
        }

        rep(q, m) {
            string s, t;
            cin &gt;&gt; s &gt;&gt; t;

            vector&lt;string&gt; r = split(s, '/');
            vector&lt;string&gt; r2 = split(t, '/');

            Tree *node = root-&gt;find(0, r);
            Tree *node2 = root-&gt;find(0, r2);

            // if(node == NULL) cout &lt;&lt; " node 1 : null" &lt;&lt; endl;
            // if(node2 == NULL) cout &lt;&lt; " node 2 : null" &lt;&lt; endl;

            if(node == NULL || node2 == NULL) {
                cout &lt;&lt; "not found" &lt;&lt; endl;
            } else {

                Tree *res = NULL;
                if(node-&gt;v.size() == 0) {
                    res = node;
                } else {
                    rep(i, node-&gt;v.size()) {
                        if(node-&gt;v[i]-&gt;v.size() == 0 &amp;&amp; node-&gt;v[i]-&gt;s == "index.html") {
                            res = node-&gt;v[i];
                        }
                    }
                }

                Tree *res2 = NULL;
                if(node2-&gt;v.size() == 0) {
                    res2 = node2;
                } else {
                    rep(i, node2-&gt;v.size()) {
                        if(node2-&gt;v[i]-&gt;v.size() == 0 &amp;&amp; node2-&gt;v[i]-&gt;s == "index.html") {
                            res2 = node2-&gt;v[i];
                        }
                    }
                }

                // if(res == NULL) cout &lt;&lt; "NULL";
                // else cout &lt;&lt; res-&gt;s &lt;&lt; ", " &lt;&lt; res-&gt;id;
                //
                // cout &lt;&lt; " ";
                //
                // if(res2 == NULL) cout &lt;&lt; "NULL";
                // else cout &lt;&lt; res2-&gt;s &lt;&lt; ", " &lt;&lt; res2-&gt;id;
                //
                // cout &lt;&lt; endl;

                if(res == NULL || res2 == NULL) {
                    cout &lt;&lt; "not found" &lt;&lt; endl;
                } else if(res-&gt;id == res2-&gt;id &amp;&amp; res-&gt;s == res2-&gt;s) {
                    cout &lt;&lt; "yes" &lt;&lt; endl;
                } else {
                    cout &lt;&lt; "no" &lt;&lt; endl;
                }
            }
        }
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1347 Shopping]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/26/aoj1347-shopping/"/>
    <updated>2016-03-26T21:44:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/26/aoj1347-shopping</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1347">Shopping | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>まず最初に，全ての場所に行って帰ってを行うグラフを考える．</p>

<p><img src="/images/AOJ/1347-1.png"></p>

<p>ここから実際に戻らなければいけない区間を出して</p>

<p><img src="/images/AOJ/1347-2.png"></p>

<p>その区間でない場所は <script type="math/tex"> 1 </script>本あればいいので <script type="math/tex"> -2 </script>する．</p>

<p><img src="/images/AOJ/1347-3.png"></p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;int&gt; c(m), d(m);
    rep(i, m) cin &gt;&gt; c[i] &gt;&gt; d[i];

    int cnt[1005];
    memset(cnt, 0, sizeof(cnt));

    rep(i, m) {
        REP(j, c[i], d[i]) {
            cnt[j]++;
        }
    }

    int ans = 3 * (n + 1);
    rep(i, n + 1) {
        if(cnt[i] == 0) {
            ans -= 2;
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1326 Stylish]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/26/aoj1326-stylish/"/>
    <updated>2016-03-26T21:21:31+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/26/aoj1326-stylish</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1326">Stylish</a></h4><p>Stylish is a programming language whose syntax comprises names, that are sequences of Latin alphabet letters, three types of grouping symbols, periods ('.'), and newlines. Grouping symbols, namely round brackets ('(' and ')'), curly brackets ('{' and '}'), and square brackets ('[' and ']'), must match and be nested properly.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>i番目までの括弧の量を先に計算しておく．<script type="math/tex"> R </script>, <script type="math/tex"> C </script>, <script type="math/tex"> S </script>を総当りしてインデントが合う組み合わせを見つける． <script type="math/tex"> 2 </script>つ以上ある場合は <script type="math/tex"> -1 </script>にする．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n, m;
    while(cin &gt;&gt; n &gt;&gt; m) {
        if(n == 0 &amp;&amp; m == 0) break;

        vector&lt;string&gt; v(n), v2(m);
        rep(i, n) cin &gt;&gt; v[i];
        rep(i, m) cin &gt;&gt; v2[i];

        int r[105], c[105], s[105];
        memset(r, 0, sizeof(r));
        memset(c, 0, sizeof(c));
        memset(s, 0, sizeof(s));

        REP(i, 1, n) {
            r[i] = r[i-1];
            c[i] = c[i-1];
            s[i] = s[i-1];
            rep(j, v[i-1].size()) {
                char ch = v[i-1][j];
                if(ch == '(') r[i]++;
                if(ch == ')') r[i]--;
                if(ch == '{') c[i]++;
                if(ch == '}') c[i]--;
                if(ch == '[') s[i]++;
                if(ch == ']') s[i]--;
            }
        }

        int r2[105], c2[105], s2[105];
        memset(r2, 0, sizeof(r2));
        memset(c2, 0, sizeof(c2));
        memset(s2, 0, sizeof(s2));

        REP(i, 1, m) {
            r2[i] = r2[i-1];
            c2[i] = c2[i-1];
            s2[i] = s2[i-1];
            rep(j, v2[i-1].size()) {
                char ch = v2[i-1][j];
                if(ch == '(') r2[i]++;
                if(ch == ')') r2[i]--;
                if(ch == '{') c2[i]++;
                if(ch == '}') c2[i]--;
                if(ch == '[') s2[i]++;
                if(ch == ']') s2[i]--;
            }
        }

        int d[105];
        memset(d, 0, sizeof(d));

        rep(i, n) {
            rep(j, v[i].size()) {
                if(v[i][j] != '.') {
                    d[i] = j;
                    break;
                }
            }
        }

        vector&lt;int&gt; ans(m);
        rep(i, m) ans[i] = INF;

        REP(i, 1, 21) {
            REP(j, 1, 21) {
                REP(k, 1, 21) {
                    bool flag = true;

                    rep(l, n) {
                        if(d[l] == i * r[l] + j * c[l] + k * s[l]) continue;
                        flag = false;
                    }

                    if(flag) {
                        rep(l, m) {
                            int d = i * r2[l] + j * c2[l] + k * s2[l];

                            if(ans[l] == INF) ans[l] = d;
                            else if(ans[l] != d) ans[l] = -1;
                        }
                    }
                }
            }
        }

        rep(i, m) {
            cout &lt;&lt; ans[i];
            if(i == m-1) cout &lt;&lt; endl;
            else cout &lt;&lt; " ";
        }
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2166 Erratic Sleep Habits]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/24/aoj2166-erratic-sleep-habits/"/>
    <updated>2016-03-24T02:13:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/24/aoj2166-erratic-sleep-habits</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2166">Erratic Sleep Habits</a></h4><p>Peter is a person with erratic sleep habits. He goes to sleep at twelve o'lock every midnight. He gets up just after one hour of sleep on some days; he may even sleep for twenty-three hours on other days. His sleeping duration changes in a cycle, where he always sleeps for only one hour on the first day of the cycle.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>睡眠周期 <script type="math/tex"> T_i </script>が与えられる．カフェインを取ることでこの睡眠周期を最初に戻すことが出来るとき，全ての予定をこなせるカフェインの量の最大値を求める．<br/>
<script type="math/tex; mode=display">
    dp[i][j] := i日目に睡眠周期jの時のカフェインの最小値
</script>
とした． <script type="math/tex"> j = 0 </script>の場合は <script type="math/tex"> i-1 </script>のどこからでも <script type="math/tex"> +1 </script>(カフェインを取ること)で遷移できて，他の場合は <script type="math/tex"> T_j </script>が <script type="math/tex"> i </script>日目の一番最初の予定より早ければ， <script type="math/tex"> dp[i-1][j-1] </script>より遷移できる．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int t;
    while(cin &gt;&gt; t &amp;&amp; t) {

        vector&lt;int&gt; v(t);
        rep(i, t) cin &gt;&gt; v[i];

        int n;
        cin &gt;&gt; n;

        vector&lt;int&gt; d(n), m(n);
        int dm[105], day = 0;
        rep(i, 105) dm[i] = INF;

        rep(i, n) {
            cin &gt;&gt; d[i] &gt;&gt; m[i];
            dm[d[i]-1] = min(dm[d[i]-1], m[i]);
            day = max(day, d[i]);
        }

        int dp[105][35];
        rep(i, 105) rep(j, 35) dp[i][j] = INF;

        dp[0][0] = 0;

        REP(i, 1, day) {
            rep(j, t) {
                if(j == 0) {
                    rep(k, t) {
                        dp[i][j] = min(dp[i][j], dp[i-1][k] + 1);
                    }
                    dp[i][j] = min(dp[i][j], dp[i-1][t-1]);
                } else {
                    if(v[j] &lt;= dm[i]) {
                        dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
                    }
                }
            }
        }

        int ans = INF;
        rep(i, t) {
            ans = min(ans, dp[day-1][i]);
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
