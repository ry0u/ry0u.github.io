<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: aoj-icpc | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/aoj-icpc/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-20T22:39:58+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ1316 The Sorcerer's Donut]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/20/aoj1316-the-sorcerers-donut/"/>
    <updated>2016-03-20T22:29:14+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/20/aoj1316-the-sorcerers-donut</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1316">The Sorcerer's Donut</a></h4><p>Your master went to the town for a day. You could have a relaxed day without hearing his scolding. But he ordered you to make donuts dough by the evening. Loving donuts so much, he can't live without eating tens of donuts everyday. What a chore for such a beautiful day.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>盤面が小さいので，ある方向に一周した文字列を列挙して <script type="math/tex"> 2 </script>回以上出て辞書順最小のものを出力した．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int w,h,x,y;
int sx,sy,gx,gy;
int dx[9] = { 1, 1, 1, 0, 0, 0,-1,-1,-1};
int dy[9] = {-1, 0, 1,-1, 0, 1,-1, 0, 1};

bool can(int y,int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}

int main() {
    while(cin &gt;&gt; h &gt;&gt; w) {
        if(h == 0 &amp;&amp; w == 0) break;

        vector&lt;string&gt; s(h);
        rep(i, h) cin &gt;&gt; s[i];

        map&lt;string, int&gt; m;
        bool used[15][25];

        rep(i, h) {
            rep(j, w) {
                rep(k, 9) {
                    int y = i, x = j;
                    memset(used, 0, sizeof(used));
                    string t = "";
                    while(!used[y][x]) {
                        used[y][x] = true;
                        t += s[y][x];

                        y = (y + h + dy[k]) % h;
                        x = (x + w + dx[k]) % w;

                        if(t.size() &gt; 1) m[t]++;
                    }
                }
            }
        }

        string ans = "";
        map&lt;string, int&gt;::iterator ite;
        for(ite = m.begin(); ite != m.end(); ite++) {
            if(ite-&gt;second &lt; 2) continue;
            if(ite-&gt;first.size() &gt; ans.size()) {
                ans = ite-&gt;first;
            } else if(ite-&gt;first.size() == ans.size()) {
                bool flag = true;
                rep(i, ans.size()) {
                    if(ite-&gt;first[i] &lt;= ans[i]) continue;
                    flag = false;
                }

                if(flag) ans = ite-&gt;first;
            }
        }

        if(ans.size() == 0) cout &lt;&lt; 0 &lt;&lt; endl;
        else cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1286 Expected Allowance]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj1286-expected-allowance/"/>
    <updated>2016-03-18T22:54:03+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj1286-expected-allowance</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1286">Expected Allowance | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p><script type="math/tex; mode=display">
    dp[i][j] := i回，m面のサイコロを降った時にjが出る回数
</script></p>

<p>として，シュミレーション．サイコロを振るのは <script type="math/tex"> dp[i+1][j+k] += dp[i][j] </script>と書ける．配列を再利用するために，<script type="math/tex"> iとi+1 </script>の偶奇を見て遷移する．次に遷移する場所に値が残っているとおかしいことになるので，<script type="math/tex"> dp[i][j] </script>からサイコロを振ったらそこは初期化する．分母は全て <script type="math/tex"> m ^n </script>で， <script type="math/tex"> k </script>引いた時に最低でも <script type="math/tex"> 1 </script>になるようにして期待値を求める．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int dp[2][100005];

int main() {
    int n, m, k;
    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; k) {
        if(n == 0 &amp;&amp; m == 0 &amp;&amp; k == 0) break;

        memset(dp, 0, sizeof(dp));
        REP(j, 1, m + 1) {
            dp[1][j] = 1;
        }

        rep(i, n) {
            rep(j, 100005) {
                if(dp[i &amp; 1][j] == 0) continue;
                REP(k, 1, m+1) {
                    dp[(i+1)&amp;1][j+k] += dp[i&amp;1][j];
                }
                dp[i&amp;1][j] = 0;
            }
        }

        double ans = 0, t = 1;
        rep(i, n) {
            t *= m;
        }

        rep(j, 100005) {
            if(dp[n&amp;1][j] == 0) continue;

            double l = j - k;
            if(l &lt;= 0) l = 1;
            ans += (dp[n &amp; 1][j] / t) * l;
        }

        cout &lt;&lt; fixed;
        cout.precision(20);
        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1277 Minimal Backgammon]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj1277-minimal-backgammon/"/>
    <updated>2016-03-18T22:14:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj1277-minimal-backgammon</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1277">Minimal Backgammon</a></h4><p>Here is a very simple variation of the game backgammon, named "Minimal Backgammon". The game is played by only one player, using only one of the dice and only one checker (the token used by the player). The game board is a line of ( N + 1) squares labeled as 0 (the start) to N (the goal).</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>動的計画法．
<script type="math/tex; mode=display">
    dp[i][j] := iターン目にマスjにいる確率
</script></p>

<p>とする．<script type="math/tex"> i </script>ターン目にマス<script type="math/tex"> j </script>にいる時にサイコロを振るのは
<script type="math/tex; mode=display">
    dp[i+1][j+k] = dp[i][j] \cdot (1.0 / 6.0);
</script>
と書ける．一回休みの時は<script type="math/tex"> dp[i+2][j+k] </script>，戻るマスは <script type="math/tex"> dp[i+1][0] </script>に遷移する．<script type="math/tex"> n </script>マスを追い越した時に戻ってくる処理でバグバグした．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

double dp[105][105];

int main() {
    int n, t, l, b;
    while(cin &gt;&gt; n &gt;&gt; t &gt;&gt; l &gt;&gt; b) {
        if(n == 0 &amp;&amp; t == 0 &amp;&amp; l == 0 &amp;&amp; b == 0) break;

        memset(dp, 0, sizeof(dp));

        bool lose[105], back[1005];
        memset(lose, 0, sizeof(lose));
        memset(back, 0, sizeof(back));

        rep(i, l) {
            int x;
            cin &gt;&gt; x;
            lose[x] = true;
        }

        rep(i, b) {
            int x;
            cin &gt;&gt; x;
            back[x] = true;
        }

        memset(dp, 0, sizeof(dp));

        dp[0][0] = 1.0;
        rep(i, t) {
            rep(j, n) {
                if(dp[i][j] == 0.0) continue;
                REP(k, 1, 7) {
                    int p = j + k;
                    if(p &gt; n) p = n - (p - n);

                    if(lose[p]) {
                        dp[i+2][p] += dp[i][j] * (1.0 / 6.0);
                    } else if(back[p]) {
                        dp[i+1][0] += dp[i][j] * (1.0 / 6.0);
                    } else {
                        dp[i+1][p] += dp[i][j] * (1.0 / 6.0);
                    }
                }
            }
        }

        double ans = 0;
        rep(i, t + 1) {
            ans += dp[i][n];
        }

        cout &lt;&lt; fixed;
        cout.precision(20);
        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
