<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: aoj-icpc | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/aoj-icpc/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-05-20T23:10:21+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How can I satisfy thee? Let me count the ways...]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/20/how-can-i-satisfy-thee-let-me-count-the-ways-dot-dot-dot/"/>
    <updated>2016-05-20T22:38:10+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/20/how-can-i-satisfy-thee-let-me-count-the-ways-dot-dot-dot</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-image="http://judge.u-aizu.ac.jp/onlinejudge/IMAGE1/2008C2.png" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1155&lang=jp">How can I satisfy thee? Let me count the ways... | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>構文解析．
<script type="math/tex; mode=display">
\begin{eqnarray}
<formula>\ &amp;::=&amp;\ 0\ or\ 1\ or\ 2 \
<formula>\ &amp;::=&amp;\ -<formula> \
<formula>\ &amp;::=&amp;\ (<formula>\ +\ or\ * <formula>) \
\end{eqnarray}
</script>
の場合に分けて考える．入れ子の括弧にどう対応させるかよく分からなかったが，自分なりに理解することができた．構文解析の関数が出来たら，<script type="math/tex"> (P, Q, R) </script>の組み合わせ(<script type="math/tex"> 2 ^3 </script>通り)を全列挙して， <script type="math/tex"> 2 </script>となる個数を数える．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int formula(string&amp; s, int&amp; i) {
    if(s[i] == '(') {
        i++;
        int val = formula(s, i);

        char op = s[i];

        i++;
        int val2 = formula(s, i);

        int ret = 0;
        if(op == '+') {
            if(val == 2 || val2 == 2) ret = 2;
            else if(val == 1 || val2 == 1) ret = 1;
            else ret = 0;
        }
        if(op == '*') {
            if(val == 2 &amp;&amp; val2 == 2) ret = 2;
            else if((val == 1 || val == 2) &amp;&amp; (val2 == 1 || val2 == 2)) ret = 1;
            else ret = 0;
        }

        i++;
        return ret;
    } else if(isdigit(s[i])) {
        int ret = (s[i] - '0');
        i++;
        return ret;
    } else if(s[i] == '-') {
        i++;
        int val = formula(s, i);

        int ret = 0;
        if(val == 0) ret = 2;
        if(val == 1) ret = 1;
        if(val == 2) ret = 0;

        return ret;
    }
}


int main() {
    string s;
    while(cin &gt;&gt; s) {
        if(s == ".") break;

        int ans = 0;
        rep(i, 3) {
            rep(j, 3) {
                rep(k, 3) {
                    string t = s;
                    rep(l, s.size()) {
                        if(t[l] == 'P') t[l] = ('0' + i);
                        else if(t[l] == 'Q') t[l] = ('0' + j);
                        else if(t[l] == 'R') t[l] = ('0' + k);
                    }

                    int p = 0;
                    if(formula(t, p) == 2) {
                        ans++;
                    }
                }
            }
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2331 A Way to Invite Friends]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/14/aoj2331-a-way-to-invite-friends/"/>
    <updated>2016-05-14T23:45:52+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/14/aoj2331-a-way-to-invite-friends</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2331">A Way to Invite Friends | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>各友だちの，嫌がらない海に行く人数の範囲( <script type="math/tex"> a_i 〜 b_i </script>)が与えられる．海に誘える最大人数を求める．<br/>
海に行く人数には「わたし」も含まれるので <script type="math/tex"> i </script>人誘えるかは， <script type="math/tex"> i+1 </script>人で海に行くことを嫌がらない友だちの数が <script type="math/tex"> i </script>人以上いるか，となるのでいもす法で累積和を取って順番に見ていった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n;
    cin &gt;&gt; n;

    int imos[100005];
    memset(imos, 0, sizeof(imos));

    rep(i, n) {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;

        imos[a]++;
        imos[b+1]--;
    }

    REP(i, 1, 100005) {
        imos[i] += imos[i-1];
    }

    int ans = 0;
    rep(i, 100005) {
        if(imos[i+1] &gt;= i) {
            ans = i;
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1174 Identically Colored Panels Connection]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/18/aoj1174-identically-colored-panels-connection/"/>
    <updated>2016-04-18T23:00:29+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/18/aoj1174-identically-colored-panels-connection</id>
    <content type="html"><![CDATA[<p><a class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article" href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1174">Identically Colored Panels Connection</a></p>

<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>塗る色を決めて順番に塗っていく． それぞれ</p>

<ul>
<li><script type="math/tex"> rec </script> : 始点から探索して<script type="math/tex"> c </script>と同じパネルが何色あるか</li>
<li><script type="math/tex"> dfs </script> : 始点から探索して<script type="math/tex"> target </script>の色を <script type="math/tex"> change </script>にする．</li>
<li><script type="math/tex"> func </script> : <script type="math/tex"> i </script>回塗った状態． 最終的に<script type="math/tex"> 5 </script>回塗った回数を答えるが，最後に <script type="math/tex"> c </script>に塗り替えた場合なので，<script type="math/tex"> 4 </script>回塗った後に <script type="math/tex"> c </script>に塗って <script type="math/tex"> rec </script>を呼ぶ．</li>
</ul>


<blockquote><p>ただし，電極は左上角のパネルに固定されていることとする．</p></blockquote>

<p>の文を見逃していて，塗り始める場所を全探索していてSampleがずっと合わなかった&hellip;<br/>
全体的に辛い</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int h, w, c;
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1};

bool can(int y,int x) {
    if(0 &lt;= y &amp;&amp; y &lt; h &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; w) return true;
    return false;
}

int cnt = 0, sy = 0, sx = 0;
bool used[10][10];
vector&lt; vector&lt;int&gt; &gt; v;

void rec(int y, int x) {
    used[y][x] = true;
    cnt++;

    rep(i, 4) {
        int ny = y + dy[i];
        int nx = x + dx[i];

        if(can(ny, nx) &amp;&amp; !used[ny][nx] &amp;&amp; v[ny][nx] == c) {
            rec(ny, nx);
        }
    }
}

int target, change;

void dfs(int y, int x) {
    v[y][x] = change;
    rep(i, 4) {
        int ny = y + dy[i];
        int nx = x + dx[i];

        if(can(ny, nx) &amp;&amp; v[ny][nx] == target) {
            dfs(ny, nx);
        }
    }
}

int ans = 0;
void func(vector&lt; vector&lt;int&gt; &gt; t, int id) {
    // cout &lt;&lt; " ------ func ---- :" &lt;&lt; id &lt;&lt; endl;
    // rep(i, h) {
    //  rep(j, w) cout &lt;&lt; t[i][j] &lt;&lt; " ";
    //  cout &lt;&lt; endl;
    // }
    if(id == 4) {
        v = t;
        target = t[sy][sx];

        if(target == c) return;
        change = c;
        dfs(sy, sx);

        cnt = 0;
        memset(used, 0, sizeof(used));
        rec(sy, sx);
        ans = max(ans, cnt);
        return;
    }

    REP(i, 1, 7) {
        if(i == t[sy][sx]) continue;
        v = t;
        target = t[sy][sx]; change = i;
        dfs(sy, sx);
        func(v, id + 1);
    }
}

int main() {
    while(cin &gt;&gt; h &gt;&gt; w &gt;&gt; c) {
        if(h == 0 &amp;&amp; w == 0 &amp;&amp; c == 0) break;

        v.resize(h);
        rep(i, h) {
            v[i].resize(w);
            rep(j, w) cin &gt;&gt; v[i][j];
        }

        ans = 0;
        func(v, 0);

        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1251 Pathological Paths]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/26/aoj1251-pathological-paths/"/>
    <updated>2016-03-26T22:12:52+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/26/aoj1251-pathological-paths</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1251">Pathological Paths</a></h4><p>Professor Pathfinder is a distinguished authority on the structure of hyperlinks in the World Wide Web. For establishing his hypotheses, he has been developing software agents, which automatically traverse hyperlinks and analyze the structure of the Web. Today, he has gotten an intriguing idea to improve his software agents.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>木構造でディレクトリ構造を表す．探すパスが両方葉の場合，ノードの番号が一致するかを見る．葉ではなくディレクトリの場合は，自分の子に文字列が"index.html"であり葉であるノードがあるかを見る．ない場合は"not found"で，ある場合はそのノード番号を比較する．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int cnt = 0;

struct Tree {
    string s;
    int id;
    Tree* par;
    vector&lt;Tree*&gt; v;

    Tree(Tree* par, string s, int id) : par(par), s(s), id(id) {}

    void add(int i, vector&lt;string&gt; res) {
        if(i == res.size()) return;

        bool flag = true;
        rep(j, v.size()) {
            if(v[j]-&gt;s == res[i]) flag = false;
        }

        if(flag) {
            cnt++;
            Tree *node = new Tree(this, res[i], cnt);
            v.push_back(node);
        }

        rep(j, v.size()) {
            if(v[j]-&gt;s == res[i]) {
                v[j]-&gt;add(i+1, res);
            }
        }
    }

    Tree* find(int i, vector&lt;string&gt; res) {
        // cout &lt;&lt; " -- in find :" &lt;&lt; s &lt;&lt; endl;
        if(i == res.size()) {
            return this;
        }

        if(res[i] == ".") {
            if(v.size() == 0) return NULL;
            return find(i+1, res);
        } else if(res[i] == "..") {
            if(v.size() == 0) return NULL;
            if(par == NULL) return NULL;
            return par-&gt;find(i+1, res);
        } else if(res[i] == "") {
            if(v.size() == 0) return NULL;
            return find(i+1, res);
        } else {
            rep(j, v.size()) {
                if(v[j]-&gt;s == res[i]) {
                    return v[j]-&gt;find(i+1, res);
                }
            }
            return NULL;
        }
    }

};

vector&lt;string&gt; split(const string &amp;str, char delim) {
    vector&lt;string&gt; res;
    size_t current = 0, found;
    while((found = str.find_first_of(delim, current)) != string::npos) {
        res.push_back(string(str, current, found - current));
        current = found + 1;
    }
    res.push_back(string(str, current, str.size() - current));
    return res;
}

int main() {
    int n, m;
    while(cin &gt;&gt; n &gt;&gt; m) {
        if(n == 0 &amp;&amp; m == 0) break;

        cnt = 0;
        Tree *root = new Tree(NULL, "root", cnt);

        rep(i, n) {
            string s;
            cin &gt;&gt; s;

            vector&lt;string&gt; ret = split(s, '/');

            root-&gt;add(0, vector&lt;string&gt;(ret.begin()+1, ret.end()));
        }

        rep(q, m) {
            string s, t;
            cin &gt;&gt; s &gt;&gt; t;

            vector&lt;string&gt; r = split(s, '/');
            vector&lt;string&gt; r2 = split(t, '/');

            Tree *node = root-&gt;find(0, r);
            Tree *node2 = root-&gt;find(0, r2);

            // if(node == NULL) cout &lt;&lt; " node 1 : null" &lt;&lt; endl;
            // if(node2 == NULL) cout &lt;&lt; " node 2 : null" &lt;&lt; endl;

            if(node == NULL || node2 == NULL) {
                cout &lt;&lt; "not found" &lt;&lt; endl;
            } else {

                Tree *res = NULL;
                if(node-&gt;v.size() == 0) {
                    res = node;
                } else {
                    rep(i, node-&gt;v.size()) {
                        if(node-&gt;v[i]-&gt;v.size() == 0 &amp;&amp; node-&gt;v[i]-&gt;s == "index.html") {
                            res = node-&gt;v[i];
                        }
                    }
                }

                Tree *res2 = NULL;
                if(node2-&gt;v.size() == 0) {
                    res2 = node2;
                } else {
                    rep(i, node2-&gt;v.size()) {
                        if(node2-&gt;v[i]-&gt;v.size() == 0 &amp;&amp; node2-&gt;v[i]-&gt;s == "index.html") {
                            res2 = node2-&gt;v[i];
                        }
                    }
                }

                // if(res == NULL) cout &lt;&lt; "NULL";
                // else cout &lt;&lt; res-&gt;s &lt;&lt; ", " &lt;&lt; res-&gt;id;
                //
                // cout &lt;&lt; " ";
                //
                // if(res2 == NULL) cout &lt;&lt; "NULL";
                // else cout &lt;&lt; res2-&gt;s &lt;&lt; ", " &lt;&lt; res2-&gt;id;
                //
                // cout &lt;&lt; endl;

                if(res == NULL || res2 == NULL) {
                    cout &lt;&lt; "not found" &lt;&lt; endl;
                } else if(res-&gt;id == res2-&gt;id &amp;&amp; res-&gt;s == res2-&gt;s) {
                    cout &lt;&lt; "yes" &lt;&lt; endl;
                } else {
                    cout &lt;&lt; "no" &lt;&lt; endl;
                }
            }
        }
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1347 Shopping]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/26/aoj1347-shopping/"/>
    <updated>2016-03-26T21:44:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/26/aoj1347-shopping</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1347">Shopping | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>まず最初に，全ての場所に行って帰ってを行うグラフを考える．</p>

<p><img src="/images/AOJ/1347-1.png"></p>

<p>ここから実際に戻らなければいけない区間を出して</p>

<p><img src="/images/AOJ/1347-2.png"></p>

<p>その区間でない場所は <script type="math/tex"> 1 </script>本あればいいので <script type="math/tex"> -2 </script>する．</p>

<p><img src="/images/AOJ/1347-3.png"></p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    vector&lt;int&gt; c(m), d(m);
    rep(i, m) cin &gt;&gt; c[i] &gt;&gt; d[i];

    int cnt[1005];
    memset(cnt, 0, sizeof(cnt));

    rep(i, m) {
        REP(j, c[i], d[i]) {
            cnt[j]++;
        }
    }

    int ans = 3 * (n + 1);
    rep(i, n + 1) {
        if(cnt[i] == 0) {
            ans -= 2;
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
