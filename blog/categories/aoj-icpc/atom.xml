<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: aoj-icpc | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/aoj-icpc/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-09-03T02:19:57+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ2151 Brave Princess Revisited]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/09/aoj2151-brave-princess-revisited/"/>
    <updated>2016-06-09T13:59:08+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/09/aoj2151-brave-princess-revisited</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151">Brave Princess Revisited | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

状態を(襲われる盗賊や刺客の人数, お金, 頂点番号)としてdijkstra．現在の状態から次の状態への遷移は，護衛を雇わないで盗賊に襲われる，護衛を雇い守ってもらう，の$2$つである．お金が辺の長さより少ない場合は護衛を雇えないことに注意する．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;
typedef pair<P, int> PI;

struct edge {
	int from,to;
	int cost, res;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int t,int c,int r) : to(t), cost(c), res(r) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

vector<edge> G[105];
int d[105][105];

void dijkstra(int s, int l) {
	rep(i, 105) rep(j, 105) d[i][j] = INF;
	d[s][l] = 0;

	priority_queue<PI, vector<PI>, greater<PI> > que;
	que.push(mp(mp(0, -l), s));

	while(que.size()) {
		PI p = que.top(); que.pop();
		int cost = p.first.first;
		int coin = p.first.second;
		int v = p.second;
		coin *= -1;

		if(d[v][coin] < cost) continue;
		
		rep(i, G[v].size()) {
			edge e = G[v][i];

			if(d[e.to][coin] > d[v][coin] + e.res) {
				d[e.to][coin] = d[v][coin] + e.res;
				que.push(mp(mp(d[e.to][coin], -coin), e.to));
			}

			int nc = coin - e.cost;
			if(nc >= 0 && d[e.to][nc] > d[v][coin]) {
				d[e.to][nc] = d[v][coin];
				que.push(mp(mp(d[e.to][nc], -nc), e.to));
			}
		}

	}
}

int main() {
	int n, m, l;
	while(cin >> n >> m >> l)  {
		if(n == 0 && m == 0 && l == 0) break;

		rep(i, 105) G[i].clear();

		rep(i, m) {
			int a, b, c, d;
			cin >> a >> b >> c >> d;

			a--; b--;

			G[a].push_back(edge(b, c, d));
			G[b].push_back(edge(a, c, d));
		}

		dijkstra(0, l);

		int ans = INF;
		rep(i, l+1) {
			ans = min(ans, d[n-1][i]);
		}

		cout << ans << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2608 Minus One]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/06/aoj2608-minus-one/"/>
    <updated>2016-06-06T23:24:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/06/aoj2608-minus-one</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2608">Minus One | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

$G$に$e$を付け加えて無向グラフにおける$s$から$t$への最短路の長さより$1$だけ大きいものの個数を答える．これはつまり，パスを貼った時に最短経路長が$1$小さくなるものである．  
  
$s$からの最短経路長を$d[i]$，$t$からの最短経路長を$d2[i]$とする．点$a$と点$b$を結んだ場合，$s \to a \to b \to t$という経路を行くとすると，コストは$d[a] + 1 + d2[b]$となる．この時$s \to t$の最短経路長$+1$となる経路は，
$$
\begin{eqnarray}
	d[t] - 1 &=& d[a] + 1 + d2[b] \\\\
	d2[b] &=& d[t] - 2 - d[a]
\end{eqnarray}
$$
が条件となる．愚直に$a, b$のペアを列挙して確認すると$O(n ^2)$で間に合わないが，点$a$を決めた時に，経路長$1$少なくなる$b$の選び方は$d[t] - 2 - d[a]$となる$d2[i]$の個数と決まるので，先に$d2[i]$をカウントしておくと$O(n)$で求められる．最短経路を求めるのが一番時間がかかるので全体で$O(n logn)$．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

struct edge {
	int from,to;
	int cost;

	edge(int t,int c) : to(t),cost(c) {}
	edge(int f,int t,int c) : from(f),to(t),cost(c) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

vector<edge> G[100005];
int d[100005], d2[100005], cnt[100005];

void dijkstra(int s) {
	priority_queue<P, vector<P>, greater<P> > que;
	rep(i, 100005) d[i] = INF;
	
	que.push(mp(0, s));
	d[s] = 0;

	while(que.size()) {
		P p = que.top(); que.pop();
		int cost = p.first;
		int v = p.second;

		if(d[v] < cost) continue;

		rep(i, G[v].size()) {
			edge e = G[v][i];
			if(d[e.to] > d[v] + e.cost) {
				d[e.to] = d[v] + e.cost;
				que.push(mp(d[e.to], e.to));
			}
		}
	}
}

int main() {
	int n, m;
	cin >> n >> m;

	int s, t;
	cin >> s >> t;
	s--; t--;

	rep(i, m) {
		int a, b;
		cin >> a >> b;
		a--; b--;

		G[a].push_back(edge(b, 1));
		G[b].push_back(edge(a, 1));
	}

	dijkstra(s);
	rep(i, n) d2[i] = d[i];

	dijkstra(t);
	rep(i, n) swap(d[i], d2[i]);

	memset(cnt, 0, sizeof(cnt));
	rep(i, n) {
		if(d2[i] == INF) continue;
		cnt[d2[i]]++;
	}

	ll ans = 0;
	rep(i, n) {
		if(d[i] == INF || d2[i] == INF) continue;
		int x = d[t] - 2 - d[i];

		if(x >= 0) {
			ans += cnt[x];
		}
	}

	cout << ans << endl;

	return 0;
}
```

経路復元とか色々していて，色々考えた後に書き直したら非常にスッキリして面白いと思った．但し解くのに時間がかかりすぎている...
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2241 Usaneko Matrix]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/04/aoj2241-usaneko-matrix/"/>
    <updated>2016-06-04T17:34:11+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/04/aoj2241-usaneko-matrix</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2241">Usaneko Matrix | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

ビンゴゲームをやる．行，列，斜めで揃っているものが$u$，$v$以上になれば勝ちとなる．それぞれの数字がどこの座標にあったかをチェックし，引いた数の座標から，縦横斜めの該当する所を$+1$する．先にどちらかが勝った場合は後は続けなくて良いので，毎回引くごとに合計を確認した．$n=1$は，場合分けした．$O(nm)$


# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int n, u, v, m;
	cin >> n >> u >> v >> m;

	map<int, vector<P> > ma[2];
	vector<vector<int> > a(n, vector<int>(n)), b(n, vector<int>(n));

	rep(i, n) {
		rep(j, n) {
			cin >> a[i][j];
			ma[0][a[i][j]].push_back(mp(i, j));
		}
	}

	rep(i, n) {
		rep(j, n) {
			cin >> b[i][j];
			ma[1][b[i][j]].push_back(mp(i, j));
		}
	}

	vector<int> x(m);
	rep(i, m) cin >> x[i];

	if(n == 1) {
		rep(i, m) {
			int sum[2];
			memset(sum, 0, sizeof(sum));

			rep(j, 2) {
				vector<P> res = ma[j][x[i]];
				if(res.size() >= 1) sum[j]++;
			}

			bool f1 = (sum[0] >= u);
			bool f2 = (sum[1] >= v);

			if(f1 && f2) {
				cout << "DRAW" << endl;
				return 0;
			} else if(f1) {
				cout << "USAGI" << endl;
				return 0;
			} else if(f2) {
				cout << "NEKO" << endl;
				return 0;
			}
		}

		cout << "DRAW" << endl;
		return 0;
	}


	int cy[2][505], cx[2][505], cross[2][2];
	memset(cy, 0, sizeof(cy));
	memset(cx, 0, sizeof(cx));
	memset(cross, 0, sizeof(cross));

	rep(i, m) {

		rep(j, 2) {
			vector<P> res = ma[j][x[i]];
			rep(k, res.size()) {
				int f = res[k].first, s = res[k].second;
				cy[j][f]++;
				cx[j][s]++;

				if(f == s) cross[j][0]++;
				if(f == n - 1 - s) cross[j][1]++;
			}
		}

		int sum[2];
		memset(sum, 0, sizeof(sum));

		rep(j, 2) {
			rep(k, 2) {
				sum[j] += (cross[j][k] == n);
			}
		}

		rep(j, 2) {
			rep(k, n) {
				sum[j] += (cy[j][k] == n);
				sum[j] += (cx[j][k] == n);
			}
		}

		bool f1 = (sum[0] >= u), f2 = (sum[1] >= v);
		if(f1 && f2) {
			cout << "DRAW" << endl;
			return 0;
		} else if(f1) {
			cout << "USAGI" << endl;
			return 0;
		} else if(f2) {
			cout << "NEKO" << endl;
			return 0;
		}
	}

	cout << "DRAW" << endl;

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2383 Rabbit Game Playing]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/30/aoj2383-rabbit-game-playing/"/>
    <updated>2016-05-30T21:06:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/30/aoj2383-rabbit-game-playing</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2383">Rabbit Game Playing | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

現在プレイした(ステージの難易度 {% m %} -T {% em %})以上の難易度のステージをプレイ出来る． {% m %} N {% em %}ステージ全てプレイする時に，何通りの方法があるか？ {% m %} mod\ 1000000007 {% em %}で求める．  
  
難易度でsortして，小さい順に列に入れていく． {% m %} i-1個 {% em %}で構成される上記のルールを満たす列に {% m %} v[i] {% em %}を入れることを考える．列の中に {% m %} v[i]-t {% em %}以上のものがあれば，その後に {% m %} v[i] {% em %}を入れることが出来る．つまり， ({% m %} i-1 {% em %}までの場合の数 {% m %} \times {% em %} {% m %} iまででv[i]-t {% em %}以上のステージの個数)通りとなる．これを {% m %} N {% em %}回繰り返す．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair
#define MOD 1000000007

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int n, t;
	cin >> n >> t;

	vector<int> v(n);
	rep(i, n) cin >> v[i];

	sort(v.begin(), v.end());

	ll ans = 1;
	vector<int> res;
	rep(i, n) {
		res.push_back(v[i]);
		int id = lower_bound(res.begin(), res.end(), v[i] - t) - res.begin();
		ans *= (res.size() - id);
		ans %= MOD;
	}

	cout << ans << endl;

	return 0;
}
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2176 For the Peace]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/29/aoj2176-for-the-peace/"/>
    <updated>2016-05-29T23:33:39+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/29/aoj2176-for-the-peace</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2176">For the Peace</a></h4><p>This is a story of a world somewhere far from the earth. In this world, the land is parted into a number of countries ruled by empires. This world is not very peaceful: they have been involved in army race. They are competing in production of missiles in particular.</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

それぞれの国の {% m %} war\ potential {% em %}はミサイルの威力の合計で決まる．ミサイルはそれぞれの国と差が {% m %} d {% em %}以下なら捨てることが出来る．全ての国はミサイルを捨てることが出来るか？  
  
何かを捨てたことによって，本来捨てられるべきものが捨てられなかった，という場合がないので，捨てられるものから捨てていった．


# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <stack>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int n, d;
	while(cin >> n >> d) {
		if(n == 0 && d == 0) break;

		stack<int> st[n];
		vector<int> sum(n);
		rep(i, n) {
			int m;
			cin >> m;

			rep(j, m) {
				int x;
				cin >> x;

				st[i].push(x);
				sum[i] += x;
			}
		}

		int id = 0, cnt = 0;
		while(cnt != n) {
			if(st[id].size() == 0) {
				id = (id + 1) % n;
				cnt++;
				continue;
			}

			int p = st[id].top();
			sum[id] -= p;

			int vmin = INF, vmax = 0;
			rep(i, n) {
				vmin = min(vmin, sum[i]);
				vmax = max(vmax, sum[i]);
			}

			if(vmax - vmin <= d) {
				st[id].pop();
				cnt = 0;
			} else {
				sum[id] += p;
				cnt++;
			}

			id = (id + 1) % n;
		}

		bool flag = true;
		rep(i, n) {
			if(sum[i] == 0) continue;
			flag  = false;
		}

		if(flag) cout << "Yes" << endl;
		else cout << "No" << endl;
	}
	return 0;
}
```
]]></content>
  </entry>
  
</feed>
