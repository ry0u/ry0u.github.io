<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: aoj-icpc | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/aoj-icpc/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-06-09T14:11:03+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ2151 Brave Princess Revisited]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/09/aoj2151-brave-princess-revisited/"/>
    <updated>2016-06-09T13:59:08+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/09/aoj2151-brave-princess-revisited</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151">Brave Princess Revisited | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>状態を(襲われる盗賊や刺客の人数, お金, 頂点番号)としてdijkstra．現在の状態から次の状態への遷移は，護衛を雇わないで盗賊に襲われる，護衛を雇い守ってもらう，の$2$つである．お金が辺の長さより少ない場合は護衛を雇えないことに注意する．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;
typedef pair&lt;P, int&gt; PI;

struct edge {
    int from,to;
    int cost, res;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int t,int c,int r) : to(t), cost(c), res(r) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[105];
int d[105][105];

void dijkstra(int s, int l) {
    rep(i, 105) rep(j, 105) d[i][j] = INF;
    d[s][l] = 0;

    priority_queue&lt;PI, vector&lt;PI&gt;, greater&lt;PI&gt; &gt; que;
    que.push(mp(mp(0, -l), s));

    while(que.size()) {
        PI p = que.top(); que.pop();
        int cost = p.first.first;
        int coin = p.first.second;
        int v = p.second;
        coin *= -1;

        if(d[v][coin] &lt; cost) continue;

        rep(i, G[v].size()) {
            edge e = G[v][i];

            if(d[e.to][coin] &gt; d[v][coin] + e.res) {
                d[e.to][coin] = d[v][coin] + e.res;
                que.push(mp(mp(d[e.to][coin], -coin), e.to));
            }

            int nc = coin - e.cost;
            if(nc &gt;= 0 &amp;&amp; d[e.to][nc] &gt; d[v][coin]) {
                d[e.to][nc] = d[v][coin];
                que.push(mp(mp(d[e.to][nc], -nc), e.to));
            }
        }

    }
}

int main() {
    int n, m, l;
    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; l)  {
        if(n == 0 &amp;&amp; m == 0 &amp;&amp; l == 0) break;

        rep(i, 105) G[i].clear();

        rep(i, m) {
            int a, b, c, d;
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;

            a--; b--;

            G[a].push_back(edge(b, c, d));
            G[b].push_back(edge(a, c, d));
        }

        dijkstra(0, l);

        int ans = INF;
        rep(i, l+1) {
            ans = min(ans, d[n-1][i]);
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2608 Minus One]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/06/aoj2608-minus-one/"/>
    <updated>2016-06-06T23:24:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/06/aoj2608-minus-one</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2608">Minus One | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>$G$に$e$を付け加えて無向グラフにおける$s$から$t$への最短路の長さより$1$だけ大きいものの個数を答える．これはつまり，パスを貼った時に最短経路長が$1$小さくなるものである．</p>

<p>$s$からの最短経路長を$d[i]$，$t$からの最短経路長を$d2[i]$とする．点$a$と点$b$を結んだ場合，$s \to a \to b \to t$という経路を行くとすると，コストは$d[a] + 1 + d2[b]$となる．この時$s \to t$の最短経路長$+1$となる経路は，
$$
\begin{eqnarray}
    d[t] - 1 &amp;=&amp; d[a] + 1 + d2[b] \\
    d2[b] &amp;=&amp; d[t] - 2 - d[a]
\end{eqnarray}
$$
が条件となる．愚直に$a, b$のペアを列挙して確認すると$O(n ^2)$で間に合わないが，点$a$を決めた時に，経路長$1$少なくなる$b$の選び方は$d[t] - 2 - d[a]$となる$d2[i]$の個数と決まるので，先に$d2[i]$をカウントしておくと$O(n)$で求められる．最短経路を求めるのが一番時間がかかるので全体で$O(n logn)$．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[100005];
int d[100005], d2[100005], cnt[100005];

void dijkstra(int s) {
    priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que;
    rep(i, 100005) d[i] = INF;

    que.push(mp(0, s));
    d[s] = 0;

    while(que.size()) {
        P p = que.top(); que.pop();
        int cost = p.first;
        int v = p.second;

        if(d[v] &lt; cost) continue;

        rep(i, G[v].size()) {
            edge e = G[v][i];
            if(d[e.to] &gt; d[v] + e.cost) {
                d[e.to] = d[v] + e.cost;
                que.push(mp(d[e.to], e.to));
            }
        }
    }
}

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    int s, t;
    cin &gt;&gt; s &gt;&gt; t;
    s--; t--;

    rep(i, m) {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        a--; b--;

        G[a].push_back(edge(b, 1));
        G[b].push_back(edge(a, 1));
    }

    dijkstra(s);
    rep(i, n) d2[i] = d[i];

    dijkstra(t);
    rep(i, n) swap(d[i], d2[i]);

    memset(cnt, 0, sizeof(cnt));
    rep(i, n) {
        if(d2[i] == INF) continue;
        cnt[d2[i]]++;
    }

    ll ans = 0;
    rep(i, n) {
        if(d[i] == INF || d2[i] == INF) continue;
        int x = d[t] - 2 - d[i];

        if(x &gt;= 0) {
            ans += cnt[x];
        }
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>経路復元とか色々していて，色々考えた後に書き直したら非常にスッキリして面白いと思った．但し解くのに時間がかかりすぎている&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2241 Usaneko Matrix]]></title>
    <link href="http://ry0u.github.io/blog/2016/06/04/aoj2241-usaneko-matrix/"/>
    <updated>2016-06-04T17:34:11+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/06/04/aoj2241-usaneko-matrix</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2241">Usaneko Matrix | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>ビンゴゲームをやる．行，列，斜めで揃っているものが$u$，$v$以上になれば勝ちとなる．それぞれの数字がどこの座標にあったかをチェックし，引いた数の座標から，縦横斜めの該当する所を$+1$する．先にどちらかが勝った場合は後は続けなくて良いので，毎回引くごとに合計を確認した．$n=1$は，場合分けした．$O(nm)$</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n, u, v, m;
    cin &gt;&gt; n &gt;&gt; u &gt;&gt; v &gt;&gt; m;

    map&lt;int, vector&lt;P&gt; &gt; ma[2];
    vector&lt;vector&lt;int&gt; &gt; a(n, vector&lt;int&gt;(n)), b(n, vector&lt;int&gt;(n));

    rep(i, n) {
        rep(j, n) {
            cin &gt;&gt; a[i][j];
            ma[0][a[i][j]].push_back(mp(i, j));
        }
    }

    rep(i, n) {
        rep(j, n) {
            cin &gt;&gt; b[i][j];
            ma[1][b[i][j]].push_back(mp(i, j));
        }
    }

    vector&lt;int&gt; x(m);
    rep(i, m) cin &gt;&gt; x[i];

    if(n == 1) {
        rep(i, m) {
            int sum[2];
            memset(sum, 0, sizeof(sum));

            rep(j, 2) {
                vector&lt;P&gt; res = ma[j][x[i]];
                if(res.size() &gt;= 1) sum[j]++;
            }

            bool f1 = (sum[0] &gt;= u);
            bool f2 = (sum[1] &gt;= v);

            if(f1 &amp;&amp; f2) {
                cout &lt;&lt; "DRAW" &lt;&lt; endl;
                return 0;
            } else if(f1) {
                cout &lt;&lt; "USAGI" &lt;&lt; endl;
                return 0;
            } else if(f2) {
                cout &lt;&lt; "NEKO" &lt;&lt; endl;
                return 0;
            }
        }

        cout &lt;&lt; "DRAW" &lt;&lt; endl;
        return 0;
    }


    int cy[2][505], cx[2][505], cross[2][2];
    memset(cy, 0, sizeof(cy));
    memset(cx, 0, sizeof(cx));
    memset(cross, 0, sizeof(cross));

    rep(i, m) {

        rep(j, 2) {
            vector&lt;P&gt; res = ma[j][x[i]];
            rep(k, res.size()) {
                int f = res[k].first, s = res[k].second;
                cy[j][f]++;
                cx[j][s]++;

                if(f == s) cross[j][0]++;
                if(f == n - 1 - s) cross[j][1]++;
            }
        }

        int sum[2];
        memset(sum, 0, sizeof(sum));

        rep(j, 2) {
            rep(k, 2) {
                sum[j] += (cross[j][k] == n);
            }
        }

        rep(j, 2) {
            rep(k, n) {
                sum[j] += (cy[j][k] == n);
                sum[j] += (cx[j][k] == n);
            }
        }

        bool f1 = (sum[0] &gt;= u), f2 = (sum[1] &gt;= v);
        if(f1 &amp;&amp; f2) {
            cout &lt;&lt; "DRAW" &lt;&lt; endl;
            return 0;
        } else if(f1) {
            cout &lt;&lt; "USAGI" &lt;&lt; endl;
            return 0;
        } else if(f2) {
            cout &lt;&lt; "NEKO" &lt;&lt; endl;
            return 0;
        }
    }

    cout &lt;&lt; "DRAW" &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2383 Rabbit Game Playing]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/30/aoj2383-rabbit-game-playing/"/>
    <updated>2016-05-30T21:06:32+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/30/aoj2383-rabbit-game-playing</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2383">Rabbit Game Playing | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>現在プレイした(ステージの難易度 <script type="math/tex"> -T </script>)以上の難易度のステージをプレイ出来る． <script type="math/tex"> N </script>ステージ全てプレイする時に，何通りの方法があるか？ <script type="math/tex"> mod\ 1000000007 </script>で求める．</p>

<p>難易度でsortして，小さい順に列に入れていく． <script type="math/tex"> i-1個 </script>で構成される上記のルールを満たす列に <script type="math/tex"> v[i] </script>を入れることを考える．列の中に <script type="math/tex"> v[i]-t </script>以上のものがあれば，その後に <script type="math/tex"> v[i] </script>を入れることが出来る．つまり， (<script type="math/tex"> i-1 </script>までの場合の数 <script type="math/tex"> \times </script> <script type="math/tex"> iまででv[i]-t </script>以上のステージの個数)通りとなる．これを <script type="math/tex"> N </script>回繰り返す．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair
#define MOD 1000000007

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n, t;
    cin &gt;&gt; n &gt;&gt; t;

    vector&lt;int&gt; v(n);
    rep(i, n) cin &gt;&gt; v[i];

    sort(v.begin(), v.end());

    ll ans = 1;
    vector&lt;int&gt; res;
    rep(i, n) {
        res.push_back(v[i]);
        int id = lower_bound(res.begin(), res.end(), v[i] - t) - res.begin();
        ans *= (res.size() - id);
        ans %= MOD;
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ2176 For the Peace]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/29/aoj2176-for-the-peace/"/>
    <updated>2016-05-29T23:33:39+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/29/aoj2176-for-the-peace</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2176">For the Peace</a></h4><p>This is a story of a world somewhere far from the earth. In this world, the land is parted into a number of countries ruled by empires. This world is not very peaceful: they have been involved in army race. They are competing in production of missiles in particular.</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>それぞれの国の <script type="math/tex"> war\ potential </script>はミサイルの威力の合計で決まる．ミサイルはそれぞれの国と差が <script type="math/tex"> d </script>以下なら捨てることが出来る．全ての国はミサイルを捨てることが出来るか？</p>

<p>何かを捨てたことによって，本来捨てられるべきものが捨てられなかった，という場合がないので，捨てられるものから捨てていった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;stack&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n, d;
    while(cin &gt;&gt; n &gt;&gt; d) {
        if(n == 0 &amp;&amp; d == 0) break;

        stack&lt;int&gt; st[n];
        vector&lt;int&gt; sum(n);
        rep(i, n) {
            int m;
            cin &gt;&gt; m;

            rep(j, m) {
                int x;
                cin &gt;&gt; x;

                st[i].push(x);
                sum[i] += x;
            }
        }

        int id = 0, cnt = 0;
        while(cnt != n) {
            if(st[id].size() == 0) {
                id = (id + 1) % n;
                cnt++;
                continue;
            }

            int p = st[id].top();
            sum[id] -= p;

            int vmin = INF, vmax = 0;
            rep(i, n) {
                vmin = min(vmin, sum[i]);
                vmax = max(vmax, sum[i]);
            }

            if(vmax - vmin &lt;= d) {
                st[id].pop();
                cnt = 0;
            } else {
                sum[id] += p;
                cnt++;
            }

            id = (id + 1) % n;
        }

        bool flag = true;
        rep(i, n) {
            if(sum[i] == 0) continue;
            flag  = false;
        }

        if(flag) cout &lt;&lt; "Yes" &lt;&lt; endl;
        else cout &lt;&lt; "No" &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
