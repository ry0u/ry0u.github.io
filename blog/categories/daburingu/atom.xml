<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ダブリング | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/daburingu/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-09-03T02:19:57+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ABC013D 阿弥陀]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/03/abc013d-a-mi-tuo/"/>
    <updated>2016-04-03T17:49:54+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/03/abc013d-a-mi-tuo</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://abc013.contest.atcoder.jp/tasks/abc013_4">D: 阿弥陀 - AtCoder Beginner Contest 013 | AtCoder</a></h4><p>(null)</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

まず一回アミダをシュミレーションする．すると，ゴールする場所 {% m %} iをj {% em %}に変える関数が作れる．これを遷移行列にして行列類乗だ！と思ったが， {% m %} N \leq 10 ^5 {% em %}で {% m %} D {% em %}は {% m %} logD {% em %}に落ちるが結果{% m %} N ^3 logD {% em %}となってしまい意味が無い．  
そもそも行列で持つ必要がない．ダブリングで {% m %} D {% em %}を {% m %} logD {% em %}に落として， {% m %} O(N logN logD) {% em %}．  
resをmapで作ってしまい {% m %} logN {% em %}が余計にかかる．変に {% m %} log {% em %}をつけて落ちることがあるので気をつけたい．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int n, m, d;
	cin >> n >> m >> d;

	vector<int> a(m);
	rep(i, m) cin >> a[i];

	vector<int> v(n);
	rep(i, n) v[i] = i;

	rep(i, m) {
		swap(v[a[i]-1], v[a[i]]);
	}

	map<int, int> res;
	rep(i, n) {
		res[v[i]] = i;
	}

	vector<int> next(n), cur(n);
	rep(i, n) cur[i] = i;
	while(d) {
		if(d & 1) {
			rep(i, n) next[i] = res[cur[i]];
			rep(i, n) cur[i] = next[i];
		}

		rep(i, n) next[i] = res[res[i]];
		rep(i, n) res[i] = next[i];

		d /= 2;
	}

	rep(i, n) {
		cout << cur[i] + 1 << endl;
	}

	return 0;
}
```
]]></content>
  </entry>
  
</feed>
