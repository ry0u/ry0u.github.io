<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: aoj | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/aoj/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-18T23:11:03+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ1286 Expected Allowance]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj1286-expected-allowance/"/>
    <updated>2016-03-18T22:54:03+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj1286-expected-allowance</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1286">Expected Allowance | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p><script type="math/tex; mode=display">
    dp[i][j] := i回，m面のサイコロを降った時にjが出る回数
</script></p>

<p>として，シュミレーション．サイコロを振るのは <script type="math/tex"> dp[i+1][j+k] += dp[i][j] </script>と書ける．配列を再利用するために，<script type="math/tex"> iとi+1 </script>の偶奇を見て遷移する．次に遷移する場所に値が残っているとおかしいことになるので，<script type="math/tex"> dp[i][j] </script>からサイコロを振ったらそこは初期化する．分母は全て <script type="math/tex"> m ^n </script>で， <script type="math/tex"> k </script>引いた時に最低でも <script type="math/tex"> 1 </script>になるようにして期待値を求める．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int dp[2][100005];

int main() {
    int n, m, k;
    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; k) {
        if(n == 0 &amp;&amp; m == 0 &amp;&amp; k == 0) break;

        memset(dp, 0, sizeof(dp));
        REP(j, 1, m + 1) {
            dp[1][j] = 1;
        }

        rep(i, n) {
            rep(j, 100005) {
                if(dp[i &amp; 1][j] == 0) continue;
                REP(k, 1, m+1) {
                    dp[(i+1)&amp;1][j+k] += dp[i&amp;1][j];
                }
                dp[i&amp;1][j] = 0;
            }
        }

        double ans = 0, t = 1;
        rep(i, n) {
            t *= m;
        }

        rep(j, 100005) {
            if(dp[n&amp;1][j] == 0) continue;

            double l = j - k;
            if(l &lt;= 0) l = 1;
            ans += (dp[n &amp; 1][j] / t) * l;
        }

        cout &lt;&lt; fixed;
        cout.precision(20);
        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1277 Minimal Backgammon]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj1277-minimal-backgammon/"/>
    <updated>2016-03-18T22:14:05+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj1277-minimal-backgammon</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1277">Minimal Backgammon</a></h4><p>Here is a very simple variation of the game backgammon, named "Minimal Backgammon". The game is played by only one player, using only one of the dice and only one checker (the token used by the player). The game board is a line of ( N + 1) squares labeled as 0 (the start) to N (the goal).</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>動的計画法．
<script type="math/tex; mode=display">
    dp[i][j] := iターン目にマスjにいる確率
</script></p>

<p>とする．<script type="math/tex"> i </script>ターン目にマス<script type="math/tex"> j </script>にいる時にサイコロを振るのは
<script type="math/tex; mode=display">
    dp[i+1][j+k] = dp[i][j] \cdot (1.0 / 6.0);
</script>
と書ける．一回休みの時は<script type="math/tex"> dp[i+2][j+k] </script>，戻るマスは <script type="math/tex"> dp[i+1][0] </script>に遷移する．<script type="math/tex"> n </script>マスを追い越した時に戻ってくる処理でバグバグした．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

double dp[105][105];

int main() {
    int n, t, l, b;
    while(cin &gt;&gt; n &gt;&gt; t &gt;&gt; l &gt;&gt; b) {
        if(n == 0 &amp;&amp; t == 0 &amp;&amp; l == 0 &amp;&amp; b == 0) break;

        memset(dp, 0, sizeof(dp));

        bool lose[105], back[1005];
        memset(lose, 0, sizeof(lose));
        memset(back, 0, sizeof(back));

        rep(i, l) {
            int x;
            cin &gt;&gt; x;
            lose[x] = true;
        }

        rep(i, b) {
            int x;
            cin &gt;&gt; x;
            back[x] = true;
        }

        memset(dp, 0, sizeof(dp));

        dp[0][0] = 1.0;
        rep(i, t) {
            rep(j, n) {
                if(dp[i][j] == 0.0) continue;
                REP(k, 1, 7) {
                    int p = j + k;
                    if(p &gt; n) p = n - (p - n);

                    if(lose[p]) {
                        dp[i+2][p] += dp[i][j] * (1.0 / 6.0);
                    } else if(back[p]) {
                        dp[i+1][0] += dp[i][j] * (1.0 / 6.0);
                    } else {
                        dp[i+1][p] += dp[i][j] * (1.0 / 6.0);
                    }
                }
            }
        }

        double ans = 0;
        rep(i, t + 1) {
            ans += dp[i][n];
        }

        cout &lt;&lt; fixed;
        cout.precision(20);
        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0616 JOI Park]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj0616-joi-park/"/>
    <updated>2016-03-18T16:24:27+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj0616-joi-park</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0616">JOI Park | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>まず，<script type="math/tex"> 広場0 </script>からの各広場までの最短経路を求める．次に，コストが小さい順にソートし，その場所への到達コストを仮の<script type="math/tex"> X </script>と置き，整備する場所とする．整備される場所同士は，地下道を通して行き来できるためそのコストを全体から引く．始点を到達コスト<script type="math/tex"> 0 </script>の広場と見れば整備しない場合も考慮される．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1LL&lt;&lt;60
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct edge {
    int from,to;
    int cost;

    edge(int t,int c) : to(t),cost(c) {}
    edge(int f,int t,int c) : from(f),to(t),cost(c) {}

    bool operator&lt;(const edge &amp;e) const {
        return cost &lt; e.cost;
    }
};

vector&lt;edge&gt; G[100005];
ll d[100005];
bool used[100005];

void dijkstra(int s,int n) {
    priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; que;
    fill(d,d+n,INF);

    d[s] = 0;
    que.push(P(0,s));

    while(que.size()) {
        P p = que.top();
        que.pop();

        int v = p.second;
        if(d[v] &lt; p.first) continue;

        rep(i,G[v].size()) {
            edge e = G[v][i];
            if(d[e.to] &gt; d[v] + e.cost) {
                d[e.to] = d[v] + e.cost;
                que.push(P(d[e.to],e.to));
            }
        }
    }
}

int main() {
    int n, m, c;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;

    ll sum = 0;
    rep(i, m) {
        int a, b, d;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;

        a--;
        b--;
        sum += d;

        G[a].push_back(edge(b, d));
        G[b].push_back(edge(a, d));
    }

    dijkstra(0, n);

    vector&lt;pair&lt;ll, int&gt; &gt; v(n);
    rep(i, n) {
        v[i].first = d[i];
        v[i].second = i;
    }

    sort(v.begin(), v.end());
    memset(used, 0, sizeof(used));

    ll ans = INF;
    rep(i, v.size()) {
        int j = v[i].second;
        used[j] = true;

        rep(k, G[j].size()) {
            if(used[G[j][k].to]) {
                sum -= G[j][k].cost;
            }
        }

        ans = min(ans, d[j] * c + sum);
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0615 Cake2]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj0615-cake2/"/>
    <updated>2016-03-18T16:03:17+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj0615-cake2</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0615">Cake 2 | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>左端と右端を持ってdpだろうとずっと考えていたけど全く分からなかった．調べた．</p>

<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://lattemalta.hatenablog.jp/entry/2015/09/07/220749">aoj0615:Cake2 - らての精進日記</a></h4><p>問題文 http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0615</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>


<p>非常に分かりやすかった．左端と右端を持つ区間DPを初めて書いた（写経）．バームクーヘンとかの時は円環を配列を繋げて表現する時に2つを繋げれば良かったが，とり方によってどっちにずれるかわからないので，真ん中を基準として左に1個，右に1個つなげる．</p>

<ul>
<li>区間の偶奇でどちらの順番かがわかる</li>
<li>左端から一個取る <script type="math/tex"> \to \rm{dfs}(l-1, r) + A[l]</script></li>
<li>右端から一個取る <script type="math/tex"> \to \rm{dfs}(l, r-1) + A[r]</script></li>
<li>memoに代入するのを忘れない</li>
</ul>


<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;ll,ll&gt; P;

int n;
vector&lt;ll&gt; v;
ll memo[4005][6005];

ll dfs(int l, int r) {
    if(memo[l][r] != -1) return memo[l][r];

    int turn = r - l - 1;

    if(turn == n) return memo[l][r] = 0;
    else if(turn % 2 == 1) {
        if(v[l] &lt; v[r]) {
            return memo[l][r] = dfs(l, r+1);
        } else {
            return memo[l][r] = dfs(l-1, r);
        }
    } else {
        return memo[l][r] = max(dfs(l-1, r) + v[l], dfs(l, r+1) + v[r]);
    }
}

int main() {
    cin &gt;&gt; n;

    v.resize(n*3);
    rep(i, n) { 
        cin &gt;&gt; v[i];
        v[i+n] = v[i];
        v[i+n+n] = v[i];
    }

    ll ans = 0;
    memset(memo, -1, sizeof(memo));

    rep(i, n) {
        ans = max(ans, dfs(i-1+n, i+1+n) + v[i]);
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0614 Railroad Trip]]></title>
    <link href="http://ry0u.github.io/blog/2016/03/18/aoj0614-railroad-trip/"/>
    <updated>2016-03-18T15:49:20+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/03/18/aoj0614-railroad-trip</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-type="article" data-card-branding="0"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0614">Railroad Trip | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>


<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>




<!-- more -->


<p>移動が終わった時に，各鉄道に何回乗ったか知りたい．imosで累積和を求めた後に，各鉄道に対して，切符を買って乗るか，その鉄道のICカードを書いICカードで乗るか，安い方を選んだ．</p>

<ul>
<li>切符で乗る <script type="math/tex"> \to cnt[i] \cdot a[i] </script></li>
<li>ICカードを買う + ICカードで乗る <script type="math/tex"> \to cnt[i] \cdot b[i] + c[i] </script></li>
</ul>


<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

ll cnt[100005];
vector&lt;ll&gt; p, a, b, c;

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    p.resize(m);
    rep(i, m) {
        cin &gt;&gt; p[i];
        p[i]--;
    }

    a.resize(n-1);
    b.resize(n-1);
    c.resize(n-1);

    rep(i, n-1) {
        cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];
    }

    rep(i, m-1) {
        if(p[i] == p[i+1]) continue;

        if(p[i] &lt; p[i+1]) {
            cnt[p[i]]++;
            cnt[p[i+1]]--;
        } else {
            cnt[p[i+1]]++;
            cnt[p[i]]--;
        }
    }

    rep(i, 100005) {
        cnt[i+1] += cnt[i];
    }

    ll ans = 0;
    rep(i, n-1) {
        ans += min(cnt[i] * a[i], cnt[i] * b[i] + c[i]);
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
