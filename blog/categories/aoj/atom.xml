<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: aoj | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/aoj/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-02-10T22:48:52+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ0551 Icicles]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/10/aoj0551-icicles/"/>
    <updated>2016-02-10T22:42:10+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/10/aoj0551-icicles</id>
    <content type="html"><![CDATA[<p>問題文<br/>
<a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0551">http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0551</a></p>

<!-- more -->


<p>i番目のつららが落ちる時間は両隣のi-1，i+1番目のつららが落ちる時間に依存し，初期の値が大きいほうからつららを落として行けば矛盾は起きないと思ったので，priority_queueでやったらACした．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n, l;
    while(cin &gt;&gt; n &gt;&gt; l) {
        if(n == 0 &amp;&amp; l == 0) break;

        vector&lt;int&gt; v(n), cnt(n);
        priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que;
        rep(i, n) {
            cin &gt;&gt; v[i];
            cnt[i] = 0;
            que.push(P(v[i], i));
        }

        while(que.size()) {
            P p = que.top();
            que.pop();

            int d = l - p.first;
            int id = p.second;

            if(id == 0) cnt[id] += cnt[id+1] + d;
            else if(id == n-1) cnt[id] += cnt[id-1] + d;
            else cnt[id] += max(cnt[id-1], cnt[id+1]) + d;
        }

        int ans = 0;
        rep(i, n) {
            ans = max(ans, cnt[i]);
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0549 A Traveler]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/10/aoj0549-a-traveler/"/>
    <updated>2016-02-10T22:34:52+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/10/aoj0549-a-traveler</id>
    <content type="html"><![CDATA[<p>問題文<br/>
<a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0549">http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0549</a></p>

<!-- more -->


<p>宿場町<script type="math/tex">kから宿場町k + a_i</script>までのコストの和が求まれば良いのでBITを用いた．ブログを書いてる時に，これimosだけのほうがシンプルでlogが消えることに気付いたけど，この問題だったらどっちでもいいよね(log<sup>2</sup>とかにならないのでほぼ定数)となった．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

struct BIT {
    vector&lt;int&gt; bit;

    BIT(int n) : bit(n+1) {}

    int sum(int i) {
        int s = 0;
        while(i &gt; 0) {
            s += bit[i];
            i -= i &amp; -i;
        }
        return s;
    }

    void add(int i,int x) {
        while(i &lt;= bit.size()) {
            bit[i] += x;
            i += i &amp; -i;
        }
    }
};

int main() {
    int n, m;
    while(cin &gt;&gt; n &gt;&gt; m) {
        if(n == 0 &amp;&amp; m == 0) break;

        BIT bit(100005);
        rep(i, n-1) {
            int a;
            cin &gt;&gt; a;

            bit.add(i+1, a);
        }

        int cur = 1;
        ll ans = 0;

        rep(i, m) {
            int a;
            cin &gt;&gt; a;

            ans += abs(bit.sum(cur+a-1) - bit.sum(cur-1));
            ans %= 100000;
            cur += a;
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>

<p>いくらlogだからといって変につけたりするとTLEすることがあるが何回かあったので，注意したい．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0547 Commute routes]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/10/aoj0547-commute-routes/"/>
    <updated>2016-02-10T22:08:01+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/10/aoj0547-commute-routes</id>
    <content type="html"><![CDATA[<p>問題文<br/>
<a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0547">http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0547</a></p>

<!-- more -->


<p>dp[i][j] := その地点から横にいける経路の個数<br/>
dp2[i][j] := その地点から縦にいける経路の個数 とした．<br/>
交差点で曲がった直後が曲がれない場合は，同じ方向であればその経路は存在する．つまりdp[i][j]の場合はdp[i][j-1]，dp2[i][j]の場合はdp[i-1][j]の経路がそのまま存在する．<br/>
また別の方向でも一個交差点を飛ばした場所の経路は存在する．つまりdp[i][j]の場合はdp2[i-2][j]，dp2[i][j]の場合はdp[i][j-2]の経路が存在する．</p>

<p>よって
<script type="math/tex; mode=display">
\begin{eqnarray}
    dp[i][j] &amp;+=&amp; dp[i][j-1] + dp2[i-2][j] \
    dp2[i][j] &amp;+=&amp; dp[i][j-2] + dp2[i-1][j]
\end{eqnarray}
</script></p>

<p>MODを取るのと忘れないようにする．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair
#define MOD 100000

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int dp[105][105], dp2[105][105];

int main() {
    int w, h;
    while(cin &gt;&gt; w &gt;&gt; h) {
        if(w == 0 &amp;&amp; h == 0) break;

        memset(dp, 0, sizeof(dp));
        memset(dp2, 0, sizeof(dp2));

        dp[0][0] = 1;
        dp2[0][0] = 1;

        rep(i, w) {
            dp[0][i] = 1;
            dp2[0][i] = 1;
        }

        rep(i, h) {
            dp[i][0] = 1;
            dp2[i][0] = 1;
        }

        REP(i, 1, h) {
            REP(j, 1, w) {
                dp[i][j] += dp[i][j-1];
                if(i - 2 &gt;= 0) dp[i][j] += dp2[i-2][j];
                dp[i][j] %= MOD;

                dp2[i][j] += dp2[i-1][j];
                if(j - 2 &gt;= 0) dp2[i][j] += dp[i][j-2];
                dp2[i][j] %= MOD;
            }
        }

        if(h == 2 || w == 2) cout &lt;&lt; 2 &lt;&lt; endl;
        else cout &lt;&lt; (dp[h-1][w-1] + dp[h-2][w-3]) % MOD &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0546 Lining up the cards]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/10/aoj0546-lining-up-the-cards/"/>
    <updated>2016-02-10T21:50:42+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/10/aoj0546-lining-up-the-cards</id>
    <content type="html"><![CDATA[<p>問題文<br/>
<a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0546">http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0546</a></p>

<!-- more-->


<p>最大<script type="math/tex"> Nが10</script>なので全探索してsetにぶっ込んで終了だと思ったけどTLEした．k番目より後ろが変更してもできる整数は一緒なので，k番目までの状態もsetにぶっ込んだらACした．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
#include &lt;map&gt;

#define REP(i,k,n) for(int i=0;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)

using namespace std;

typedef long long ll;
typedef pair&lt;int, int&gt; P;

int func(vector&lt;int&gt; v, int k) {
    stringstream ss;
    rep(i, k) {
        ss &lt;&lt; v[i];
    }

    int ret;
    ss &gt;&gt; ret;

    return ret;
}

int main() {
    int n;
    while(cin &gt;&gt; n) {
        if(n == 0) break;

        int k;
        cin &gt;&gt; k;

        vector&lt;int&gt; v(n);
        rep(i, n) cin &gt;&gt; v[i];

        sort(v.begin(), v.end());

        set&lt;int&gt; ans;
        set&lt;vector&lt;int&gt; &gt; st;


        do {
            vector&lt;int&gt; ret(k);
            rep(i, k)  ret[i] = v[i];

            if(st.find(ret) == st.end()) {
                st.insert(ret);
                ans.insert(func(v, k));
            } else continue;
        }while(next_permutation(v.begin(), v.end()));

        cout &lt;&lt; ans.size() &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ0545 Party]]></title>
    <link href="http://ry0u.github.io/blog/2016/02/10/aoj0545-party/"/>
    <updated>2016-02-10T21:45:34+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/02/10/aoj0545-party</id>
    <content type="html"><![CDATA[<p>問題文<br/>
<a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0545">http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0545</a></p>

<!-- more -->


<p>この手の問題を結構前にAtCoderで探索して解き，その時のwarshall_floyd解が非常にスマートだったという覚えがあったのでそれで書いてみた．<script type="math/tex"> N \leq 500 なのでO(N ^3)でも十分間に合う</script></p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int d[1005][1005];

void warshall_floyd(int n, int m) {
    rep(i,n) rep(j,n) d[i][j] = INF;
    rep(i,n) d[i][i] = 0;

    rep(i, m) {
        int s, t;
        cin &gt;&gt; s &gt;&gt; t;

        s--;
        t--;

        d[s][t] = 1;
        d[t][s] = 1;
    }

    rep(k, n) {
        rep(i, n) {
            rep(j, n) {
                if(d[i][k] == INF || d[k][j] == INF) continue;
                d[i][j] = min(d[i][j],d[i][k] + d[k][j]);
            }
        }
    }
}

int main() {
    int n, m;
    while(cin &gt;&gt; n &gt;&gt; m) {
        if(n == 0 &amp;&amp; m == 0) break;

        warshall_floyd(n, m);

        int ans = 0;
        rep(i, n) {
            if(i == 0) continue;
            if(d[0][i] &lt;= 2) {
                ans++;
            }
        }

        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
