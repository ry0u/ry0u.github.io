<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vol15 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/vol15/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-09-03T02:19:57+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOJ1517 Challenge from Grandfather]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/11/aoj1517-challenge-from-grandfather/"/>
    <updated>2016-05-11T11:35:39+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/11/aoj1517-challenge-from-grandfather</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1517">Challenge from Grandfather | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

部分行列の回転，反転，左シフト，右シフト，島反転を実装する．  
回転は90度回転を{% m %} \frac{angle}{90} {% em %}回行う．  
反転，左シフト，右シフトはその通りにあって，島反転は幅優先で島を発見し反転していった．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int n, m;
int t[15][15];
vector<int> v[15];

void vrotate(int r, int c, int size, int angle) {
	if(angle == 0 || angle == 360) return;

	memset(t, 0, sizeof(t));

	rep(i, angle/90) {
		int col = c;
		for(int i = r + size - 1; i >= r; i--, col++) {
			REP(j, c, c + size) {
				t[r+j-c][col] = v[i][j];
			}
		}

		REP(i, r, r + size) {
			REP(j, c, c + size) {
				v[i][j] = t[i][j];
			}
		}
	}
}

void reversal(int r, int c, int size) {
	REP(i, r, min(n, r + size)) {
		REP(j, c, min(n, c + size)) {
			v[i][j] = !v[i][j];
		}
	}
}

void leftshift(int r) {
	int t = v[r][0];
	rep(i, n) {
		v[r][i] = v[r][i+1];
	}
	v[r][n-1] = t;
}

void rightshift(int r) {
	int t = v[r][n-1];
	for(int i = n-1; i >= 1; i--) {
		v[r][i] = v[r][i-1];
	}
	v[r][0] = t;
}

int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1};
bool used[15][15];

bool can(int y, int x) {
	if(0 <= y && y < n && 0 <= x && x < n) return true;
	return false;
}

void islandreversal(int r, int c) {
	queue<P> que;
	que.push(mp(r, c));

	memset(used, 0, sizeof(used));
	used[r][c] = true;
	int t = v[r][c];
	while(que.size()) {
		P p = que.front(); que.pop();
		int y = p.first;
		int x = p.second;

		if(v[y][x] == t) {
			v[y][x] = !v[y][x];
		}

		rep(i, 4) {
			int ny = y + dy[i];
			int nx = x + dx[i];

			if(can(ny, nx) && !used[ny][nx] && v[ny][nx] == t) {
				que.push(mp(ny, nx));
				used[ny][nx] = true;
			}
		}
	}
}

int main() {
	cin >> n >> m;

	memset(v, 0, sizeof(v));
	rep(i, n) {
		v[i].resize(n);
		rep(j, n) cin >> v[i][j];
	}

	rep(i, m) {
		int o;
		cin >> o;

		int r, c, size, angle;

		if(o == 0) { // rotate
			cin >> r >> c >> size >> angle;
			r--; c--;

			vrotate(r, c, size, angle);
		} else if(o == 1) { // reversal
			cin >> r >> c >> size;
			r--; c--;

			reversal(r, c, size);
		} else if(o == 2) { // left shift
			cin >> r;
			r--;

			leftshift(r);
		} else if(o == 3) { // right shift
			cin >> r;
			r--;
			rightshift(r);
		} else if(o == 4) { // Island reversal
			cin >> r >> c;
			r--; c--;
			islandreversal(r, c);
		}
	}

	rep(i, n) {
		rep(j, n) {
			cout << v[i][j];

			if(j == n-1) cout << endl;
			else cout << " ";
		}
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1516 Nasty Boys]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/11/aoj1516-nasty-boys/"/>
    <updated>2016-05-11T11:13:41+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/11/aoj1516-nasty-boys</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1516">Nasty Boys | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

一筆書き出来るか，ということでグラフ作って奇数点の頂点を数えようかと思ったけど，グラフを作るなら，mapに突っ込んで {% m %} 1 {% em %}文字ずつ隣接しているか見たほうが早いと思い，そっちにした．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

map<char, set<char> > m;

int main() {

	m['A'].insert('B');
	m['A'].insert('D');

	m['B'].insert('A');
	m['B'].insert('C');
	m['B'].insert('E');

	m['C'].insert('B');
	m['C'].insert('F');

	m['D'].insert('A');
	m['D'].insert('E');
	m['D'].insert('G');

	m['E'].insert('B');
	m['E'].insert('D');
	m['E'].insert('F');
	m['E'].insert('H');

	m['F'].insert('C');
	m['F'].insert('E');
	m['F'].insert('I');

	m['G'].insert('D');
	m['G'].insert('H');

	m['H'].insert('E');
	m['H'].insert('G');
	m['H'].insert('I');

	m['I'].insert('F');
	m['I'].insert('H');

	rep(i, 1000) {
		string s;
		cin >> s;

		bool flag = true;
		rep(j, s.size()-1) {
			if(m[s[j]].find(s[j+1]) == m[s[j]].end()) {
				flag = false;
				break;
			}
		}

		if(flag) cout << s << endl;
	}


	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1512 Smartphone Game]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/10/aoj1512-smartphone-game/"/>
    <updated>2016-05-10T00:50:38+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/10/aoj1512-smartphone-game</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1512">Smartphone Game | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

> ブロックを任意に1つだけ決めて、最大でn回まで上下左右に移動できる。移動先のブロックは移動元のブロックのあった場所に移動する。つまり、隣接したブロックを交換する事になる。

この部分が理解出来ていなかった．普通に {% m %} n {% em %}回まで，隣接しているブロック同士をswapしていて {% m %} 1 {% em %}つのブロックだけをswapしていくことが出来ていなかった．  
求めるのは{% m %} 1 {% em %}回のプレイで得られる最大の点数なので，まずは {% m %} n {% em %}回までswapしたブロックの状態をsetに突っ込む．その後，削除，移動で変化が無くなるまで続ける．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int cost[6];
bool used[5][5], flag;
int dx[4] = {1,0,-1,0};
int dy[4] = {0,1,0,-1};

bool can(int y,int x) {
	if(0 <= y && y < 5 && 0 <= x && x < 5) return true;
	return false;
}

ll del(vector<vector<int> > &v, ll bonus) {
	memset(used, 0, sizeof(used));
	rep(i, 5) {
		rep(j, 5) {
			if(v[i][j] == 0) continue;

			int a = i;
			while(a + 1 <= 4 && v[a+1][j] == v[i][j]) {
				a++;
			}

			int b = i;
			while(b - 1 >= 0 && v[b-1][j] == v[i][j]) {
				b--;
			}

			int c = j;
			while(c + 1 <= 4 && v[i][c+1] == v[i][j]) {
				c++;
			}

			int d = j;
			while(d - 1 >= 0 && v[i][d-1] == v[i][j]) {
				d--;
			}

			if(a - b + 1 >= 3 || c - d + 1 >= 3) used[i][j] = true;
		}
	}

	ll ret = 0;
	rep(i, 5) {
		rep(j, 5) {
			if(used[i][j]) {
				ret += bonus * cost[v[i][j]];
				flag = true;
				v[i][j] = 0;
			}
		}
	}

	return ret;
}

void mov(vector<vector<int> > &v) {
	for(int i = 4; i >= 0; i--) {
		rep(j, 5) {
			int y = i;
			while(y + 1 <= 4 && v[y + 1][j] == 0) {
				swap(v[y][j], v[y+1][j]);
				y++;
			}
		}
	}
}

int n;
ll ans = 0;

set<vector<vector<int> > > res;

void dfs(int cnt, int y, int x, vector<vector<int> > v) {
	res.insert(v);

	if(cnt == n) {
		return;
	}

	rep(i, 4) {
		int ny = y + dy[i];
		int nx = x + dx[i];

		if(can(ny, nx)) {
			swap(v[y][x], v[ny][nx]);
			dfs(cnt + 1, ny, nx, v);
			swap(v[y][x], v[ny][nx]);
		}
	}
}

int main() {
	while(cin >> n && n != -1) {
		ans = 0;
		res.clear();

		vector<vector<int> > v(5, vector<int>(5));
		rep(i, 5) rep(j, 5) cin >> v[i][j];
		rep(i, 5) cin >> cost[i+1];

		rep(i, 5) {
			rep(j, 5) {
				dfs(0, i, j, v);
			}
		}

		set<vector<vector<int> > >::iterator ite;
		for(ite = res.begin(); ite != res.end(); ite++) {

			ll bonus = 1, sum = 0;
			vector<vector<int> > t = *ite;

			while(true) {
				flag = false;
				sum += del(t, bonus);

				if(flag) {
					mov(t);
					bonus++;

				} else break;
			}

			// cout << "----- : " << sum << endl;
			// rep(i, 5) {
			// 	rep(j, 5) {
			// 		cout << t[i][j] << " ";
			// 	}
			// 	cout << endl;
			// }
			ans = max(ans, sum);
		}

		cout << ans << endl;
	}

	return 0;
}
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1510 Independent Reserach]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/10/aoj1510-independent-reserach/"/>
    <updated>2016-05-10T00:43:06+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/10/aoj1510-independent-reserach</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1510">Independent Research | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->
グリッドが {% m %} 5 \times 5 \times 5 {% em %}， {% m %} N \leq 100 {% em %}なので，愚直にシュミレーション．そのマスの周り {% m %} 26 {% em %}マスに生息している生物の数を数えて，そのマスの誕生と死滅を判断する．  

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int n, c = 0;
int v[5][5][5], v2[5][5][5];
bool a[30], b[30];

int dx[26] = { 1,-1,	 0, 0,	   0, 0,	 1, 1,-1,-1,	 1, 1,-1,-1,	 0, 0, 0, 0,	 1, 1, 1, 1,	-1,-1,-1,-1};
int dy[26] = { 0, 0,	 1,-1,	   0, 0,	 1,-1, 1,-1,	 0, 0, 0, 0,	 1, 1,-1,-1,	 1, 1,-1,-1,	 1, 1,-1,-1};
int dz[26] = { 0, 0,	 0, 0,	   1,-1,	 0, 0, 0, 0,	 1,-1, 1,-1,	 1,-1, 1,-1,	 1,-1, 1,-1,	 1,-1, 1,-1};

bool can(int x,int y,int z) {
	if(0 <= x && x < 5 && 0 <= y && y < 5 && 0 <= z && z < 5) return true;
	return false;
}

int main() {
	while(cin >> n && n) {
		memset(v, 0, sizeof(v));
		memset(v2, 0, sizeof(v2));

		rep(i, 5) {
			rep(j, 5) {
				string s;
				cin >> s;

				rep(k, 5) {
					v[i][j][k] = s[k] - '0';
				}
			}
		}

		int m1;
		cin >> m1;

		memset(a, 0, sizeof(a));
		rep(i, m1) {
			int x;
			cin >> x;
			a[x] = true;
		}

		int m2;
		cin >> m2;
		memset(b, 0, sizeof(b));
		rep(i, m2) {
			int x;
			cin >> x;
			b[x] = true;
		}

		rep(q, n) {
			rep(i, 5) rep(j, 5) rep(k, 5) v2[i][j][k] = v[i][j][k];
			rep(i, 5) {
				rep(j, 5) {
					rep(k, 5) {
						int sum = 0;

						rep(l, 26) {
							int x = i + dx[l];
							int y = j + dy[l];
							int z = k + dz[l];

							if(can(x, y, z)) sum += v[x][y][z];
						}

						if(v[i][j][k] == 0) {
							if(a[sum]) {
								v2[i][j][k] = 1;
							}
						} else {
							if(!b[sum]) {
								v2[i][j][k] = 0;
							}
						}
					}
				}
			}

			rep(i, 5) rep(j, 5) rep(k, 5) v[i][j][k] = v2[i][j][k];
		}

		if(c) cout << endl;
		cout << "Case " << c + 1 << ":" << endl;
		c++;

		rep(i, 5) {
			if(i) cout << endl;
			rep(j, 5) {
				rep(k, 5) {
					cout << v[i][j][k];
				}
				cout << endl;
			}
		}
	}

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOJ1509 Rental DVD Shop NEO]]></title>
    <link href="http://ry0u.github.io/blog/2016/05/10/aoj1509-rental-dvd-shop-neo/"/>
    <updated>2016-05-10T00:29:00+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/05/10/aoj1509-rental-dvd-shop-neo</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1509">Rental DVD Shop NEO | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

セットレンタルを複数回適用することが出来る，とある{% m %} d {% em %}本以上買う場合は(選んだ本数) {% m %} \times e{% em %}となるので，{% m %} 1 {% em %}本を {% m %} e {% em %}円でレンタルすることが出来る訳なので，複数回買ったのを結局まとめてしまえば，セットレンタルをするのは{% m %} 1 {% em %}回で良いことが分かる．  
{% m %} e {% em %}円より高いものはこのセットで買った方がお得で，{% m %} e {% em %}円より高いものが {% m %} d {% em %}本無い場合は，どのへんまでをレンタルしたほうが良いかを判断しなければならないので，値段順に降順ソートして，セットレンタルする範囲と普通に借りる範囲を順番に見て，最小を取った．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	ll a, b, c, d, e;
	while(true) {
		cin >> a >> b >> c >> d >> e;

		if(a == 0 && b == 0 && c == 0 && d == 0 && e == 0) break;

		ll na, nb, nc;
		cin >> na >> nb >> nc;

		vector<ll> v;
		rep(i, na) v.push_back(a);
		rep(i, nb) v.push_back(b);
		rep(i, nc) v.push_back(c);

		sort(v.begin(), v.end(), greater<ll>());

		ll sum = a * na + b * nb + c * nc;
		ll ans = sum, pre = 0;

		rep(i, v.size()) {
			pre += v[i];
			sum -= v[i];
			if(i >= d-1) {
				ans = min(ans, sum + min(pre, (i + 1) * e));
			} else {
				ans = min(ans, sum + min(pre, d * e));
			}
		}

		cout << ans << endl;
	}

	return 0;
}
```

]]></content>
  </entry>
  
</feed>
