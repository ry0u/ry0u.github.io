<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 2分探索 | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/2fen-tan-suo/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-03-23T21:16:20+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Codeforces314-div2D One-Dimensional Battle Ships]]></title>
    <link href="http://ry0u.github.io/blog/2015/08/10/codeforces314-div2d-one-dimensional-battle-ships/"/>
    <updated>2015-08-10T11:21:11+09:00</updated>
    <id>http://ry0u.github.io/blog/2015/08/10/codeforces314-div2d-one-dimensional-battle-ships</id>
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/567/problem/D">http://codeforces.com/contest/567/problem/D</a><br/>
1次元のマス目がある．ここに長さaの船をk個置く．Bobの質問に対して，Aliceが嘘を言った時の番号を答える．</p>

<h1>考察</h1>

<p>どの質問までかを2分探索する．この探索に対してのvectorを作り，それぞれの区間に船が何個入るかを出す．区間を見たいので，端の0のn+1を追加する．この個数がkをこえるかこえないかで判断する．計算量は，探索でlog(n)，vectorのsortにn*log(n)かかるので，全体でO(n*log(n)<sup>2</sup>)．</p>

<h1>Code</h1>

<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;
#include &lt;set&gt;

#define REP(i,k,n) for(int i=k;i&lt;n;i++)
#define rep(i,n) for(int i=0;i&lt;n;i++)
#define INF 1&lt;&lt;30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

int main() {
    int n,k,a;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; a;

    int m;
    cin &gt;&gt; m;

    vector&lt;int&gt; v(m);
    rep(i,m) {
        cin &gt;&gt; v[i];
    }

    int l = 0,r = m+1;
    while(r - l &gt; 1) {
        int mid = (l+r)/2;
        vector&lt;int&gt; t(v.begin(),v.begin()+mid);

        t.push_back(0);
        t.push_back(n+1);
        sort(t.begin(),t.end());

        int cnt = 0;
        rep(j,t.size()-1) {
            int d = t[j+1] - t[j];
            cnt += d/(a+1);
        }

        if(cnt &gt;= k) {
            l = mid;
        }
        else {
            r = mid;
        }
    }

    if(l == m) cout &lt;&lt; -1 &lt;&lt; endl;
    else cout &lt;&lt; l+1 &lt;&lt; endl;

    return 0;
}
</code></pre>
]]></content>
  </entry>
  
</feed>
