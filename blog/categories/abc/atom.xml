<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: abc | ry0u_ydのblog]]></title>
  <link href="http://ry0u.github.io/blog/categories/abc/atom.xml" rel="self"/>
  <link href="http://ry0u.github.io/"/>
  <updated>2016-09-03T02:19:57+09:00</updated>
  <id>http://ry0u.github.io/</id>
  <author>
    <name><![CDATA[ry0u_yd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ABC014D 閉路]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/03/abc014d-bi-lu/"/>
    <updated>2016-04-03T18:09:24+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/03/abc014d-bi-lu</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://abc014.contest.atcoder.jp/tasks/abc014_4">D: 閉路 - AtCoder Beginner Contest 014 | AtCoder</a></h4><p>(null)</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

木に {% m %} 1 {% em %}本付け加えて出来る閉路は，つなげる {% m %} 2 {% em %}点とその {% m %} 2 {% em %}点の最小共通祖先で出来る三角形になるはずである．よって， {% m %} LCA(a, b) {% em %}を求めた後に，その三角形の長さを出力した．長さは {% m %} LCA {% em %}を求める際に深さが出ているので，そこから出せる．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

vector<int> G[100005];
int root;

int parent[20][100005];
int depth[100005];

void dfs(int v, int p, int d) {
	parent[0][v] = p;
	depth[v] = d;
	rep(i, G[v].size()) {
		if(G[v][i] != p) dfs(G[v][i], v, d+1);
	}
}

void init(int V) {
	dfs(root, -1, 0);
	for(int k = 0; k + 1 < 20; k++) {
		rep(v, V) {
			if(parent[k][v] < 0) parent[k + 1][v] = -1;
			else parent[k + 1][v]= parent[k][parent[k][v]];
		}
	}
}

int lca(int u, int v) {
	if(depth[u] > depth[v]) swap(u, v);
	rep(k, 20) {
		if((depth[v] - depth[u]) >> k & 1) {
			v = parent[k][v];
		}
	}
	if(u == v) return u;
	for(int k = 20 - 1; k >= 0; k--) {
		if(parent[k][u] != parent[k][v]) {
			u = parent[k][u];
			v = parent[k][v];
		}
	}
	return parent[0][u];
}

int main() {
	int n;
	cin >> n;

	rep(i, n-1) {
		int x, y;
		cin >> x >> y;

		x--; y--;
		G[x].push_back(y);
		G[y].push_back(x);
	}

	root = 0;
	init(n);

	int Q;
	cin >> Q;

	rep(q, Q) {
		int a, b;
		cin >> a >> b;

		a--; b--;

		int par = lca(a, b);

		cout << (depth[a] - depth[par]) + (depth[b] - depth[par]) + 1 << endl;
	}

	return 0;
}
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC013D 阿弥陀]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/03/abc013d-a-mi-tuo/"/>
    <updated>2016-04-03T17:49:54+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/03/abc013d-a-mi-tuo</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://abc013.contest.atcoder.jp/tasks/abc013_4">D: 阿弥陀 - AtCoder Beginner Contest 013 | AtCoder</a></h4><p>(null)</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

まず一回アミダをシュミレーションする．すると，ゴールする場所 {% m %} iをj {% em %}に変える関数が作れる．これを遷移行列にして行列類乗だ！と思ったが， {% m %} N \leq 10 ^5 {% em %}で {% m %} D {% em %}は {% m %} logD {% em %}に落ちるが結果{% m %} N ^3 logD {% em %}となってしまい意味が無い．  
そもそも行列で持つ必要がない．ダブリングで {% m %} D {% em %}を {% m %} logD {% em %}に落として， {% m %} O(N logN logD) {% em %}．  
resをmapで作ってしまい {% m %} logN {% em %}が余計にかかる．変に {% m %} log {% em %}をつけて落ちることがあるので気をつけたい．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int n, m, d;
	cin >> n >> m >> d;

	vector<int> a(m);
	rep(i, m) cin >> a[i];

	vector<int> v(n);
	rep(i, n) v[i] = i;

	rep(i, m) {
		swap(v[a[i]-1], v[a[i]]);
	}

	map<int, int> res;
	rep(i, n) {
		res[v[i]] = i;
	}

	vector<int> next(n), cur(n);
	rep(i, n) cur[i] = i;
	while(d) {
		if(d & 1) {
			rep(i, n) next[i] = res[cur[i]];
			rep(i, n) cur[i] = next[i];
		}

		rep(i, n) next[i] = res[res[i]];
		rep(i, n) res[i] = next[i];

		d /= 2;
	}

	rep(i, n) {
		cout << cur[i] + 1 << endl;
	}

	return 0;
}
```
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC013C 節制]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/03/abc013c-jie-zhi/"/>
    <updated>2016-04-03T17:31:07+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/03/abc013c-jie-zhi</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://abc013.contest.atcoder.jp/tasks/abc013_3">C: 節制 - AtCoder Beginner Contest 013 | AtCoder</a></h4><p>(null)</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

### 部分点 1

{% math %}
	dp[i][j] := i日目に満足度jの時の食費の最小値
{% endmath %}
として動的計画法．

* 普通の食事 : {% m %} dp[i+1][j+b] = {\rm max} (dp[i+1][j+b], dp[i][j] + a) {% em %}
* 質素の食事 : {% m %} dp[i+1][j+d] = {\rm max} (dp[i+1][j+d], dp[i][j] + c) {% em %}
* 食事抜き : {% m %} dp[i+1][j-e] = {\rm max} (dp[i+1][j-e], dp[i][j]) {% em %}

この {% m %} 3 {% em %}つの遷移がある．食事抜きの場合に{% m %} j-e {% em %}が {% m %} 0 {% em %}より大きい場合に限ることに注意する．

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

ll dp[55][100005];

int main() {
	ll n, h;
	cin >> n >> h;

	ll a, b, c, d, e;
	cin >> a >> b >> c >> d >> e;

	rep(i, 55) {
		rep(j, 100005) {
			dp[i][j] = INF;
		}
	}
	dp[0][h] = 0;

	rep(i, n) {
		rep(j, 100005) {
			if(dp[i][j] == INF) continue;

			if(dp[i+1][j+b] == -1) {
				dp[i+1][j+b] = dp[i][j] + a;
			} else {
				dp[i+1][j+b] = min(dp[i+1][j+b], dp[i][j] + a);
			}

			if(dp[i+1][j+d] == -1) {
				dp[i+1][j+d] = dp[i][j] + c;
			} else {
				dp[i+1][j+d] = min(dp[i+1][j+d], dp[i][j] + c);
			}

			if(j - e > 0) {
				if(dp[i+1][j-e] == -1) {
					dp[i+1][j-e] = dp[i][j];
				} else {
					dp[i+1][j-e] = min(dp[i+1][j-e], dp[i][j]);
				}
			}
		}
	}

	ll ans = INF;
	rep(i, 100005) {
		ans = min(ans, dp[n][i]);
	}

	cout << ans << endl;

	return 0;
}
```

### 部分点2
普通の食事の回数と，質素な食事の回数を決めれば，残りの日にちが食事抜きとなる．これが {% m %} 0 {% em %}より大きければ，そのペアは存在する．その中で{% m %} 普通の食事の回数 * a + 質素な食事の回数 * b {% em %}の最小を取る．

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	ll n, h;
	cin >> n >> h;

	ll a, b, c, d, e;
	cin >> a >> b >> c >> d >> e;
	
	ll ans = INF;
	rep(i, n + 1) {
		rep(j, n + 1) {
			if(i + j > n) continue;
			int k = n - i - j;

			// cout << h << " " << i * b << " " << j * d << " " << k * e << "  ->  " << h + i * b + j * d - k * e << endl;
			if(h + i * b + j * d - k * e > 0) {
				ans = min(ans, i * a + j * c);
			}
		}
	}

	cout << ans << endl;

	return 0;
}
```

### 満点解法
普通の食事の回数を決めれば，後は満足度は単調増加数列になる．この数列の中で初めて {% m %} 0 {% em %}を超える時が，その普通の食事の回数の場合の最小金額である． {% m %} O(N logN) {% em %}．

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1LL<<60
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int n;
	ll h;
	cin >> n >> h;

	ll a, b, c, d, e;
	cin >> a >> b >> c >> d >> e;
	
	ll ans = INF;
	for(ll i = 0; i < n + 1; i++) {
		ll l = -1, r = n - i;
		while(r - l > 1) {
			ll j = (l + r) / 2;
			ll k = n - i - j;

			if(h + i * b + j * d - k * e > 0) {
				r = j;
			} else {
				l = j;
			}
		}

		ll res = i * a + (l + 1) * c;
		ans = min(ans, res);
	}

	cout << ans << endl;

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC012D バスと割けられない運命]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/03/abc012d-basutoge-kerarenaiyun-ming/"/>
    <updated>2016-04-03T17:27:51+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/03/abc012d-basutoge-kerarenaiyun-ming</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://abc012.contest.atcoder.jp/tasks/abc012_4">D: バスと避けられない運命 - AtCoder Beginner Contest 012 | AtCoder</a></h4><p>(null)</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

バス停の数{% m %} N {% em %}が {% m %} 1 \leq N \leq 300 {% em %}と小さいので，愚直にそこを始点とした最短経路を求め，最大値の最小値を取った． {% m %} O(N ^2) {% em %}．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1LL<<60
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

struct edge {
	int from,to;
	ll cost;

	edge(int t, ll c) : to(t),cost(c) {}
	edge(int f, int t, ll c) : from(f),to(t),cost(c) {}

	bool operator<(const edge &e) const {
		return cost < e.cost;
	}
};

vector<edge> G[305];
ll d[305];

void dijkstra(int s, int n) {
	priority_queue<P, vector<P>, greater<P> > que;
	fill(d, d+n, INF);

	d[s] = 0;
	que.push(P(0,s));

	while(que.size()) {
		P p = que.top();
		que.pop();

		int v = p.second;
		if(d[v] < p.first) continue;

		rep(i, G[v].size()) {
			edge e = G[v][i];
			if(d[e.to] > d[v] + e.cost) {
				d[e.to] = d[v] + e.cost;
				que.push(P(d[e.to],e.to));
			}
		}
	}
}


int main() {
	int n, m;
	cin >> n >> m;

	rep(i, m) {
		ll s, t, c;
		cin >> s >> t >> c;
		s--; t--;

		G[s].push_back(edge(t, c));
		G[t].push_back(edge(s, c));
	}

	ll ans = INF;
	rep(i, n) {
		dijkstra(i, n);
		ll res = 0;
		rep(j, n) {
			res = max(res, d[j]);
		}

		ans = min(ans, res);
	}

	cout << ans << endl;

	return 0;
}
```

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABC010D 浮気予防]]></title>
    <link href="http://ry0u.github.io/blog/2016/04/03/abc010d-fu-qi-yu-fang/"/>
    <updated>2016-04-03T17:10:50+09:00</updated>
    <id>http://ry0u.github.io/blog/2016/04/03/abc010d-fu-qi-yu-fang</id>
    <content type="html"><![CDATA[<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://abc010.contest.atcoder.jp/tasks/abc010_4">D: 浮気予防 - AtCoder Beginner Contest 010 | AtCoder</a></h4><p>(null)</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

二重辺連結成分分解をしてrootを{% m %} 0 {% em %}の木にした後に， {% m %} 0 {% em %}から伸びるパスの後に対称が入ればその辺を切る，で出来ると思い実装してみたがサンプルが全然合わない．  
rootを含む閉路があった場合に，そこはrootにまとまってしまうのでそのグループの中での最小が分からないし，そこの切り方によってはrootから出る枝を切る必要が無いかもしれない．  

ギブアップして解説を見た．  
http://www.slideshare.net/chokudai/abc010-35598499  

最大流・最小カット問題になるのか...  
処理を追加後のグラフでは，辺を切るのはそのままで，ログイン出来なくするのは，追加したパスを切れば良いとなる．この考え方は非常に勉強になった．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <stack>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

struct edge {
	int to, cap, rev;
	
	edge(int t, int c, int r) {
		to = t; cap = c; rev = r;
	}
};

vector<edge> G[105];
bool used[105];

void add_edge(int from,int to,int cap) {
	G[from].push_back(edge(to,cap,G[to].size()));
	G[to].push_back(edge(from,0,G[from].size()-1));
}

int dfs(int v,int t,int f) {
	if(v == t) return f;
	used[v] = true;

	rep(i,G[v].size()) {
		edge &e = G[v][i];
		if(!used[e.to] && e.cap > 0) {
			int d = dfs(e.to,t,min(f,e.cap));
			if(d > 0) {
				e.cap -= d;   
				G[e.to][e.rev].cap += d; 
				return d;
			}
		}
	}
	return 0;
}

int max_flow(int s,int t) {
	int flow = 0;
	for(;;) {
		memset(used,0,sizeof(used));
		int f = dfs(s,t,INF);
		if(f == 0) return flow;
		flow += f;
	}
}

int main() {
	int n, g, e;
	cin >> n >> g >> e;

	vector<int> p(g);
	rep(i, g) cin >> p[i];

	rep(i, e) {
		int a, b;
		cin >> a >> b;

		add_edge(a, b, 1);
		add_edge(b, a, 1);
	}

	rep(i, g) {
		add_edge(p[i], n+1, 1);
	}

	int s = 0, t = n + 1;

	cout << max_flow(s, t) << endl;

	return 0;
}
```

]]></content>
  </entry>
  
</feed>
