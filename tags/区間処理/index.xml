<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>区間処理 on ry0u_ydのblog</title>
    <link>http://ry0u.github.io/tags/%E5%8C%BA%E9%96%93%E5%87%A6%E7%90%86/index.xml</link>
    <description>Recent content in 区間処理 on ry0u_ydのblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <atom:link href="http://ry0u.github.io/tags/%E5%8C%BA%E9%96%93%E5%87%A6%E7%90%86/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Codeforces401 div2C Alyona and Spreadsheet</title>
      <link>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2C-Alyona-and-Spreadsheet/</link>
      <pubDate>Sat, 25 Feb 2017 00:46:58 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2C-Alyona-and-Spreadsheet/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://codeforces.com/contest/777/problem/C&#34;&gt;http://codeforces.com/contest/777/problem/C&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;$n$行$m$列の行列が与えられる．列方向の$[l, r]$が広義の単調増加になっている列がある場合は$Yes$を，そうではない場合は$No$を返す．&lt;/p&gt;

&lt;p&gt;一列ずつどこからどこまでが単調増加になっているかの区間を求める．区間の小さい方が同じ場合は$max$を取ってより大きい区間にする．小さい方から順番に見ていく時に，それよりも前に見た区間の右端の方が大きい場合は，覆われている場合なので，今までみた$max$の値を持っておき，その値より小さければ更新する．区間の中に質問の$[l, r]$が含まれているかの問題になるので，$l$を含む区間の最大の右端が$r$より大きければ，その区間が単調増加になっていることが分かる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

int ma[100005], cnt[100005];

int main() {
	cin.tie(0);
    ios::sync_with_stdio(false);

	int n, m;
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;

	vector&amp;lt;ll&amp;gt; pre(m), now(m);
	rep(i, m) cin &amp;gt;&amp;gt; pre[i];

	memset(ma, 0, sizeof(ma));
	memset(cnt, 0, sizeof(cnt));

	rep(i, n) {
		ma[i+1] = i+1;
	}

	rep(i, n-1) {
		rep(j, m) cin &amp;gt;&amp;gt; now[j];

		rep(j, m) {
			if(pre[j] &amp;lt;= now[j]) {
				cnt[j]++;
				int d = ma[i+2-cnt[j]];
				ma[i+2-cnt[j]] = max(d, i + 2);
			} else {
				cnt[j] = 0;
			}
		}
		pre = now;
	}

	int t = 0;
	rep(i, n + 1) {
		t = max(ma[i], t);
		ma[i] = max(ma[i], t);
	}

	int k;
	cin &amp;gt;&amp;gt; k;
	rep(i, k) {
		int l, r;
		cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;

		if(r &amp;lt;= ma[l]) cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
		else cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>