<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dp on ry0u_ydのblog</title>
    <link>http://ry0u.github.io/tags/dp/index.xml</link>
    <description>Recent content in Dp on ry0u_ydのblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <atom:link href="http://ry0u.github.io/tags/dp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>University CodeSprint 2 Sherlocks Array Merging Algorithm</title>
      <link>http://ry0u.github.io/comp/2017-02-22-University-CodeSprint-2-Sherlock%27s-Array-Merging-Algorithm/</link>
      <pubDate>Wed, 22 Feb 2017 15:30:19 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-22-University-CodeSprint-2-Sherlock%27s-Array-Merging-Algorithm/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.hackerrank.com/contests/university-codesprint-2/challenges/sherlocks-array-merging-algorithm&#34;&gt;https://www.hackerrank.com/contests/university-codesprint-2/challenges/sherlocks-array-merging-algorithm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;複数の配列から先頭1つずつを取り，取ったものをsortして$M$の末尾に加える．最終的に$V$と一致する通りを求める．&lt;/p&gt;

&lt;p&gt;$$
    dp[pos][n] := 前回n個取り，pos目まで見た時の組み合わせ
$$&lt;/p&gt;

&lt;p&gt;取る数は必ず広義単調減少となり増えることはない．前回$n$個取った場合に今回$r (0 \leq r \leq n)$個取るとすると，まず$n$個の場所に$r$個を当てはめるために$_{n}C_{r}$通り，また$r$個はどんな順番でも良いので$r$の並び方$r!$通りある．現在$pos$まで見て，$r$個取ったとすると次の遷移は$(pos + r, r)$である．$r$個取る時は，$V$の$[pos, pos + r)$が単調増加になっていなければならないことに注意する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second
#define MOD 1000000007

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

ll dp[1205][1205], up[1205][1205], fact[1205];

ll C[2005][2005];
void combination(int size) {
	for (int i = 0; i &amp;lt; size; i++) C[i][0] = 1LL;
	for (int i = 1; i &amp;lt; size; i++) {
		for (int j = 1; j &amp;lt;= i; j++) {
			C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
		}
	}
}

int n;

ll dfs(int pos, int len) {
	if(len == -1) {
		ll res = 0;
		for(ll i = 1; i &amp;lt;= n &amp;amp;&amp;amp; pos + i &amp;lt;= n; i++) {
			if(up[pos][pos + i - 1]) {
				res += dfs(pos + i, i) % MOD;
				res %= MOD;

			} else break;
		}
		return dp[pos][len] = res;
	} else {
		if(dp[pos][len] != -1) return dp[pos][len];
		if(pos == n) return 1;

		ll res = 0;
		for(ll i = 1; i &amp;lt;= len &amp;amp;&amp;amp; pos + i &amp;lt;= n; i++) {
			if(up[pos][pos + i - 1]) {
				res += (((C[len][len-i] * fact[i]) % MOD) * dfs(pos + i, i)) % MOD;
				res %= MOD;
			} else break;
		}

		return dp[pos][len] = res;
	}
}

int main() {
	cin &amp;gt;&amp;gt; n;

	vector&amp;lt;int&amp;gt; v(n);
	rep(i, n) cin &amp;gt;&amp;gt; v[i];

	combination(1205);
	fact[0] = 1;
	REP(i, 1, 1205) {
		fact[i] = (i * fact[i-1]) % MOD;
	}

	rep(i, n + 1) {
		rep(j, n + 1) {
			dp[i][j] = -1;
			up[i][j] = false;
		}
	}

	rep(i, n) {
		bool flag = true;
		REP(j, i, n) {
			up[i][j] = flag;
			if(j &amp;lt; n-1 &amp;amp;&amp;amp; v[j] &amp;gt; v[j+1]) flag = false;
		}
	}

	cout &amp;lt;&amp;lt; dfs(0, -1) &amp;lt;&amp;lt; endl;

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本番中に解けなかった．悔しい．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SRM342 D1M ReverseResources</title>
      <link>http://ry0u.github.io/comp/2017-02-17-SRM342-D1M-ReverseResources/</link>
      <pubDate>Fri, 17 Feb 2017 22:40:34 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-17-SRM342-D1M-ReverseResources/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=7415&amp;amp;rd=10666&#34;&gt;https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=7415&amp;amp;rd=10666&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文字列$str$を$resources$中の文字列から$1$つ選んで作りたい．$resources$の各文字列にある&amp;rdquo;%s&amp;rdquo;は，$resources$中の任意の文字列に置き換えすることができる．$str$を構成できる組み合わせは何通りか．&lt;/p&gt;

&lt;p&gt;$$
\begin{eqnarray}
    dp[i][j] &amp;amp;:=&amp;amp; [i, j)を構成できる組み合わせ数\\&lt;br /&gt;
    dp2[i][j][k][l] &amp;amp;:=&amp;amp; [i, j)をresources[j][l]まで見て構成できる組み合わせ数
\end{eqnarray}
$$&lt;/p&gt;

&lt;p&gt;区間$[l, r)$に各文字列を当てた場合を全て試す．&amp;rsquo;%s&amp;rsquo;が無い場合は，その区間と割り当てた文字列が完全に一致している場合は$1$，そうでない場合は$0$を返す．ある場合は，$[l, r)$区間のどこまでを$%s$で別の文字列に置き換えるか，$[l, i)$, $[i, r)$に分割する$i$を全て試す．$dp2[l][r][id][pos] += (a * b) % MOD;$にMODを入れないとoverflowする(落ちた)．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define MOD 1000000007

#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int, int&amp;gt; P;

int n;
string s;
vector&amp;lt;string&amp;gt; v;

int dp[55][55], dp2[35][35][55][55];

ll dfs(int l, int r);
ll dfs2(int l, int r, int id, int pos);

ll dfs(int l, int r) {
	if(dp[l][r] != -1) return dp[l][r];
	dp[l][r] = 0;
	rep(i, n) {
		dp[l][r] += dfs2(l, r, i, 0);
		dp[l][r] %= MOD;
	}
	return dp[l][r];
}

ll dfs2(int l, int r, int id, int pos) {
	if(dp2[l][r][id][pos] != -1) return dp2[l][r][id][pos];
	if(pos &amp;gt;= v[id].size()) return 0;

	if(v[id][pos] == &#39;?&#39;) {
		if(pos != v[id].size() - 1) {
			dp2[l][r][id][pos] = 0;
			for(int i = l + 1; i &amp;lt;= r; i++) {
				ll a = dfs(l, i);
				ll b = dfs2(i, r, id, pos + 1);
				dp2[l][r][id][pos] += (a * b) % MOD;
				dp2[l][r][id][pos] %= MOD;
			}
			return dp2[l][r][id][pos];
		} else {
			return dp2[l][r][id][pos] = dfs(l, r);
		}
	} else {
		if(s[l] != v[id][pos]) return 0;
		if(r - l == 1) {
			if(pos == v[id].size()-1) return 1;
			else return 0;
		}
		return dp2[l][r][id][pos] = dfs2(l + 1, r, id, pos + 1);
	}
}

class ReverseResources {
	public:
	int findDecompositions(string str, vector &amp;lt;string&amp;gt; resources) {
		s = str;
		n = resources.size();
		v.clear(); v.resize(n);
		rep(i, n) {
			string t = &amp;quot;&amp;quot;;
			rep(j, resources[i].size()) {
				if(j + 1 &amp;lt; resources[i].size() &amp;amp;&amp;amp; resources[i][j] == &#39;%&#39; &amp;amp;&amp;amp; resources[i][j+1] == &#39;s&#39;) {
					j++;
					t += &amp;quot;?&amp;quot;;
				} else {
					t += resources[i][j];
				}
			}
			v[i] = t;
		}

		memset(dp, -1, sizeof(dp));
		memset(dp2, -1, sizeof(dp2));
		return dfs(0, s.size());
	}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;hugo&#34;&gt;hugo&lt;/h2&gt;

&lt;p&gt;エスケープで色々問題が起こっている．どうすればよいか&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数式中の改行(&lt;a href=&#34;http://blog.tonytsai.name/blog/2017-01-05-test-mathjax/&#34;&gt;http://blog.tonytsai.name/blog/2017-01-05-test-mathjax/&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aaa&lt;/code&gt;inline code中のbracket&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SRM314 D1M LandAndSea</title>
      <link>http://ry0u.github.io/comp/2017-02-17-SRM341-D1M-LandAndSea/</link>
      <pubDate>Fri, 17 Feb 2017 21:46:48 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-17-SRM341-D1M-LandAndSea/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=7512&#34;&gt;https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=7512&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;島が&amp;rsquo;.&amp;lsquo;，海が&amp;rsquo;.&amp;lsquo;で表された盤面が与えられる．島は上下左右斜めで隣接しているとき，同じグループの島となる．島が島を内包しているとき，内包している島のレベルの$max + 1$がその島のレベルとなる．内包している島を持っていない場合，その島のレベルは$0$である．各レベルの島の数を返す．&lt;/p&gt;

&lt;p&gt;まずレベルは考えずに島の内包関係をグラフで表現する．盤面外に出ること無しで，海を伝って他の島に当たった数を保持しておき，その数が最大のものに内包されているとした．内包関係をグラフで表現した後は，トポロジカルソートをしてトポロジカル順序で島のレベルを確定させていった．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair

#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int, int&amp;gt; P;

int h, w;
int id[55][55];
int dx[4] = { 1, 0,-1, 0};
int dy[4] = { 0, 1, 0,-1};
int dx2[8] = { 1, 1, 0,-1,-1,-1, 0, 1};
int dy2[8] = { 0, 1, 1, 1, 0,-1,-1,-1};

bool inside(int y, int x) {
	if(0 &amp;lt;= y &amp;amp;&amp;amp; y &amp;lt; h &amp;amp;&amp;amp; 0 &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt; w) return true;
	return false;
}

int counter = 0;
bool visited[55][55];
vector&amp;lt;string&amp;gt; s;
void dfs(int y, int x) {
	rep(i, 8) {
		int ny = y + dy2[i];
		int nx = x + dx2[i];

		if(inside(ny, nx) &amp;amp;&amp;amp; !visited[ny][nx] &amp;amp;&amp;amp; s[ny][nx] == &#39;x&#39;) {
			id[ny][nx] = counter;
			visited[ny][nx] = true;
			dfs(ny, nx);
		}
	}
}

int myid = -1;
bool outflag = false;
map&amp;lt;int, int&amp;gt; m;
void dfs2(int y, int x) {
	if(outflag) return;

	rep(i, 4) {
		int ny = y + dy[i];
		int nx = x + dx[i];
		

		if(visited[ny][nx]) continue;
		if(!inside(ny, nx)) {
			outflag = true;
			return;
		}

		if(s[ny][nx] == &#39;.&#39;) {
			visited[ny][nx] = true;
			dfs2(ny, nx);
		} else {
			int t = id[ny][nx];

			if(t != myid) {
				visited[ny][nx] = true;
				m[id[ny][nx]]++;
			} else {
				visited[ny][nx] = true;
				dfs2(ny, nx);
			}

		}
	}
}

vector&amp;lt;int&amp;gt; G[55 * 55], out;
bool used[55 * 55];
void tposo(int cur) { // topologicalsort-dfs
	used[cur] = true;
	rep(i,G[cur].size()) {
		int v = G[cur][i];
		if(!used[v]) tposo(v);
	}

	out.push_back(cur);
}


class LandAndSea {
	public:
	vector &amp;lt;int&amp;gt; howManyIslands(vector &amp;lt;string&amp;gt; seaMap) {
		s = seaMap;
		h = seaMap.size();
		w = seaMap[0].size();

		counter = 0;
		memset(id, -1, sizeof(id));
		memset(visited, false, sizeof(visited));
		rep(i, 55) G[i].clear();
		out.clear();

		vector&amp;lt;P&amp;gt; start;
		rep(i, h) {
			rep(j, w) {
				if(visited[i][j]) continue;
				if(s[i][j] == &#39;.&#39;) continue;

				id[i][j] = counter;
				visited[i][j] = true;
				start.push_back(mp(i, j));

				dfs(i, j);
				counter++;
			}
		}

		int indeg[55 * 55];
		memset(indeg, 0, sizeof(indeg));

		rep(i, counter) {
			m.clear();
			myid = i;
			outflag = false;
			memset(visited, false, sizeof(visited));

			visited[start[i].fi][start[i].se] = true;
			dfs2(start[i].fi, start[i].se);

			if(outflag) continue;
			int parent = -1, vmax = 0;

			each(it, m) {
				if(it-&amp;gt;second &amp;gt; vmax) {
					parent = it-&amp;gt;first;
					vmax = it-&amp;gt;second;
				}
			}

			G[i].push_back(parent);
			indeg[parent]++;
		}

		memset(used, 0, sizeof(used));
		rep(i, counter) {
			if(!used[i]) tposo(i);
		}
		reverse(out.begin(), out.end());

		map&amp;lt;int, int&amp;gt; ans;
		vector&amp;lt;int&amp;gt; dp(counter);
		rep(i, out.size()) {
			int id = out[i];
			ans[dp[id]]++;
			rep(j, G[id].size()) {
				dp[G[id][j]] = max(dp[G[id][j]], dp[id] + 1);
			}
		}

		vector&amp;lt;int&amp;gt; res(ans.size());
		rep(i, ans.size()) res[i] = ans[i];
		return res;
	}
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>