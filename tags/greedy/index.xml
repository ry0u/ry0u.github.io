<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Greedy on ry0u_ydのblog</title>
    <link>http://ry0u.github.io/tags/greedy/index.xml</link>
    <description>Recent content in Greedy on ry0u_ydのblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <atom:link href="http://ry0u.github.io/tags/greedy/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Codeforces402 div2C Dishonest Sellers</title>
      <link>http://ry0u.github.io/comp/2017-02-27-Codeforces402-div2C-Dishonest-Sellers/</link>
      <pubDate>Mon, 27 Feb 2017 22:35:26 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-27-Codeforces402-div2C-Dishonest-Sellers/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://codeforces.com/contest/779/problem/C&#34;&gt;http://codeforces.com/contest/779/problem/C&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;$n$個のもの全てを今週と来週に分けて買いたい．$i$番目の今週の値段は$a_i$で，来週の値段は$b_i$である．少なくとも今週に$k$個買わなければならない時に，必要となる最小の金額を求める．&lt;/p&gt;

&lt;p&gt;基本的に来週になると高くなるものは今週買い，安くなるものは来週買った方が良い．今週買った方が良いものが$k$個未満の場合は，来週買った方が良いものから安くなる金額が少ない順に買う．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

bool flag[200005];

int main() {
	int n, k;
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;

	vector&amp;lt;P&amp;gt; v(n);
	rep(i, n) cin &amp;gt;&amp;gt; v[i].fi;
	rep(i, n) cin &amp;gt;&amp;gt; v[i].se;

	memset(flag, 0, sizeof(flag));
	priority_queue&amp;lt;P, vector&amp;lt;P&amp;gt;, greater&amp;lt;P&amp;gt; &amp;gt; que;
	rep(i, n) {
		if(v[i].fi - v[i].se &amp;gt; 0) {
			que.push(mp(v[i].fi - v[i].se, i));
			flag[i] = true;
		}
	}

	int now = n - que.size();
	while(now &amp;lt; k) {
		P p = que.top(); que.pop();
		now++;
		flag[p.se] = false;
	}
	
	ll ans = 0;
	rep(i, n) {
		if(flag[i]) ans += v[i].se;
		else ans += v[i].fi;
	}

	cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Codeforces401 div2D Could of Hashtags</title>
      <link>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2D-Could-of-Hashtags/</link>
      <pubDate>Sat, 25 Feb 2017 22:19:48 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2D-Could-of-Hashtags/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://codeforces.com/contest/777/problem/D&#34;&gt;http://codeforces.com/contest/777/problem/D&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;与えられる$n$個の文字列が辞書順になるように文字を調整したい．できることは末尾から文字を消していくことで，辞書順にするために消す必要がある文字数を最小にして出力する．&lt;/p&gt;

&lt;p&gt;消す文字を最小化したいので，残す文字を最大化する．逆からみて，残せるだけ残していくようにしたらACした．$i+1$番目まで確定していて，$i$番目を決める時，長さの短い方に合わせて文字を見ていき，辞書順で小さい場合は$i$番目はそのまま，辞書順で大きい場合は$i$番目と$i+1$番目の先頭からの共通文字列とする．全て同じ文字だった場合は，$i$番目と$i+1$番目の長さが短い方を優先する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

int main() {
	int n;
	cin &amp;gt;&amp;gt; n;

	vector&amp;lt;string&amp;gt; v(n);
	rep(i, n) cin &amp;gt;&amp;gt; v[i];

	vector&amp;lt;string&amp;gt; ans(n);
	ans[n-1] = v[n-1];

	for(int i = n - 2; i &amp;gt;= 0; i--) {
		if(ans[i+1] == &amp;quot;#&amp;quot;) {
			ans[i] =  &amp;quot;#&amp;quot;;
			continue;
		}

		string t = &amp;quot;&amp;quot;;
		int flag = 0;
		rep(j, min(ans[i+1].size(), v[i].size())) {
			if(v[i][j] == ans[i+1][j]) {
				t += v[i][j];
				continue;
			}
			else if(v[i][j] &amp;lt; ans[i+1][j]) {
				flag = 1;
				break;
			} else {
				flag = 2;
				break;
			}
		}

		if(flag == 0) ans[i] = (v[i].size() &amp;lt;= ans[i+1].size() ? v[i] : ans[i+1]);
		if(flag == 1) ans[i] = v[i];
		if(flag == 2) ans[i] = t;
	}

	rep(i, n) cout &amp;lt;&amp;lt; ans[i] &amp;lt;&amp;lt; endl;


	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>