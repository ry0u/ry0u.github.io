<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stack on ry0u_ydのblog</title>
    <link>http://ry0u.github.io/tags/stack/index.xml</link>
    <description>Recent content in Stack on ry0u_ydのblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <atom:link href="http://ry0u.github.io/tags/stack/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Codeforces401 div2E Hanoi Factory</title>
      <link>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2E-Hanoi-Factory/</link>
      <pubDate>Sat, 25 Feb 2017 22:49:03 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2E-Hanoi-Factory/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://codeforces.com/contest/777/problem/E&#34;&gt;http://codeforces.com/contest/777/problem/E&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;内周の半径を$a_i$，外周の半径を$b_i$，高さを$h_i$とした輪っかがある．$i$番目の上に$j$番目が乗ることができる条件は$b_j \leq b_i$かつ，$b_j &amp;gt; a_i$である．内周の半径より，上に乗せようと考えている外周の半径が小さい場合は，重ねることができない．高さの合計の最大値を求めよ．&lt;/p&gt;

&lt;p&gt;まず条件より外周が大きい順，さらに外周が同じ場合は内周が大きい順にsortすると良さそう．stackで現在乗せているものを表す．stackのtopと$i$番目を比較して，乗る状態であるならば乗せる．そうでないならば，乗せられる状態になるまでstackをpopする．このようにすることで，以前の高さの和を持っておくことができ，乗せられないものが出ても対応できる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;
typedef pair&amp;lt;P, int&amp;gt; PI;

int main() {
	int n;
	cin &amp;gt;&amp;gt; n;

	vector&amp;lt;PI&amp;gt; v(n);
	rep(i, n) cin &amp;gt;&amp;gt; v[i].fi.se &amp;gt;&amp;gt; v[i].fi.fi &amp;gt;&amp;gt; v[i].se;

	sort(v.begin(), v.end(), greater&amp;lt;PI&amp;gt;());

	ll ans = 0, sum = 0;
	stack&amp;lt;PI&amp;gt; st;
	rep(i, n) {
		while(st.size()) {
			PI p = st.top();
			if(v[i].fi.fi &amp;lt;= p.fi.fi &amp;amp;&amp;amp; v[i].fi.fi &amp;gt; p.fi.se) break;

			sum -= p.se;
			st.pop();
		}

		sum += v[i].se;
		st.push(v[i]);

		ans = max(ans, sum);
	}

	cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>