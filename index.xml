<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ry0u_ydのblog</title>
    <link>http://ry0u.github.io/index.xml</link>
    <description>Recent content on ry0u_ydのblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Wed, 05 Apr 2017 14:03:08 +0900</lastBuildDate>
    <atom:link href="http://ry0u.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Multigrid Reduction in Time</title>
      <link>http://ry0u.github.io/post/2017-04-05-Multigrid-Reduction-in-Time/</link>
      <pubDate>Wed, 05 Apr 2017 14:03:08 +0900</pubDate>
      
      <guid>http://ry0u.github.io/post/2017-04-05-Multigrid-Reduction-in-Time/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;1次元熱拡散問題をMultigrid Reduction in Timeで解く&lt;/p&gt;

&lt;h2 id=&#34;1次元熱拡散&#34;&gt;1次元熱拡散&lt;/h2&gt;

&lt;p&gt;1次元熱伝導方程式は$u:$温度ベクトル，$k:$熱拡散係数, $S:$熱のわき出しとすると以下の式で表される．
$$
\displaystyle \frac{\delta u}{\delta t} = k \frac{\delta ^2 u}{\delta x ^2} + S
$$&lt;/p&gt;

&lt;p&gt;これを時間を前進，空間を二次中心差分の陽解法で離散化する．上付き文字は時間，下付き文字は空間のindexである．&lt;/p&gt;

&lt;p&gt;$$
    \frac{u^{n+1}_{i}-u^{n}_{i}}{\Delta t} = k \frac{u ^{n}_{i-1} - 2u^{n}_{i} + u^{n}_{i+1}}{\Delta x ^2} + S^{n}_i
$$&lt;/p&gt;

&lt;p&gt;整理すると
$$
\begin{eqnarray}
    u^{n+1}_{i} &amp;amp;=&amp;amp; \frac{k \Delta t}{\Delta x^2} (u ^{n}_{i-1} - 2u^{n}_{i} + u^{n}_{i+1}) + u^n_{i} + S^{n}_i\Delta t\\&lt;br /&gt;
                 &amp;amp;=&amp;amp; \frac{k \Delta t}{\Delta x^2} u^{n}_{i-1} + (1 - \frac{2k\Delta t}{\Delta x^2}) u^{n}_{i} + \frac{k \Delta t}{\Delta x^2} u^{n}_{i+1} + S^{n}_i\Delta t
\end{eqnarray}
$$&lt;/p&gt;

&lt;p&gt;これをディリクレ境界条件で行列を用いて表すと以下のようになる
$$
\left(
    \begin{array}{c}
        u^{n+1}_{0} \\&lt;br /&gt;
        u^{n+1}_{1} \\&lt;br /&gt;
        u^{n+1}_{2} \\&lt;br /&gt;
        u^{n+1}_{3} \\&lt;br /&gt;
        \vdots \\&lt;br /&gt;
        u^{n+1}_{N} \\&lt;br /&gt;
    \end{array}
\right) = \left(
    \begin{array}{cccccc}
        1 &amp;amp;   &amp;amp;   &amp;amp;   &amp;amp;  &amp;amp;   \\&lt;br /&gt;
        \frac{k \Delta t}{\Delta x^2} &amp;amp; -\frac{2k \Delta t}{\Delta x^2} &amp;amp; \frac{k \Delta t}{\Delta x^2} &amp;amp;   &amp;amp;  &amp;amp;   \\&lt;br /&gt;
          &amp;amp; \frac{k \Delta t}{\Delta x^2} &amp;amp; -\frac{2k \Delta t}{\Delta x^2} &amp;amp; \frac{k \Delta t}{\Delta x^2} &amp;amp;  &amp;amp;   \\&lt;br /&gt;
        &amp;amp;  &amp;amp; \frac{k \Delta t}{\Delta x^2} &amp;amp; -\frac{2k \Delta t}{\Delta x^2} &amp;amp; \frac{k \Delta t}{\Delta x^2} &amp;amp; \\&lt;br /&gt;
          &amp;amp;   &amp;amp;   &amp;amp;   &amp;amp; \ddots &amp;amp;  \\&lt;br /&gt;
          &amp;amp;   &amp;amp;   &amp;amp;   &amp;amp;  &amp;amp; 1 \\&lt;br /&gt;
    \end{array}
\right) \left(
    \begin{array}{c}
        u^{n+1}_{0} \\&lt;br /&gt;
        u^{n+1}_{1} \\&lt;br /&gt;
        u^{n+1}_{2} \\&lt;br /&gt;
        u^{n+1}_{3} \\&lt;br /&gt;
        \vdots \\&lt;br /&gt;
        u^{n+1}_{N} \\&lt;br /&gt;
    \end{array}
\right) + \left(
    \begin{array}{c}
        S^{n+1}_{0}\Delta t \\&lt;br /&gt;
        S^{n+1}_{1}\Delta t \\&lt;br /&gt;
        S^{n+1}_{2}\Delta t \\&lt;br /&gt;
        S^{n+1}_{3}\Delta t \\&lt;br /&gt;
        \vdots \\&lt;br /&gt;
        S^{n+1}_{N}\Delta t \\&lt;br /&gt;
    \end{array}
\right)
$$&lt;/p&gt;

&lt;p&gt;この係数行列を$\Phi$, 熱のわき出しを$g$を用いて表せば，$u^{n+1} = \Phi u^{n} + g^n$となる．&lt;/p&gt;

&lt;h2 id=&#34;multigrid-reduction-in-time&#34;&gt;Multigrid Reduction in Time&lt;/h2&gt;

&lt;p&gt;タイムステップ$T$まで求めたいとする．$T$が巨大で逐次に1timestepずつ進めることが困難な場合を想定する．これをある区間幅$m$で依存関係を切り並列で行う．依存関係を切っているので，誤差が生じる．この誤差を時間進展が大きく，問題サイズが小さい問題を解き，その時の解を使って補正する．これを誤差が十分に小さくなるまで行う反復解法である．&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;TODO:時間進展の図を作る&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;この時間進展を$-\Phi u^{n} + u^{n+1} = g^n$と移項し，行列を用いて表すと以下のようになる．下付き文字は時間のindexとなっていること，初期値が熱のわき出しとなっていることに注意する($u_0 = g_0$)．&lt;/p&gt;

&lt;p&gt;$$
A(\mathbf{u}) = \left( \begin{array}{cccc}
I &amp;amp; &amp;amp; &amp;amp; \\&lt;br /&gt;
-\Phi &amp;amp; I &amp;amp; &amp;amp; \\&lt;br /&gt;
 &amp;amp; \ddots &amp;amp; \ddots &amp;amp; \\&lt;br /&gt;
 &amp;amp; &amp;amp; -\Phi&amp;amp; I \\&lt;br /&gt;
\end{array} \right) \left( \begin{array}{c}
u_0 \\&lt;br /&gt;
u_1 \\&lt;br /&gt;
\cdots \\&lt;br /&gt;
u_T \\&lt;br /&gt;
\end{array} \right) = \left( \begin{array}{c}
g_0 \\&lt;br /&gt;
g_1 \\&lt;br /&gt;
\cdots \\&lt;br /&gt;
g_T \\&lt;br /&gt;
\end{array} \right) = \mathbf{g}
$$&lt;/p&gt;

&lt;p&gt;これを粗いレベル$\Delta$に落とす．$T_{\Delta} = \displaystyle \frac{T}{m}$, $\Delta t = m\delta t$とし，この問題を解き，上のレベルの誤差を補正する．
$$
A_{\Delta}(\mathbf{u}_{\Delta}) = \left( \begin{array}{cccc}
I &amp;amp; &amp;amp; &amp;amp; \\&lt;br /&gt;
-\Phi_{\Delta} &amp;amp; I &amp;amp; &amp;amp; \\&lt;br /&gt;
 &amp;amp; \ddots &amp;amp; \ddots &amp;amp; \\&lt;br /&gt;
 &amp;amp; &amp;amp; -\Phi_{\Delta}&amp;amp; I \\&lt;br /&gt;
\end{array} \right) \left( \begin{array}{c}
u_{_{\Delta}, 0} \\&lt;br /&gt;
u_{_{\Delta}, 1} \\&lt;br /&gt;
\cdots \\&lt;br /&gt;
u_{_{\Delta}, T_{\Delta}} \\&lt;br /&gt;
\end{array} \right) = \left( \begin{array}{c}
g_{_{\Delta}, 0} \\&lt;br /&gt;
g_{_{\Delta}, 1} \\&lt;br /&gt;
\cdots \\&lt;br /&gt;
g_{_{\Delta}, T_{\Delta}} \\&lt;br /&gt;
\end{array} \right) = \mathbf{g}_{\Delta}
$$&lt;/p&gt;

&lt;p&gt;ここで時間進展において，$F$-$Point$と$C$-$Point$を定義する．$C$-$Point$は格子点の事である．ここで区間幅を$m$とすると，$C$-$Point$となるのは，$u_{0}$, $u_{m}$, $u_{2m}$, $&amp;hellip;$である．$F$-$Point$とは$C$-$Point$以外の点である．&lt;/p&gt;

&lt;p&gt;次に2つの緩和$F$-$relaxation$と$C$-$relaxation$を定義する．$F$-$relaxation$は$F-Point$を更新する緩和で，$C$-$relaxation$は$C$-$Point$を更新する緩和である．最初の区間だけに注目すれば下のようになる．&lt;/p&gt;

&lt;p&gt;$$
\begin{eqnarray}
    F-relaxation &amp;amp;:=&amp;amp; u_{0} \xrightarrow{\Phi} u_{1} \xrightarrow{\Phi} &amp;hellip; u_{m-2} \xrightarrow{\Phi} u_{m-1} \\&lt;br /&gt;
    C-relaxation &amp;amp;:=&amp;amp; u_{m-1} \xrightarrow{\Phi} u_{m}
\end{eqnarray}
$$&lt;/p&gt;

&lt;p&gt;アルゴリズムは&lt;a href=&#34;http://computation.llnl.gov/projects/parallel-time-integration-multigrid/strand2d-pit.pdf&#34;&gt;http://computation.llnl.gov/projects/parallel-time-integration-multigrid/strand2d-pit.pdf&lt;/a&gt; のp3そのままである．(これを言ったらそもそもこの記事全体が，この論文そのものだがそこは気にしない)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;$FCF$-$relaxation$をする．($F$-$relaxation$, $C$-$relaxation$, $F$-$relaxation$)&lt;/li&gt;
&lt;li&gt;粗いレベル$\Delta$を作る． $u_{\Delta, i} \leftarrow u_{mi}$, $r_{\Delta, i} \leftarrow g_{mi} - A(u)_{mi} \ \ \ \ \ \mbox{for}\ i = 0, &amp;hellip;, T_{\Delta}$&lt;/li&gt;
&lt;li&gt;$A_{\Delta}(\mathbf{v}_{\Delta}) = A_{\Delta}(\mathbf{u}_{\Delta}) + \mathbf{r}_{\Delta}$を$v_{\Delta}$について解く&lt;/li&gt;
&lt;li&gt;errorを計算する．$e_{\Delta} = v_{\Delta} - u_{\Delta}$&lt;/li&gt;
&lt;li&gt;上のレベルに補正する．$u_{mi} = u_{mi} + e_{\Delta, i}$&lt;/li&gt;
&lt;li&gt;上のレベルで$F$-$relaxation$をする．&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1について，まず初めに$F$をすると，右隣の$C$-$Point$に誤差がたまる．しかし，$F$だけをしても次の格子へ値が伝搬しないため，$C$をして格子点を更新する．この状態では$C$-$Point$の右隣の$F$-$Point$に誤差がたまるが，ここで誤差がたまっても下のレベルに落ちないので，もう一回$F$をして，誤差を次の$C$-$Point$にためる．そのレベルで格子点であれば，必ず下のレベルに落ちるためである．&lt;/p&gt;

&lt;p&gt;2について，ここで粗いレベルを作る．現在のレベルの$m$の倍数を抜き出す．ここで多段レベルであれば，1へ戻る．レベルMAXになった時は各プロセスが1timestepしか持たない場合である．その場合は，直接解いてしまう．実装の面からすれば，$Gather$してから，問題を解き，$Scatter$する．&lt;/p&gt;

&lt;p&gt;3について，ここで未知の変数は$\mathbf{v}_{\Delta}$のみである．$A_{\Delta}$が二重対角のため前進代入で解ける．&lt;/p&gt;

&lt;p&gt;後はどれだけ補正すれば良いかのerrorを計算し，上のレベルに補正する．補正した後は$F$-$relaxation$をすることによって，上のレベルの$A(\mathbf{u})$を更新する．&lt;/p&gt;

&lt;p&gt;全timestepの誤差が十分に小さくなるまでにこのサイクルを続ける．このサイクルの回数は$m$に依存しているため，同じ$m$であれば，求めたいtimestep, 並列度が変わっても回数は変わらない．(当然時間は変わる)&lt;/p&gt;

&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;

&lt;p&gt;全部貼ると長いのでmainだけ貼る．後はgithubに上げておく&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
#include &amp;lt;mpi.h&amp;gt;

#include &amp;quot;Parameter.hpp&amp;quot;
#include &amp;quot;Mat.hpp&amp;quot;
#include &amp;quot;Generator.hpp&amp;quot;
#include &amp;quot;Relaxation.hpp&amp;quot;
#include &amp;quot;Debugger.hpp&amp;quot;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)

using namespace std;

int main() {
	int myid, numprocs;
	MPI_Init(NULL, NULL);

	MPI_Status status;
	MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;myid);
	MPI_Comm_size(MPI_COMM_WORLD, &amp;amp;numprocs);

	int MAX_L = get_MAX_Level();

	if(myid == 0) {
		cout &amp;lt;&amp;lt; &amp;quot;============ Parameter ============&amp;quot; &amp;lt;&amp;lt; endl;
		cout &amp;lt;&amp;lt; &amp;quot;N:&amp;quot; &amp;lt;&amp;lt; N &amp;lt;&amp;lt; &amp;quot; M:&amp;quot; &amp;lt;&amp;lt; M &amp;lt;&amp;lt; &amp;quot; P:&amp;quot; &amp;lt;&amp;lt; P &amp;lt;&amp;lt; &amp;quot; T:&amp;quot; &amp;lt;&amp;lt; T &amp;lt;&amp;lt; &amp;quot; MAX_L:&amp;quot; &amp;lt;&amp;lt; MAX_L &amp;lt;&amp;lt; endl;
	}

	// local [level][time][place]
	Mat local_u[MAX_L], local_Au[MAX_L], local_r[MAX_L], local_g[MAX_L], local_v[MAX_L];

	int local_m = M;
	int local_step = T / P; // (T / P) - 各プロセスが担当するstep数
	double local_dt = dt;

	rep(i, MAX_L) {
		local_u[i] = Mat(local_step, Vec(N));
		local_Au[i] = Mat(local_step, Vec(N));
		local_r[i] = Mat(local_step, Vec(N));
		local_g[i] = Mat(local_step, Vec(N));
		local_v[i] = Mat(local_step, Vec(N));
	}

	if(myid == 0) { // initialize [0, 0, ..., 0, 100]
		local_u[0][0][N-1] = 100;
		rep(i, MAX_L) local_g[i][0] = local_u[0][0];
	}

int cycle_cnt = 0;
while(true) {
	if(myid == 0) {
		cout &amp;lt;&amp;lt; &amp;quot;========================== MGRIT ======================== cnt:&amp;quot; &amp;lt;&amp;lt; cycle_cnt &amp;lt;&amp;lt; endl;
	}

	// -------------- V - Cycle Down ------------
	rep(level, MAX_L - 1) {
		Mat phi = Generator::phi(local_dt);

		F_relaxation(phi, local_u[level], local_step, local_m);
		C_relaxation(phi, local_u[level], local_step, local_m);
		F_relaxation(phi, local_u[level], local_step, local_m);

		MPI_Barrier(MPI_COMM_WORLD);

		local_Au[level] = Generator::global_Au(phi, local_u[level], local_step);

		// next level
		local_u[level + 1] = Generator::level_down(local_u[level], local_step);
		// local_r[level + 1] = sub(local_g[level], local_Au[level]);
		rep(i, local_step / M) {
			rep(j, N) {
				local_r[level + 1][i][j] = local_g[level][i * M][j] - local_Au[level][i * M][j];
			}
		}

		MPI_Barrier(MPI_COMM_WORLD);

		local_step /= M;
		local_dt *= M;
	}

	if(myid == 0) { // process 0に集約するために拡張
		local_u[MAX_L - 1].resize(P);
		REP(i, 1, P) {
			local_u[MAX_L - 1][i] = Vec(N);
		}
	}
	
	double tmp_u[P][N];
	memset(tmp_u, 0, sizeof(tmp_u));
	rep(i, N) tmp_u[0][i] = local_u[MAX_L-1][0][i];

	MPI_Barrier(MPI_COMM_WORLD);
	MPI_Gather(&amp;amp;tmp_u[0][0], N, MPI_DOUBLE, &amp;amp;tmp_u[0][0], N, MPI_DOUBLE, 0, MPI_COMM_WORLD);
	MPI_Barrier(MPI_COMM_WORLD);

	double r_delta[P][N];
	memset(r_delta, 0, sizeof(r_delta));
	rep(i, N) r_delta[0][i] = local_r[MAX_L-1][0][i];

	MPI_Barrier(MPI_COMM_WORLD);
	MPI_Gather(&amp;amp;r_delta[0][0], N, MPI_DOUBLE, &amp;amp;r_delta[0][0], N, MPI_DOUBLE, 0, MPI_COMM_WORLD);
	MPI_Barrier(MPI_COMM_WORLD);

	//本来ならばgも集めるが，今回はg0 = u0, その他は全て0のため結果が変わらないので飛ばす
	// double tmp_g[P][N];
	// memset(tmp_g, 0, sizeof(tmp_g));
	// rep(i, N) tmp_g[0][i] = local_g[MAX_L-1][0][i];
	//
	// MPI_Barrier(MPI_COMM_WORLD);
	// MPI_Gather(&amp;amp;tmp_g[0][0], N, MPI_DOUBLE, &amp;amp;tmp_g[0][0], N, MPI_DOUBLE, 0, MPI_COMM_WORLD);
	// MPI_Barrier(MPI_COMM_WORLD);

	if(myid == 0) {
		rep(i, P) {
			rep(j, N) {
				local_u[MAX_L-1][i][j] = tmp_u[i][j];
			}
		}

		Mat MAX_L_phi = Generator::phi(local_dt);

		//ここは直接解いてしまい，このMAX_L-1でのuを決定する
		rep(i, P - 1) {
			local_u[MAX_L-1][i+1] = mul(MAX_L_phi, local_u[MAX_L-1][i]);
		}
		
		local_Au[MAX_L-1] = Generator::local_Au(MAX_L_phi, local_u[MAX_L-1], P);

		Mat right_vec(P, Vec(N));
		rep(i, P) {
			rep(j, N) {
				right_vec[i][j] = local_Au[MAX_L-1][i][j] + r_delta[i][j];
			}
		}

		local_v[MAX_L-1][0] = right_vec[0];
		rep(i, P - 1) {
			local_v[MAX_L-1][i+1] = add(right_vec[i+1], mul(MAX_L_phi, local_v[MAX_L-1][i]));
		}
		
		Mat error(P, Vec(N));
		rep(i, P) {
			rep(j, N) {
				error[i][j] = local_v[MAX_L-1][i][j] - local_u[MAX_L-1][i][j];
			}
		}
		
		rep(i, P) {
			rep(j, N) {
				tmp_u[i][j] = tmp_u[i][j] + error[i][j];
			}
		}

		//本来のprocess1にする
		REP(i, 1, N) {
			rep(j, N) {
				local_u[MAX_L-1][i][j] = 0; local_Au[MAX_L-1][i][j] = 0;
				local_v[MAX_L-1][i][j] = 0; local_r[MAX_L-1][i][j] = 0;
			}
		}
	}

	MPI_Barrier(MPI_COMM_WORLD);
	MPI_Scatter(&amp;amp;tmp_u[0][0], N, MPI_DOUBLE, &amp;amp;tmp_u[0][0], N, MPI_DOUBLE, 0, MPI_COMM_WORLD);
	MPI_Barrier(MPI_COMM_WORLD);

	rep(i, N) {
		local_u[MAX_L-2][0][i] = tmp_u[0][i];
	}

	local_step *= M;
	local_dt /= M;

	Mat phi = Generator::phi(local_dt);
	F_relaxation(phi, local_u[MAX_L-2], local_step, local_m);

	// -------------- V - Cycle Up ------------
	for(int level = MAX_L - 2; level &amp;gt;= 1; level--) {
		// uが更新されているので，Auも変わる
		local_Au[level] = Generator::global_Au(phi, local_u[level], local_step);

		Mat right_vec(local_step, Vec(N));
		rep(i, local_step) {
			rep(j, N) {
				right_vec[i][j] = local_Au[level][i][j] + local_r[level][i][j];
			}
		}

		Vec pre(N);
		if(myid) {
			MPI_Recv(&amp;amp;pre[0], N, MPI_DOUBLE, myid - 1, 0, MPI_COMM_WORLD, &amp;amp;status);
		}

		rep(i, local_step) {
			local_v[level][i] = add(right_vec[i], mul(phi, pre));
			pre = local_v[level][i];
		}

		if(myid &amp;lt; P - 1) {
			MPI_Send(&amp;amp;local_v[level][local_step-1][0], N, MPI_DOUBLE, myid + 1, 0, MPI_COMM_WORLD);
		}

		Mat error(local_step, Vec(N));
		rep(i, local_step) {
			rep(j, N) {
				error[i][j] = local_v[level][i][j] - local_u[level][i][j];
			}
		}
		
		rep(i, local_step) {
			rep(j, N) {
				local_u[level-1][i * M][j] += error[i][j];
			}
		}

		local_step *= M;
		local_dt /= M;

		phi = Generator::phi(local_dt);
		F_relaxation(phi, local_u[level-1], local_step, local_m);
	}

	local_Au[0] = Generator::global_Au(phi, local_u[0], local_step);

	double local_error = 0;
	rep(i, local_step) {
		rep(j, N) {
			local_error += (local_g[0][i][j] - local_Au[0][i][j]) * (local_g[0][i][j] - local_Au[0][i][j]);
		}
	}

	local_error = sqrt(local_error);

	double check = 0;
	MPI_Allreduce(&amp;amp;local_error, &amp;amp;check, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);

	if(myid == 0) {
		cout &amp;lt;&amp;lt; &amp;quot; -------- MGRIT check:&amp;quot; &amp;lt;&amp;lt; check &amp;lt;&amp;lt; endl;
	}

	if(check &amp;lt; EPS) {
		if(myid == 0) {
			cout &amp;lt;&amp;lt; &amp;quot;================== simulation end ===================&amp;quot; &amp;lt;&amp;lt; endl;
		}
		break;
	}

	cycle_cnt++;
}

	MPI_Finalize();

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参照したもの&#34;&gt;参照したもの&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://computation.llnl.gov/projects/parallel-time-integration-multigrid/strand2d-pit.pdf&#34;&gt;http://computation.llnl.gov/projects/parallel-time-integration-multigrid/strand2d-pit.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.math.mun.ca/~smaclachlan/research/spacetimeMG.pdf&#34;&gt;http://www.math.mun.ca/~smaclachlan/research/spacetimeMG.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://conferences.computer.org/pmbs/2016/papers/5218a022.pdf&#34;&gt;http://conferences.computer.org/pmbs/2016/papers/5218a022.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;todo&#34;&gt;TODO&lt;/h2&gt;

&lt;p&gt;また後で色々追記をしようを思っている(思っているだけ)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Codeforces402-div2D String Game</title>
      <link>http://ry0u.github.io/comp/2017-02-27-Codeforces402-div2D-String-Game/</link>
      <pubDate>Mon, 27 Feb 2017 22:43:04 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-27-Codeforces402-div2D-String-Game/</guid>
      <description>&lt;p&gt;文字列$t$と$t$の部分文字列$p$，文字列$t$のどの文字を消していくかのindexが与えられる．部分文字列$p$が得られなくなるため，文字を消していく作業を続ける時に，最大で何個消せるか．&lt;/p&gt;

&lt;p&gt;一文字ずつ順番に消していき，その文字列が$p$を構成できるかどうか(連続している必要はない)を試すのには$O(n ^2)$なので間に合わない．配列を$p$を構成できるかできないか，を$yes / no$で持った時に，$[yes, yes, &amp;hellip;, yes, no, &amp;hellip;, no]$になるので，この$yes$の右端を二分探索で求める．二分探索で今見ている番目まで文字列を消し，$p$を構成できるかを見るので$O(n logn)$となる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

bool used[200005];

int main() {
	string s, t;
	cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t;

	vector&amp;lt;int&amp;gt; a(s.size());
	rep(i, s.size()) {
		cin &amp;gt;&amp;gt; a[i];
		a[i]--;
	}

	int l = -1, r = s.size() + 5;
	while(r - l &amp;gt; 1) {
		int med = (l + r) / 2;

		memset(used, 0, sizeof(used));
		rep(i, med) {
			used[a[i]] = true;
		}

		string ss = &amp;quot;&amp;quot;;
		rep(i, s.size()) {
			if(used[i]) continue;
			else ss += s[i];
		}

		bool flag = true;
		int tid = 0;
		rep(i, ss.size()) {
			if(ss[i] == t[tid]) {
				tid++;
			}
		}

		if(tid == t.size()) l = med;
		else r = med;
	}

	cout &amp;lt;&amp;lt; r - 1 &amp;lt;&amp;lt; endl;

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Codeforces402 div2C Dishonest Sellers</title>
      <link>http://ry0u.github.io/comp/2017-02-27-Codeforces402-div2C-Dishonest-Sellers/</link>
      <pubDate>Mon, 27 Feb 2017 22:35:26 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-27-Codeforces402-div2C-Dishonest-Sellers/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://codeforces.com/contest/779/problem/C&#34;&gt;http://codeforces.com/contest/779/problem/C&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;$n$個のもの全てを今週と来週に分けて買いたい．$i$番目の今週の値段は$a_i$で，来週の値段は$b_i$である．少なくとも今週に$k$個買わなければならない時に，必要となる最小の金額を求める．&lt;/p&gt;

&lt;p&gt;基本的に来週になると高くなるものは今週買い，安くなるものは来週買った方が良い．今週買った方が良いものが$k$個未満の場合は，来週買った方が良いものから安くなる金額が少ない順に買う．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

bool flag[200005];

int main() {
	int n, k;
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;

	vector&amp;lt;P&amp;gt; v(n);
	rep(i, n) cin &amp;gt;&amp;gt; v[i].fi;
	rep(i, n) cin &amp;gt;&amp;gt; v[i].se;

	memset(flag, 0, sizeof(flag));
	priority_queue&amp;lt;P, vector&amp;lt;P&amp;gt;, greater&amp;lt;P&amp;gt; &amp;gt; que;
	rep(i, n) {
		if(v[i].fi - v[i].se &amp;gt; 0) {
			que.push(mp(v[i].fi - v[i].se, i));
			flag[i] = true;
		}
	}

	int now = n - que.size();
	while(now &amp;lt; k) {
		P p = que.top(); que.pop();
		now++;
		flag[p.se] = false;
	}
	
	ll ans = 0;
	rep(i, n) {
		if(flag[i]) ans += v[i].se;
		else ans += v[i].fi;
	}

	cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>CSAcademy round19 Smallest Array Permutation</title>
      <link>http://ry0u.github.io/comp/2017-02-26-CSAcademy-round19-Smallest-Array-Permutation/</link>
      <pubDate>Sun, 26 Feb 2017 22:59:41 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-26-CSAcademy-round19-Smallest-Array-Permutation/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://csacademy.com/contest/round-19/#task/smallest-array-permutation&#34;&gt;https://csacademy.com/contest/round-19/#task/smallest-array-permutation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;$N$個の要素を持つ配列が与えられる．同じ要素が隣り合わず，辞書順で最小のものを求める．&lt;/p&gt;

&lt;p&gt;辞書順最小にしたいので，小さい数から順番に並べたいが，前回置いたものと同じ数を置くことは出来ないため，前回置いた数以外の最小の数を並べていく．同じ数が隣り合わないために，まだ決めていない要素数が奇数の時かつ，同じ要素が$\frac{要素数+1}{2}$ある時は，$1$個飛ばしで並べなければならないことに注意する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

int main() {
	int n;
	cin &amp;gt;&amp;gt; n;

	map&amp;lt;int, int&amp;gt; m;
	rep(i, n) {
		int x;
		cin &amp;gt;&amp;gt; x;

		m[x]++;
	}

	priority_queue&amp;lt;P&amp;gt; que;
	each(it, m) {
		if(it-&amp;gt;second &amp;gt; (n + 1) / 2) {
			cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
			return 0;
		}

		que.push(mp(it-&amp;gt;se, -it-&amp;gt;fi));
	}

	int len = n, pre = -1;
	vector&amp;lt;int&amp;gt; ans;

	while(que.size()) {
		int cnt = que.top().fi;
		int id = -que.top().se;

		while(m.count(id) == 0) {
			que.pop();
			cnt = que.top().fi;
			id = -que.top().se;
		}

		while(true) {
			cnt = m[id];
			que.pop();

			if(!que.size()) break;

			if(que.top().fi &amp;lt;= cnt) {
				que.push(mp(cnt, -id));
				break;
			} else {
				cnt = que.top().fi;
				id = -que.top().se;
			}
		}

		if(len % 2 == 1) {
			if(cnt == (len + 1) / 2) {
				m[id]--;
				if(m[id] == 0) m.erase(id);

				pre = id;
				ans.push_back(id);
				que.push(mp(cnt - 1, -id));
			} else {
				map&amp;lt;int, int&amp;gt;::iterator it = m.begin();

				if(it-&amp;gt;fi == pre) it++;
				m[it-&amp;gt;fi]--;
				if(m[it-&amp;gt;fi] == 0) m.erase(it-&amp;gt;fi);

				pre = it-&amp;gt;fi;
				ans.push_back(it-&amp;gt;fi);
			}
		} else {
			map&amp;lt;int, int&amp;gt;::iterator it = m.begin();
			if(it-&amp;gt;fi == pre) it++;
			m[it-&amp;gt;fi]--;
			if(m[it-&amp;gt;fi] == 0) m.erase(it-&amp;gt;fi);

			pre = it-&amp;gt;fi;
			ans.push_back(it-&amp;gt;fi);
		}

		len--;
		if(len == 0) break;
	}

	rep(i, ans.size()) {
		if(i) cout &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
		cout &amp;lt;&amp;lt; ans[i];
	}
	cout &amp;lt;&amp;lt; endl;

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>CSAcademy round19 Cities Robbery</title>
      <link>http://ry0u.github.io/comp/2017-02-26-CSAcademy-round19-Cities-Robbery/</link>
      <pubDate>Sun, 26 Feb 2017 22:42:04 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-26-CSAcademy-round19-Cities-Robbery/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://csacademy.com/contest/round-19/#task/cities-robbery&#34;&gt;https://csacademy.com/contest/round-19/#task/cities-robbery&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;$1$次元上に$N$個の都市があり，それぞれ座標が$x_i$で価値が$w_i$である．$X$にいて，$K$動くことが出来るときに，得られる価値の和を最大化する．&lt;/p&gt;

&lt;p&gt;現在の位置よりも右側にいるのか，左側にいるのかで分けて持つ．右側を折り返して左側に行くパターンと，左側を折り返して右側に行くパターンの$2$つに分かれる．何個まで持つかを配列にして持っておけば，価値にマイナスはないので単調増加列になるため，片方を決め打ちすると，残りの距離からその場合の最大の価値を二分探索で求めることができる．$(0, 0)$を追加して片方を何も取らない場合も一緒にした．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,ll&amp;gt; P;

int main() {
	int n, x, k;
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; x &amp;gt;&amp;gt; k;

	ll start = 0;
	vector&amp;lt;P&amp;gt; v(n);
	rep(i, n) {
		cin &amp;gt;&amp;gt; v[i].fi &amp;gt;&amp;gt; v[i].se;
		v[i].fi -= x;
	}

	vector&amp;lt;P&amp;gt; a, b;
	rep(i, n) {
		if(v[i].fi == 0) start += v[i].se;

		if(v[i].fi &amp;lt; 0) a.push_back(mp(-v[i].fi, v[i].se));
		else b.push_back(v[i]);
	}

	a.push_back(mp(0, 0));
	sort(a.begin(), a.end());

	b.push_back(mp(0, 0));
	sort(b.begin(), b.end());

	vector&amp;lt;ll&amp;gt; aid(a.size());
	vector&amp;lt;ll&amp;gt; aval(a.size());
	rep(i, a.size()) {
		aid[i] = a[i].fi;
		aval[i] = a[i].se;
	}

	REP(i, 1, a.size()) aval[i] += aval[i-1];

	vector&amp;lt;ll&amp;gt; bid(b.size());
	vector&amp;lt;ll&amp;gt; bval(b.size());
	rep(i, b.size()) {
		bid[i] = b[i].fi;
		bval[i] = b[i].se;
	}

	REP(i, 1, b.size()) bval[i] += bval[i-1];

	ll ans = 0;
	rep(i, a.size()) {
		if(aid[i] &amp;gt; k) break;
		ans = max(ans, aval[i] + start);

		// aからi個とる
		ll diff = k - 2 * aid[i];
		
		if(diff &amp;lt; 0) continue;

		vector&amp;lt;ll&amp;gt;::iterator it = upper_bound(bid.begin(), bid.end(), diff);
		if(it == bid.end()) {
			ans = max(ans, aval[i] + start + bval[bval.size()-1]);
		} else {
			int id = (it - bid.begin());
			if(id == 0) continue;
			id--;

			ans = max(ans, aval[i] + start + bval[id]);
		}
	}

	rep(i, b.size()) {
		if(bid[i] &amp;gt; k) break;
		ans = max(ans, bval[i] + start);

		// aからi個とる
		ll diff = k - 2 * bid[i];

		if(diff &amp;lt; 0) continue;

		vector&amp;lt;ll&amp;gt;::iterator it = upper_bound(aid.begin(), aid.end(), diff);
		if(it == aid.end()) {
			ans = max(ans, bval[i] + start + aval[aval.size()-1]);
		} else {
			int id = (it - aid.begin());
			if(id == 0) continue;
			id--;

			ans = max(ans, bval[i] + start + aval[id]);
		}
	}

	cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Codeforces401 div2E Hanoi Factory</title>
      <link>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2E-Hanoi-Factory/</link>
      <pubDate>Sat, 25 Feb 2017 22:49:03 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2E-Hanoi-Factory/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://codeforces.com/contest/777/problem/E&#34;&gt;http://codeforces.com/contest/777/problem/E&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;内周の半径を$a_i$，外周の半径を$b_i$，高さを$h_i$とした輪っかがある．$i$番目の上に$j$番目が乗ることができる条件は$b_j \leq b_i$かつ，$b_j &amp;gt; a_i$である．内周の半径より，上に乗せようと考えている外周の半径が小さい場合は，重ねることができない．高さの合計の最大値を求めよ．&lt;/p&gt;

&lt;p&gt;まず条件より外周が大きい順，さらに外周が同じ場合は内周が大きい順にsortすると良さそう．stackで現在乗せているものを表す．stackのtopと$i$番目を比較して，乗る状態であるならば乗せる．そうでないならば，乗せられる状態になるまでstackをpopする．このようにすることで，以前の高さの和を持っておくことができ，乗せられないものが出ても対応できる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;
typedef pair&amp;lt;P, int&amp;gt; PI;

int main() {
	int n;
	cin &amp;gt;&amp;gt; n;

	vector&amp;lt;PI&amp;gt; v(n);
	rep(i, n) cin &amp;gt;&amp;gt; v[i].fi.se &amp;gt;&amp;gt; v[i].fi.fi &amp;gt;&amp;gt; v[i].se;

	sort(v.begin(), v.end(), greater&amp;lt;PI&amp;gt;());

	ll ans = 0, sum = 0;
	stack&amp;lt;PI&amp;gt; st;
	rep(i, n) {
		while(st.size()) {
			PI p = st.top();
			if(v[i].fi.fi &amp;lt;= p.fi.fi &amp;amp;&amp;amp; v[i].fi.fi &amp;gt; p.fi.se) break;

			sum -= p.se;
			st.pop();
		}

		sum += v[i].se;
		st.push(v[i]);

		ans = max(ans, sum);
	}

	cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Codeforces401 div2D Could of Hashtags</title>
      <link>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2D-Could-of-Hashtags/</link>
      <pubDate>Sat, 25 Feb 2017 22:19:48 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2D-Could-of-Hashtags/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://codeforces.com/contest/777/problem/D&#34;&gt;http://codeforces.com/contest/777/problem/D&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;与えられる$n$個の文字列が辞書順になるように文字を調整したい．できることは末尾から文字を消していくことで，辞書順にするために消す必要がある文字数を最小にして出力する．&lt;/p&gt;

&lt;p&gt;消す文字を最小化したいので，残す文字を最大化する．逆からみて，残せるだけ残していくようにしたらACした．$i+1$番目まで確定していて，$i$番目を決める時，長さの短い方に合わせて文字を見ていき，辞書順で小さい場合は$i$番目はそのまま，辞書順で大きい場合は$i$番目と$i+1$番目の先頭からの共通文字列とする．全て同じ文字だった場合は，$i$番目と$i+1$番目の長さが短い方を優先する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

int main() {
	int n;
	cin &amp;gt;&amp;gt; n;

	vector&amp;lt;string&amp;gt; v(n);
	rep(i, n) cin &amp;gt;&amp;gt; v[i];

	vector&amp;lt;string&amp;gt; ans(n);
	ans[n-1] = v[n-1];

	for(int i = n - 2; i &amp;gt;= 0; i--) {
		if(ans[i+1] == &amp;quot;#&amp;quot;) {
			ans[i] =  &amp;quot;#&amp;quot;;
			continue;
		}

		string t = &amp;quot;&amp;quot;;
		int flag = 0;
		rep(j, min(ans[i+1].size(), v[i].size())) {
			if(v[i][j] == ans[i+1][j]) {
				t += v[i][j];
				continue;
			}
			else if(v[i][j] &amp;lt; ans[i+1][j]) {
				flag = 1;
				break;
			} else {
				flag = 2;
				break;
			}
		}

		if(flag == 0) ans[i] = (v[i].size() &amp;lt;= ans[i+1].size() ? v[i] : ans[i+1]);
		if(flag == 1) ans[i] = v[i];
		if(flag == 2) ans[i] = t;
	}

	rep(i, n) cout &amp;lt;&amp;lt; ans[i] &amp;lt;&amp;lt; endl;


	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Codeforces401 div2C Alyona and Spreadsheet</title>
      <link>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2C-Alyona-and-Spreadsheet/</link>
      <pubDate>Sat, 25 Feb 2017 00:46:58 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2C-Alyona-and-Spreadsheet/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://codeforces.com/contest/777/problem/C&#34;&gt;http://codeforces.com/contest/777/problem/C&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;$n$行$m$列の行列が与えられる．列方向の$[l, r]$が広義の単調増加になっている列がある場合は$Yes$を，そうではない場合は$No$を返す．&lt;/p&gt;

&lt;p&gt;一列ずつどこからどこまでが単調増加になっているかの区間を求める．区間の小さい方が同じ場合は$max$を取ってより大きい区間にする．小さい方から順番に見ていく時に，それよりも前に見た区間の右端の方が大きい場合は，覆われている場合なので，今までみた$max$の値を持っておき，その値より小さければ更新する．区間の中に質問の$[l, r]$が含まれているかの問題になるので，$l$を含む区間の最大の右端が$r$より大きければ，その区間が単調増加になっていることが分かる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

int ma[100005], cnt[100005];

int main() {
	cin.tie(0);
    ios::sync_with_stdio(false);

	int n, m;
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;

	vector&amp;lt;ll&amp;gt; pre(m), now(m);
	rep(i, m) cin &amp;gt;&amp;gt; pre[i];

	memset(ma, 0, sizeof(ma));
	memset(cnt, 0, sizeof(cnt));

	rep(i, n) {
		ma[i+1] = i+1;
	}

	rep(i, n-1) {
		rep(j, m) cin &amp;gt;&amp;gt; now[j];

		rep(j, m) {
			if(pre[j] &amp;lt;= now[j]) {
				cnt[j]++;
				int d = ma[i+2-cnt[j]];
				ma[i+2-cnt[j]] = max(d, i + 2);
			} else {
				cnt[j] = 0;
			}
		}
		pre = now;
	}

	int t = 0;
	rep(i, n + 1) {
		t = max(ma[i], t);
		ma[i] = max(ma[i], t);
	}

	int k;
	cin &amp;gt;&amp;gt; k;
	rep(i, k) {
		int l, r;
		cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;

		if(r &amp;lt;= ma[l]) cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
		else cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>University CodeSprint 2 Sherlocks Array Merging Algorithm</title>
      <link>http://ry0u.github.io/comp/2017-02-22-University-CodeSprint-2-Sherlock%27s-Array-Merging-Algorithm/</link>
      <pubDate>Wed, 22 Feb 2017 15:30:19 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-22-University-CodeSprint-2-Sherlock%27s-Array-Merging-Algorithm/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.hackerrank.com/contests/university-codesprint-2/challenges/sherlocks-array-merging-algorithm&#34;&gt;https://www.hackerrank.com/contests/university-codesprint-2/challenges/sherlocks-array-merging-algorithm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;複数の配列から先頭1つずつを取り，取ったものをsortして$M$の末尾に加える．最終的に$V$と一致する通りを求める．&lt;/p&gt;

&lt;p&gt;$$
    dp[pos][n] := 前回n個取り，pos目まで見た時の組み合わせ
$$&lt;/p&gt;

&lt;p&gt;取る数は必ず広義単調減少となり増えることはない．前回$n$個取った場合に今回$r (0 \leq r \leq n)$個取るとすると，まず$n$個の場所に$r$個を当てはめるために$_{n}C_{r}$通り，また$r$個はどんな順番でも良いので$r$の並び方$r!$通りある．現在$pos$まで見て，$r$個取ったとすると次の遷移は$(pos + r, r)$である．$r$個取る時は，$V$の$[pos, pos + r)$が単調増加になっていなければならないことに注意する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second
#define MOD 1000000007

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

ll dp[1205][1205], up[1205][1205], fact[1205];

ll C[2005][2005];
void combination(int size) {
	for (int i = 0; i &amp;lt; size; i++) C[i][0] = 1LL;
	for (int i = 1; i &amp;lt; size; i++) {
		for (int j = 1; j &amp;lt;= i; j++) {
			C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
		}
	}
}

int n;

ll dfs(int pos, int len) {
	if(len == -1) {
		ll res = 0;
		for(ll i = 1; i &amp;lt;= n &amp;amp;&amp;amp; pos + i &amp;lt;= n; i++) {
			if(up[pos][pos + i - 1]) {
				res += dfs(pos + i, i) % MOD;
				res %= MOD;

			} else break;
		}
		return dp[pos][len] = res;
	} else {
		if(dp[pos][len] != -1) return dp[pos][len];
		if(pos == n) return 1;

		ll res = 0;
		for(ll i = 1; i &amp;lt;= len &amp;amp;&amp;amp; pos + i &amp;lt;= n; i++) {
			if(up[pos][pos + i - 1]) {
				res += (((C[len][len-i] * fact[i]) % MOD) * dfs(pos + i, i)) % MOD;
				res %= MOD;
			} else break;
		}

		return dp[pos][len] = res;
	}
}

int main() {
	cin &amp;gt;&amp;gt; n;

	vector&amp;lt;int&amp;gt; v(n);
	rep(i, n) cin &amp;gt;&amp;gt; v[i];

	combination(1205);
	fact[0] = 1;
	REP(i, 1, 1205) {
		fact[i] = (i * fact[i-1]) % MOD;
	}

	rep(i, n + 1) {
		rep(j, n + 1) {
			dp[i][j] = -1;
			up[i][j] = false;
		}
	}

	rep(i, n) {
		bool flag = true;
		REP(j, i, n) {
			up[i][j] = flag;
			if(j &amp;lt; n-1 &amp;amp;&amp;amp; v[j] &amp;gt; v[j+1]) flag = false;
		}
	}

	cout &amp;lt;&amp;lt; dfs(0, -1) &amp;lt;&amp;lt; endl;

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本番中に解けなかった．悔しい．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>University CodeSprint 2 The Story of a Tree</title>
      <link>http://ry0u.github.io/comp/2017-02-22-University-CodeSprint-2-TheStoryofaTree/</link>
      <pubDate>Wed, 22 Feb 2017 15:00:01 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-22-University-CodeSprint-2-TheStoryofaTree/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.hackerrank.com/contests/university-codesprint-2/challenges/the-story-of-a-tree&#34;&gt;https://www.hackerrank.com/contests/university-codesprint-2/challenges/the-story-of-a-tree&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;$n$個の頂点の木が与えられる．Bobはランダムでrootを選ぶ．Aliceの$parent(v_i) = u_i$であるか，という$g$個の質問が，ボブが選んだ木に対して$k$個以上正解しているかの確率を求める．&lt;/p&gt;

&lt;p&gt;愚直に求める場合は，ボブが選んだ木全てに対して，つまりrootが$0 \sim n-1$である全ての木に対して，Aliceの質問が$k$個以上正解しているかを求める．これは$O(ng)$となり間に合わない．&lt;/p&gt;

&lt;p&gt;親子関係が変わるのは，rootと隣接している頂点$v$とrootを変更するとき，つまり
$$
\begin{eqnarray}
    parent[root] &amp;amp;=&amp;amp; -1\\&lt;br /&gt;
    parent[v] &amp;amp;=&amp;amp; root
\end{eqnarray}
$$
の場合に$v$をrootに変更するときは，
$$
\begin{eqnarray}
    parent[root] &amp;amp;=&amp;amp; v\\&lt;br /&gt;
    parent[v] &amp;amp;=&amp;amp; -1
\end{eqnarray}
$$
とし，親子関係が変わるのは$2$点のみである．他は変更する必要がない．&lt;/p&gt;

&lt;p&gt;まず適当にrootを$0$にして，親子関係を構築し，そこからrootをdfsでrootを変更していく．現在のrootを$cur$，次にrootに変更しようと考えている頂点を$to$とすると，$parent[to] = cur$の関係が失われ，$parent[cur] = to$の関係が生まれる．これがAliceの質問に入っているかを見ればよい．Aliceの質問を満たしている親子関係をsetで持ったので$O(n log(g))$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second
#define MAX_N 200005

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

int par[MAX_N];
vector&amp;lt;int&amp;gt; G[MAX_N];

void dfs(int cur, int pre) {
	par[cur] = pre;

	rep(i, G[cur].size()) {
		int to = G[cur][i];
		if(to == pre) continue;
		dfs(to, cur);
	}
}

int ok = 0, K = 0;
vector&amp;lt;int&amp;gt; a, b;
set&amp;lt;P&amp;gt; st, input;

void dfs2(int cur, int pre) {
	if(st.size() &amp;gt;= K) ok++;

	rep(i, G[cur].size()) {
		int to = G[cur][i];
		if(to == pre) continue;

		// root - change (cur, to)
		par[cur] = to;
		par[to] = -1;

		P inP = mp(cur, to);
		P outP = mp(to, cur);

		bool in = false, out = false;
		if(st.find(outP) != st.end()) {
			out = true;
			st.erase(outP);
		}

		if(input.find(inP) != input.end() &amp;amp;&amp;amp; st.find(inP) == st.end()) {
			in = true;
			st.insert(inP);
		}

		dfs2(to, cur);

		if(out) {
			st.insert(outP);
		}

		if(in) {
			st.erase(inP);
		}

		par[cur] = -1;
		par[to] = cur;
	}
}

int main() {
	int q;
	cin &amp;gt;&amp;gt; q;

	rep(qq, q) {
		int n;
		cin &amp;gt;&amp;gt; n;

		rep(i, MAX_N) G[i].clear();
		rep(i, n - 1) {
			int u, v;
			cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;

			u--; v--;
			G[u].push_back(v);
			G[v].push_back(u);
		}

		int g, k;
		cin &amp;gt;&amp;gt; g &amp;gt;&amp;gt; k;
		K = k;

		a.clear(); a.resize(g);
		b.clear(); b.resize(g);

		rep(i, g) {
			cin &amp;gt;&amp;gt; a[i] &amp;gt;&amp;gt; b[i];
			a[i]--; b[i]--;
		}

		rep(i, MAX_N) par[i] = -1;
		dfs(0, -1);

		st.clear(); input.clear();
		rep(i, g) {
			P p = mp(b[i], a[i]);
			input.insert(p);
			if(par[b[i]] == a[i]) st.insert(p);
		}

		ok = 0;
		dfs2(0, -1);

		int d = __gcd(ok, n);

		int x = ok / d;
		int y = n / d;

		cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;quot;/&amp;quot; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl;

		// if(x == 0) cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; endl;
		// else if(x == y) cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; endl;
		// else cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;quot;/&amp;quot; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl;
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;余りの読解力の無さで&lt;code&gt;p/q&lt;/code&gt;と$q$のqの区別が分からず，ゲームを通しての確率を求めるものだと勘違いしていた．また&lt;code&gt;0/1&lt;/code&gt;が解となる時には&lt;code&gt;0&lt;/code&gt;を，&lt;code&gt;1/1&lt;/code&gt;が解となる時には&lt;code&gt;1&lt;/code&gt;を出力すると勘違いしてしまい，WAを重ねてしまった．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>University CodeSprint 2 Game of Two Stacks</title>
      <link>http://ry0u.github.io/comp/2017-02-21-University-CodeSprint-2-GameOfTwoStacks/</link>
      <pubDate>Tue, 21 Feb 2017 23:44:43 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-21-University-CodeSprint-2-GameOfTwoStacks/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.hackerrank.com/contests/university-codesprint-2/challenges/game-of-two-stacks&#34;&gt;https://www.hackerrank.com/contests/university-codesprint-2/challenges/game-of-two-stacks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2つのstack$A, B$が与えられる．どちらのstackからも数字を取ってよい．取った数字の和が$x$より大きくなった時点で失格となる．失格にならずに取った数字の和の最大値を求める．&lt;/p&gt;

&lt;p&gt;stackなので$A, B$どちらも上からのみ数字を取ることができる．$v[i] = $上から$i$番目まで取った時の数字の和とすれば，$v$は広義単調増加となる．片方を$i$番目まで取ると決め打ちすると，もう片方からは最大で$x - v[i]$まで取ることができ，これは二分探索で求めることができる．$n, m \leq 10 ^5$なので$O(n log n)$で間に合う．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

int main() {
	int g;
	cin &amp;gt;&amp;gt; g;

	vector&amp;lt;ll&amp;gt; a, b, A, B;
	rep(q, g) {
		int n, m; ll x;
		cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; x;

		a.clear(); b.clear();
		a.resize(n); b.resize(m);
		rep(i, n) cin &amp;gt;&amp;gt; a[i];
		rep(i, m) cin &amp;gt;&amp;gt; b[i];

		A = a; B = b;
		rep(i, n - 1) A[i+1] += A[i];
		rep(i, m - 1) B[i+1] += B[i];

		int ans = 0;

		rep(i, n + 1) {
			ll res = (i ? A[i-1] : 0);
			
			if(res &amp;lt;= x) ans = max(ans, i);
			else continue;

			ll diff = x - res + 1;
			vector&amp;lt;ll&amp;gt;::iterator it = lower_bound(B.begin(), B.end(), diff);
			int id = it - B.begin();

			if(id == 0) continue;
			ans = max(ans, i + id);

		}

		cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SRM342 D1M ReverseResources</title>
      <link>http://ry0u.github.io/comp/2017-02-17-SRM342-D1M-ReverseResources/</link>
      <pubDate>Fri, 17 Feb 2017 22:40:34 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-17-SRM342-D1M-ReverseResources/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=7415&amp;amp;rd=10666&#34;&gt;https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=7415&amp;amp;rd=10666&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文字列$str$を$resources$中の文字列から$1$つ選んで作りたい．$resources$の各文字列にある&amp;rdquo;%s&amp;rdquo;は，$resources$中の任意の文字列に置き換えすることができる．$str$を構成できる組み合わせは何通りか．&lt;/p&gt;

&lt;p&gt;$$
\begin{eqnarray}
    dp[i][j] &amp;amp;:=&amp;amp; [i, j)を構成できる組み合わせ数\\&lt;br /&gt;
    dp2[i][j][k][l] &amp;amp;:=&amp;amp; [i, j)をresources[j][l]まで見て構成できる組み合わせ数
\end{eqnarray}
$$&lt;/p&gt;

&lt;p&gt;区間$[l, r)$に各文字列を当てた場合を全て試す．&amp;rsquo;%s&amp;rsquo;が無い場合は，その区間と割り当てた文字列が完全に一致している場合は$1$，そうでない場合は$0$を返す．ある場合は，$[l, r)$区間のどこまでを$%s$で別の文字列に置き換えるか，$[l, i)$, $[i, r)$に分割する$i$を全て試す．$dp2[l][r][id][pos] += (a * b) % MOD;$にMODを入れないとoverflowする(落ちた)．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define MOD 1000000007

#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int, int&amp;gt; P;

int n;
string s;
vector&amp;lt;string&amp;gt; v;

int dp[55][55], dp2[35][35][55][55];

ll dfs(int l, int r);
ll dfs2(int l, int r, int id, int pos);

ll dfs(int l, int r) {
	if(dp[l][r] != -1) return dp[l][r];
	dp[l][r] = 0;
	rep(i, n) {
		dp[l][r] += dfs2(l, r, i, 0);
		dp[l][r] %= MOD;
	}
	return dp[l][r];
}

ll dfs2(int l, int r, int id, int pos) {
	if(dp2[l][r][id][pos] != -1) return dp2[l][r][id][pos];
	if(pos &amp;gt;= v[id].size()) return 0;

	if(v[id][pos] == &#39;?&#39;) {
		if(pos != v[id].size() - 1) {
			dp2[l][r][id][pos] = 0;
			for(int i = l + 1; i &amp;lt;= r; i++) {
				ll a = dfs(l, i);
				ll b = dfs2(i, r, id, pos + 1);
				dp2[l][r][id][pos] += (a * b) % MOD;
				dp2[l][r][id][pos] %= MOD;
			}
			return dp2[l][r][id][pos];
		} else {
			return dp2[l][r][id][pos] = dfs(l, r);
		}
	} else {
		if(s[l] != v[id][pos]) return 0;
		if(r - l == 1) {
			if(pos == v[id].size()-1) return 1;
			else return 0;
		}
		return dp2[l][r][id][pos] = dfs2(l + 1, r, id, pos + 1);
	}
}

class ReverseResources {
	public:
	int findDecompositions(string str, vector &amp;lt;string&amp;gt; resources) {
		s = str;
		n = resources.size();
		v.clear(); v.resize(n);
		rep(i, n) {
			string t = &amp;quot;&amp;quot;;
			rep(j, resources[i].size()) {
				if(j + 1 &amp;lt; resources[i].size() &amp;amp;&amp;amp; resources[i][j] == &#39;%&#39; &amp;amp;&amp;amp; resources[i][j+1] == &#39;s&#39;) {
					j++;
					t += &amp;quot;?&amp;quot;;
				} else {
					t += resources[i][j];
				}
			}
			v[i] = t;
		}

		memset(dp, -1, sizeof(dp));
		memset(dp2, -1, sizeof(dp2));
		return dfs(0, s.size());
	}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;hugo&#34;&gt;hugo&lt;/h2&gt;

&lt;p&gt;エスケープで色々問題が起こっている．どうすればよいか&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数式中の改行(&lt;a href=&#34;http://blog.tonytsai.name/blog/2017-01-05-test-mathjax/&#34;&gt;http://blog.tonytsai.name/blog/2017-01-05-test-mathjax/&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aaa&lt;/code&gt;inline code中のbracket&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SRM314 D1M LandAndSea</title>
      <link>http://ry0u.github.io/comp/2017-02-17-SRM341-D1M-LandAndSea/</link>
      <pubDate>Fri, 17 Feb 2017 21:46:48 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-17-SRM341-D1M-LandAndSea/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=7512&#34;&gt;https://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=7512&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;島が&amp;rsquo;.&amp;lsquo;，海が&amp;rsquo;.&amp;lsquo;で表された盤面が与えられる．島は上下左右斜めで隣接しているとき，同じグループの島となる．島が島を内包しているとき，内包している島のレベルの$max + 1$がその島のレベルとなる．内包している島を持っていない場合，その島のレベルは$0$である．各レベルの島の数を返す．&lt;/p&gt;

&lt;p&gt;まずレベルは考えずに島の内包関係をグラフで表現する．盤面外に出ること無しで，海を伝って他の島に当たった数を保持しておき，その数が最大のものに内包されているとした．内包関係をグラフで表現した後は，トポロジカルソートをしてトポロジカル順序で島のレベルを確定させていった．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair

#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int, int&amp;gt; P;

int h, w;
int id[55][55];
int dx[4] = { 1, 0,-1, 0};
int dy[4] = { 0, 1, 0,-1};
int dx2[8] = { 1, 1, 0,-1,-1,-1, 0, 1};
int dy2[8] = { 0, 1, 1, 1, 0,-1,-1,-1};

bool inside(int y, int x) {
	if(0 &amp;lt;= y &amp;amp;&amp;amp; y &amp;lt; h &amp;amp;&amp;amp; 0 &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt; w) return true;
	return false;
}

int counter = 0;
bool visited[55][55];
vector&amp;lt;string&amp;gt; s;
void dfs(int y, int x) {
	rep(i, 8) {
		int ny = y + dy2[i];
		int nx = x + dx2[i];

		if(inside(ny, nx) &amp;amp;&amp;amp; !visited[ny][nx] &amp;amp;&amp;amp; s[ny][nx] == &#39;x&#39;) {
			id[ny][nx] = counter;
			visited[ny][nx] = true;
			dfs(ny, nx);
		}
	}
}

int myid = -1;
bool outflag = false;
map&amp;lt;int, int&amp;gt; m;
void dfs2(int y, int x) {
	if(outflag) return;

	rep(i, 4) {
		int ny = y + dy[i];
		int nx = x + dx[i];
		

		if(visited[ny][nx]) continue;
		if(!inside(ny, nx)) {
			outflag = true;
			return;
		}

		if(s[ny][nx] == &#39;.&#39;) {
			visited[ny][nx] = true;
			dfs2(ny, nx);
		} else {
			int t = id[ny][nx];

			if(t != myid) {
				visited[ny][nx] = true;
				m[id[ny][nx]]++;
			} else {
				visited[ny][nx] = true;
				dfs2(ny, nx);
			}

		}
	}
}

vector&amp;lt;int&amp;gt; G[55 * 55], out;
bool used[55 * 55];
void tposo(int cur) { // topologicalsort-dfs
	used[cur] = true;
	rep(i,G[cur].size()) {
		int v = G[cur][i];
		if(!used[v]) tposo(v);
	}

	out.push_back(cur);
}


class LandAndSea {
	public:
	vector &amp;lt;int&amp;gt; howManyIslands(vector &amp;lt;string&amp;gt; seaMap) {
		s = seaMap;
		h = seaMap.size();
		w = seaMap[0].size();

		counter = 0;
		memset(id, -1, sizeof(id));
		memset(visited, false, sizeof(visited));
		rep(i, 55) G[i].clear();
		out.clear();

		vector&amp;lt;P&amp;gt; start;
		rep(i, h) {
			rep(j, w) {
				if(visited[i][j]) continue;
				if(s[i][j] == &#39;.&#39;) continue;

				id[i][j] = counter;
				visited[i][j] = true;
				start.push_back(mp(i, j));

				dfs(i, j);
				counter++;
			}
		}

		int indeg[55 * 55];
		memset(indeg, 0, sizeof(indeg));

		rep(i, counter) {
			m.clear();
			myid = i;
			outflag = false;
			memset(visited, false, sizeof(visited));

			visited[start[i].fi][start[i].se] = true;
			dfs2(start[i].fi, start[i].se);

			if(outflag) continue;
			int parent = -1, vmax = 0;

			each(it, m) {
				if(it-&amp;gt;second &amp;gt; vmax) {
					parent = it-&amp;gt;first;
					vmax = it-&amp;gt;second;
				}
			}

			G[i].push_back(parent);
			indeg[parent]++;
		}

		memset(used, 0, sizeof(used));
		rep(i, counter) {
			if(!used[i]) tposo(i);
		}
		reverse(out.begin(), out.end());

		map&amp;lt;int, int&amp;gt; ans;
		vector&amp;lt;int&amp;gt; dp(counter);
		rep(i, out.size()) {
			int id = out[i];
			ans[dp[id]]++;
			rep(j, G[id].size()) {
				dp[G[id][j]] = max(dp[G[id][j]], dp[id] + 1);
			}
		}

		vector&amp;lt;int&amp;gt; res(ans.size());
		rep(i, ans.size()) res[i] = ans[i];
		return res;
	}
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>移行した</title>
      <link>http://ry0u.github.io/post/2017-02-16-first/</link>
      <pubDate>Thu, 16 Feb 2017 13:53:10 +0900</pubDate>
      
      <guid>http://ry0u.github.io/post/2017-02-16-first/</guid>
      <description>&lt;p&gt;移行した．今まではOctopressを使用していたが，環境を変えた際にnew_post, deployできれば満足してしまっていて，archivesに対応できていないことに最近気付いた．tagから過去記事を遡れないのは不便だと感じたので修正を試みたが，自分の能力では直すことができなかった．&lt;/p&gt;

&lt;p&gt;検索しているとOctopressからHugoに移行した系の記事が山ほど出てきた．Hugoはシンプルで良いとの評価が多いように思えた．今後何か問題があった場合の事も考えると，なるべく分かりやすい方にしてみよう思い移行してみた．&lt;/p&gt;

&lt;p&gt;installはすぐに終わった．themeはなるべくシンプルなものが良かったので&lt;a href=&#34;http://themes.gohugo.io/beg/&#34;&gt;beg&lt;/a&gt;を改良した．公式のDocumentが非常に分かりやすいと思った．多くの記事を書いていくと，ファイル名に日付が無ければ見にくいと思ったので，&lt;code&gt;date +%Y-%m-%d-&lt;/code&gt;を追加するようにした．後は何か機能が欲しいと思った時，何か問題が出た時にあれこれしようと思った．&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>