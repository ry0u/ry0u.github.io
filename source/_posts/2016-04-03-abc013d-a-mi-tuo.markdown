---
layout: post
title: "ABC013D 阿弥陀"
date: 2016-04-03 17:49:54 +0900
comments: true
categories: [ABC, AtCoder, ダブリング]
---

<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article"><h4><a href="http://abc013.contest.atcoder.jp/tasks/abc013_4">D: 阿弥陀 - AtCoder Beginner Contest 013 | AtCoder</a></h4><p>(null)</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

まず一回アミダをシュミレーションする．すると，ゴールする場所 {% m %} iをj {% em %}に変える関数が作れる．これを遷移行列にして行列類乗だ！と思ったが， {% m %} N \leq 10 ^5 {% em %}で {% m %} D {% em %}は {% m %} logD {% em %}に落ちるが結果{% m %} N ^3 logD {% em %}となってしまい意味が無い．  
そもそも行列で持つ必要がない．ダブリングで {% m %} D {% em %}を {% m %} logD {% em %}に落として， {% m %} O(N logN logD) {% em %}．  
resをmapで作ってしまい {% m %} logN {% em %}が余計にかかる．変に {% m %} log {% em %}をつけて落ちることがあるので気をつけたい．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int main() {
	int n, m, d;
	cin >> n >> m >> d;

	vector<int> a(m);
	rep(i, m) cin >> a[i];

	vector<int> v(n);
	rep(i, n) v[i] = i;

	rep(i, m) {
		swap(v[a[i]-1], v[a[i]]);
	}

	map<int, int> res;
	rep(i, n) {
		res[v[i]] = i;
	}

	vector<int> next(n), cur(n);
	rep(i, n) cur[i] = i;
	while(d) {
		if(d & 1) {
			rep(i, n) next[i] = res[cur[i]];
			rep(i, n) cur[i] = next[i];
		}

		rep(i, n) next[i] = res[res[i]];
		rep(i, n) res[i] = next[i];

		d /= 2;
	}

	rep(i, n) {
		cout << cur[i] + 1 << endl;
	}

	return 0;
}
```
