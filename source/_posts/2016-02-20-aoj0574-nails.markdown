---
layout: post
title: "AOJ0574 Nails"
date: 2016-02-20 00:38:56 +0900
comments: true
categories: [AOJ, いもす法]
---

問題文  
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0574

<!-- more -->

* {% m %} (a,b)に+1{% em %}
* {% m %} (a, b+1)に-1 {% em %}
* {% m %} (a+x+1, b)に-1 {% em %}
* {% m %}(a+x+2, b+1)に+1{% em %}
* {% m %}(a+x+1, b+x+2)に+1{% em %}
* {% m %}(a+x+2，b+x+2)に-1 {% em %}

して，左から右，上から下，左上から右下方向の累積和を取り，0ではない場所の個数を数えた．  


# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int d[5005][5005];

int main() {
	int n, m;
	cin >> n >> m;

	memset(d, 0, sizeof(d));

	rep(i, m) {
		int a, b, x;
		cin >> a >> b >> x;

		a--;
		b--;

		d[a][b]++;
		d[a][b+1]--;

		d[a+x+1][b]--;
		d[a+x+2][b+1]++;

		d[a+x+1][b+x+2]++;
		d[a+x+2][b+x+2]--;
	}

	rep(i, n) {
		rep(j, i+1) d[i][j+1] += d[i][j];
	}

	rep(i, n) {
		rep(j, i+1) d[i+1][j] += d[i][j];
	}

	rep(i, n) {
		rep(j, i+1) d[i+1][j+1] += d[i][j];
	}

	int ans = 0;
	rep(i, n) {
		rep(j, i+1) {
			if(d[i][j]) ans++;
		}
	}
	
	cout << ans << endl;

	return 0;
}
```
