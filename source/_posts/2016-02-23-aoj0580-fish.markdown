---
layout: post
title: "AOJ0580 Fish"
date: 2016-02-23 00:00:36 +0900
comments: true
categories: [AOJ,座標圧縮]
---

問題文  
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0580
<!-- more -->

魚の種類{% m %} Nが最大で50 {% em %}なので，座標圧縮すると，3重ループがかける．  
座標圧縮は  
http://algoogle.hadrori.jp/algorithm/compress.html  
が非常に分かりやすかった（蟻本の問題みたいに前後+1，-1した場所まで取っておく置く必要なし）．  
  
座圧後の{% m %} i, j, k {% em %}の座圧前の体積は
{% math %}
	(\mbox{xunzip}[i+1] - \mbox{xunzip}[i]) \cdot (\mbox{yunzip}[j+1] - \mbox{yunzip}[j]) \cdot (\mbox{zunzip}[k+1] - \mbox{zunzip}[k])
{% endmath %}
で求められる．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <cmath>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair
#define EPS 1e-8
#define equals(a,b) fabs((a) - (b)) < EPS

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

int compress(vector<int>& v, map<int, int>& zip, map<int, int>& unzip) {
	sort(v.begin(), v.end());
	v.erase(unique(v.begin(),v.end()),v.end());

	rep(i, v.size()) {
		zip[v[i]] = i;
		unzip[i] = v[i];
	}

	return v.size();
}

int d[55 * 3][55 * 3][55 * 5];

int main() {
	int n, K;
	cin >> n >> K;

	vector<int> x, y, z;
	vector<int> x1(n), y1(n), z1(n), x2(n), y2(n), z2(n);

	rep(i, n) {
		cin >> x1[i] >> y1[i] >> z1[i] >> x2[i] >> y2[i] >> z2[i];
		x.push_back(x1[i]);
		x.push_back(x2[i]);

		y.push_back(y1[i]);
		y.push_back(y2[i]);

		z.push_back(z1[i]);
		z.push_back(z2[i]);
	}

	map<int, int> xzip, yzip, zzip;
	map<int, int> xunzip, yunzip, zunzip;

	int X = compress(x, xzip, xunzip);
	int Y = compress(y, yzip, yunzip);
	int Z = compress(z, zzip, zunzip);

	memset(d, 0, sizeof(d));

	rep(i, n) {
		REP(j, xzip[x1[i]], xzip[x2[i]]) {
			REP(k, yzip[y1[i]], yzip[y2[i]]) {
				REP(l, zzip[z1[i]], zzip[z2[i]]) {
					d[j][k][l]++;
				}
			}
		}
	}

	ll ans = 0;
	rep(i, X) {
		rep(j, Y) {
			rep(k, Z) {
				if(d[i][j][k] >= K) {
					ans += ll(xunzip[i+1] - xunzip[i]) * ll(yunzip[j+1] - yunzip[j]) * ll(zunzip[k+1] - zunzip[k]);
				}
			}
		}
	}

	cout << ans << endl;

	return 0;
}
```
