---
layout: post
title: "AOJ1501 Grid"
date: 2016-04-20 22:05:48 +0900
comments: true
categories: [AOJ, Vol15, 幅優先]
---

<blockquote class="embedly-card" data-card-key="39deea93f79745829254c0652225a544" data-card-controls="0" data-card-branding="0" data-card-type="article-full"><h4><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1501">Grid | Aizu Online Judge</a></h4><p>Introduction to Programming Introduction to Algorithms and Data Structures Library of Data Structures Library of Graph Algorithms Library of Computational Geometry Library of Dynamic Programming Library of Number Theory</p></blockquote>
<script async src="//cdn.embedly.com/widgets/platform.js" charset="UTF-8"></script>

<!-- more -->

愚直に幅優先で見て行くが，誤読に続く誤読を繰り返しとても時間がかかった．端と端が繋がるのは

```cpp
int nx = (x + dx[i] + r) % r;
int ny = (y + dy[i] + c) % c;
```

と表現出来る．後は同じ深さの所は足していく．

# Code

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>
#include <sstream>
#include <map>
#include <set>
#include <queue>

#define REP(i,k,n) for(int i=k;i<n;i++)
#define rep(i,n) for(int i=0;i<n;i++)
#define INF 1<<30
#define pb push_back
#define mp make_pair
#define MOD 100000007

using namespace std;
typedef long long ll;
typedef pair<int,int> P;

bool used[1005][1005];
ll cnt[1005][1005];
int depth[1005][1005];

int r, c;
int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};

bool can(int x, int y) {
	if(0 <= x &&  x < r && 0 <= y && y < c) return true;
	return false;
}

int main() {
	int a1, a2, b1, b2;
	cin >> r >> c >> a1 >> a2 >> b1 >> b2;


	memset(used, 0, sizeof(used));
	used[a1][a2] = true;

	memset(cnt, 0, sizeof(cnt));
	cnt[a1][a2] = 1;

	memset(depth, 0, sizeof(depth));

	queue<P> que;
	que.push(mp(a1, a2));

	int ans = INF;
	while(que.size()) {
		P p = que.front(); que.pop();
		int x = p.first; int y = p.second;
		
		if(x == b1 && y == b2) {
			break;
		}

		rep(i, 4) {
			int nx = x + dx[i] + r;
			int ny = y + dy[i] + c;

			nx %= r; ny %= c;

			if(!used[nx][ny]) {
				cnt[nx][ny] += cnt[x][y];
				cnt[nx][ny] %= MOD;
				used[nx][ny] = true;
				depth[nx][ny] = depth[x][y] + 1;
				que.push(mp(nx, ny));
			} else if(depth[nx][ny] == depth[x][y] + 1) {
				cnt[nx][ny] += cnt[x][y];
				cnt[nx][ny] %= MOD;
			}
		}
	}

	cout << cnt[b1][b2] << endl;

	return 0;
}
```

