<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Codeforces on ry0u_ydのblog</title>
    <link>http://ry0u.github.io/categories/codeforces/index.xml</link>
    <description>Recent content in Codeforces on ry0u_ydのblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <atom:link href="http://ry0u.github.io/categories/codeforces/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Codeforces401 div2E Hanoi Factory</title>
      <link>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2E-Hanoi-Factory/</link>
      <pubDate>Sat, 25 Feb 2017 22:49:03 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2E-Hanoi-Factory/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://codeforces.com/contest/777/problem/E&#34;&gt;http://codeforces.com/contest/777/problem/E&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;内周の半径を$a_i$，外周の半径を$b_i$，高さを$h_i$とした輪っかがある．$i$番目の上に$j$番目が乗ることができる条件は$b_j \leq b_i$かつ，$b_j &amp;gt; a_i$である．内周の半径より，上に乗せようと考えている外周の半径が小さい場合は，重ねることができない．高さの合計の最大値を求めよ．&lt;/p&gt;

&lt;p&gt;まず条件より外周が大きい順，さらに外周が同じ場合は内周が大きい順にsortすると良さそう．stackで現在乗せているものを表す．stackのtopと$i$番目を比較して，乗る状態であるならば乗せる．そうでないならば，乗せられる状態になるまでstackをpopする．このようにすることで，以前の高さの和を持っておくことができ，乗せられないものが出ても対応できる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;
typedef pair&amp;lt;P, int&amp;gt; PI;

int main() {
	int n;
	cin &amp;gt;&amp;gt; n;

	vector&amp;lt;PI&amp;gt; v(n);
	rep(i, n) cin &amp;gt;&amp;gt; v[i].fi.se &amp;gt;&amp;gt; v[i].fi.fi &amp;gt;&amp;gt; v[i].se;

	sort(v.begin(), v.end(), greater&amp;lt;PI&amp;gt;());

	ll ans = 0, sum = 0;
	stack&amp;lt;PI&amp;gt; st;
	rep(i, n) {
		while(st.size()) {
			PI p = st.top();
			if(v[i].fi.fi &amp;lt;= p.fi.fi &amp;amp;&amp;amp; v[i].fi.fi &amp;gt; p.fi.se) break;

			sum -= p.se;
			st.pop();
		}

		sum += v[i].se;
		st.push(v[i]);

		ans = max(ans, sum);
	}

	cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Codeforces401 div2D Could of Hashtags</title>
      <link>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2D-Could-of-Hashtags/</link>
      <pubDate>Sat, 25 Feb 2017 22:19:48 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2D-Could-of-Hashtags/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://codeforces.com/contest/777/problem/D&#34;&gt;http://codeforces.com/contest/777/problem/D&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;与えられる$n$個の文字列が辞書順になるように文字を調整したい．できることは末尾から文字を消していくことで，辞書順にするために消す必要がある文字数を最小にして出力する．&lt;/p&gt;

&lt;p&gt;消す文字を最小化したいので，残す文字を最大化する．逆からみて，残せるだけ残していくようにしたらACした．$i+1$番目まで確定していて，$i$番目を決める時，長さの短い方に合わせて文字を見ていき，辞書順で小さい場合は$i$番目はそのまま，辞書順で大きい場合は$i$番目と$i+1$番目の先頭からの共通文字列とする．全て同じ文字だった場合は，$i$番目と$i+1$番目の長さが短い方を優先する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

int main() {
	int n;
	cin &amp;gt;&amp;gt; n;

	vector&amp;lt;string&amp;gt; v(n);
	rep(i, n) cin &amp;gt;&amp;gt; v[i];

	vector&amp;lt;string&amp;gt; ans(n);
	ans[n-1] = v[n-1];

	for(int i = n - 2; i &amp;gt;= 0; i--) {
		if(ans[i+1] == &amp;quot;#&amp;quot;) {
			ans[i] =  &amp;quot;#&amp;quot;;
			continue;
		}

		string t = &amp;quot;&amp;quot;;
		int flag = 0;
		rep(j, min(ans[i+1].size(), v[i].size())) {
			if(v[i][j] == ans[i+1][j]) {
				t += v[i][j];
				continue;
			}
			else if(v[i][j] &amp;lt; ans[i+1][j]) {
				flag = 1;
				break;
			} else {
				flag = 2;
				break;
			}
		}

		if(flag == 0) ans[i] = (v[i].size() &amp;lt;= ans[i+1].size() ? v[i] : ans[i+1]);
		if(flag == 1) ans[i] = v[i];
		if(flag == 2) ans[i] = t;
	}

	rep(i, n) cout &amp;lt;&amp;lt; ans[i] &amp;lt;&amp;lt; endl;


	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Codeforces401 div2C Alyona and Spreadsheet</title>
      <link>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2C-Alyona-and-Spreadsheet/</link>
      <pubDate>Sat, 25 Feb 2017 00:46:58 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-25-Codeforces401-div2C-Alyona-and-Spreadsheet/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://codeforces.com/contest/777/problem/C&#34;&gt;http://codeforces.com/contest/777/problem/C&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;$n$行$m$列の行列が与えられる．列方向の$[l, r]$が広義の単調増加になっている列がある場合は$Yes$を，そうではない場合は$No$を返す．&lt;/p&gt;

&lt;p&gt;一列ずつどこからどこまでが単調増加になっているかの区間を求める．区間の小さい方が同じ場合は$max$を取ってより大きい区間にする．小さい方から順番に見ていく時に，それよりも前に見た区間の右端の方が大きい場合は，覆われている場合なので，今までみた$max$の値を持っておき，その値より小さければ更新する．区間の中に質問の$[l, r]$が含まれているかの問題になるので，$l$を含む区間の最大の右端が$r$より大きければ，その区間が単調増加になっていることが分かる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

int ma[100005], cnt[100005];

int main() {
	cin.tie(0);
    ios::sync_with_stdio(false);

	int n, m;
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;

	vector&amp;lt;ll&amp;gt; pre(m), now(m);
	rep(i, m) cin &amp;gt;&amp;gt; pre[i];

	memset(ma, 0, sizeof(ma));
	memset(cnt, 0, sizeof(cnt));

	rep(i, n) {
		ma[i+1] = i+1;
	}

	rep(i, n-1) {
		rep(j, m) cin &amp;gt;&amp;gt; now[j];

		rep(j, m) {
			if(pre[j] &amp;lt;= now[j]) {
				cnt[j]++;
				int d = ma[i+2-cnt[j]];
				ma[i+2-cnt[j]] = max(d, i + 2);
			} else {
				cnt[j] = 0;
			}
		}
		pre = now;
	}

	int t = 0;
	rep(i, n + 1) {
		t = max(ma[i], t);
		ma[i] = max(ma[i], t);
	}

	int k;
	cin &amp;gt;&amp;gt; k;
	rep(i, k) {
		int l, r;
		cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r;

		if(r &amp;lt;= ma[l]) cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
		else cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>