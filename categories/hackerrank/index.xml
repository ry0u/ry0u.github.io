<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hackerrank on ry0u_ydのblog</title>
    <link>http://ry0u.github.io/categories/hackerrank/index.xml</link>
    <description>Recent content in Hackerrank on ry0u_ydのblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <atom:link href="http://ry0u.github.io/categories/hackerrank/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>University CodeSprint 2 Game of Two Stacks</title>
      <link>http://ry0u.github.io/comp/2017-02-21-University-CodeSprint-2-GameOfTwoStacks/</link>
      <pubDate>Tue, 21 Feb 2017 23:44:43 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-21-University-CodeSprint-2-GameOfTwoStacks/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.hackerrank.com/contests/university-codesprint-2/challenges/game-of-two-stacks&#34;&gt;https://www.hackerrank.com/contests/university-codesprint-2/challenges/game-of-two-stacks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2つのstack$A, B$が与えられる．どちらのstackからも数字を取ってよい．取った数字の和が$x$より大きくなった時点で失格となる．失格にならずに取った数字の和の最大値を求める．&lt;/p&gt;

&lt;p&gt;stackなので$A, B$どちらも上からのみ数字を取ることができる．$v[i] = $上から$i$番目まで取った時の数字の和とすれば，$v$は広義単調増加となる．片方を$i$番目まで取ると決め打ちすると，もう片方からは最大で$x - v[i]$まで取ることができ，これは二分探索で求めることができる．$n, m \leq 10 ^5$なので$O(n log n)$で間に合う．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

int main() {
	int g;
	cin &amp;gt;&amp;gt; g;

	vector&amp;lt;ll&amp;gt; a, b, A, B;
	rep(q, g) {
		int n, m; ll x;
		cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; x;

		a.clear(); b.clear();
		a.resize(n); b.resize(m);
		rep(i, n) cin &amp;gt;&amp;gt; a[i];
		rep(i, m) cin &amp;gt;&amp;gt; b[i];

		A = a; B = b;
		rep(i, n - 1) A[i+1] += A[i];
		rep(i, m - 1) B[i+1] += B[i];

		int ans = 0;

		rep(i, n + 1) {
			ll res = (i ? A[i-1] : 0);
			
			if(res &amp;lt;= x) ans = max(ans, i);
			else continue;

			ll diff = x - res + 1;
			vector&amp;lt;ll&amp;gt;::iterator it = lower_bound(B.begin(), B.end(), diff);
			int id = it - B.begin();

			if(id == 0) continue;
			ans = max(ans, i + id);

		}

		cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>