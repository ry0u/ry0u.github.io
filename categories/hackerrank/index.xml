<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hackerrank on ry0u_ydのblog</title>
    <link>http://ry0u.github.io/categories/hackerrank/index.xml</link>
    <description>Recent content in Hackerrank on ry0u_ydのblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <atom:link href="http://ry0u.github.io/categories/hackerrank/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>University CodeSprint 2 Sherlocks Array Merging Algorithm</title>
      <link>http://ry0u.github.io/comp/2017-02-22-University-CodeSprint-2-Sherlock%27s-Array-Merging-Algorithm/</link>
      <pubDate>Wed, 22 Feb 2017 15:30:19 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-22-University-CodeSprint-2-Sherlock%27s-Array-Merging-Algorithm/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.hackerrank.com/contests/university-codesprint-2/challenges/sherlocks-array-merging-algorithm&#34;&gt;https://www.hackerrank.com/contests/university-codesprint-2/challenges/sherlocks-array-merging-algorithm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;複数の配列から先頭1つずつを取り，取ったものをsortして$M$の末尾に加える．最終的に$V$と一致する通りを求める．&lt;/p&gt;

&lt;p&gt;$$
    dp[pos][n] := 前回n個取り，pos目まで見た時の組み合わせ
$$&lt;/p&gt;

&lt;p&gt;取る数は必ず広義単調減少となり増えることはない．前回$n$個取った場合に今回$r (0 \leq r \leq n)$個取るとすると，まず$n$個の場所に$r$個を当てはめるために$_{n}C_{r}$通り，また$r$個はどんな順番でも良いので$r$の並び方$r!$通りある．現在$pos$まで見て，$r$個取ったとすると次の遷移は$(pos + r, r)$である．$r$個取る時は，$V$の$[pos, pos + r)$が単調増加になっていなければならないことに注意する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second
#define MOD 1000000007

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

ll dp[1205][1205], up[1205][1205], fact[1205];

ll C[2005][2005];
void combination(int size) {
	for (int i = 0; i &amp;lt; size; i++) C[i][0] = 1LL;
	for (int i = 1; i &amp;lt; size; i++) {
		for (int j = 1; j &amp;lt;= i; j++) {
			C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
		}
	}
}

int n;

ll dfs(int pos, int len) {
	if(len == -1) {
		ll res = 0;
		for(ll i = 1; i &amp;lt;= n &amp;amp;&amp;amp; pos + i &amp;lt;= n; i++) {
			if(up[pos][pos + i - 1]) {
				res += dfs(pos + i, i) % MOD;
				res %= MOD;

			} else break;
		}
		return dp[pos][len] = res;
	} else {
		if(dp[pos][len] != -1) return dp[pos][len];
		if(pos == n) return 1;

		ll res = 0;
		for(ll i = 1; i &amp;lt;= len &amp;amp;&amp;amp; pos + i &amp;lt;= n; i++) {
			if(up[pos][pos + i - 1]) {
				res += (((C[len][len-i] * fact[i]) % MOD) * dfs(pos + i, i)) % MOD;
				res %= MOD;
			} else break;
		}

		return dp[pos][len] = res;
	}
}

int main() {
	cin &amp;gt;&amp;gt; n;

	vector&amp;lt;int&amp;gt; v(n);
	rep(i, n) cin &amp;gt;&amp;gt; v[i];

	combination(1205);
	fact[0] = 1;
	REP(i, 1, 1205) {
		fact[i] = (i * fact[i-1]) % MOD;
	}

	rep(i, n + 1) {
		rep(j, n + 1) {
			dp[i][j] = -1;
			up[i][j] = false;
		}
	}

	rep(i, n) {
		bool flag = true;
		REP(j, i, n) {
			up[i][j] = flag;
			if(j &amp;lt; n-1 &amp;amp;&amp;amp; v[j] &amp;gt; v[j+1]) flag = false;
		}
	}

	cout &amp;lt;&amp;lt; dfs(0, -1) &amp;lt;&amp;lt; endl;

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本番中に解けなかった．悔しい．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>University CodeSprint 2 The Story of a Tree</title>
      <link>http://ry0u.github.io/comp/2017-02-22-University-CodeSprint-2-TheStoryofaTree/</link>
      <pubDate>Wed, 22 Feb 2017 15:00:01 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-22-University-CodeSprint-2-TheStoryofaTree/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.hackerrank.com/contests/university-codesprint-2/challenges/the-story-of-a-tree&#34;&gt;https://www.hackerrank.com/contests/university-codesprint-2/challenges/the-story-of-a-tree&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;$n$個の頂点の木が与えられる．Bobはランダムでrootを選ぶ．Aliceの$parent(v_i) = u_i$であるか，という$g$個の質問が，ボブが選んだ木に対して$k$個以上正解しているかの確率を求める．&lt;/p&gt;

&lt;p&gt;愚直に求める場合は，ボブが選んだ木全てに対して，つまりrootが$0 \sim n-1$である全ての木に対して，Aliceの質問が$k$個以上正解しているかを求める．これは$O(ng)$となり間に合わない．&lt;/p&gt;

&lt;p&gt;親子関係が変わるのは，rootと隣接している頂点$v$とrootを変更するとき，つまり
$$
\begin{eqnarray}
    parent[root] &amp;amp;=&amp;amp; -1\\&lt;br /&gt;
    parent[v] &amp;amp;=&amp;amp; root
\end{eqnarray}
$$
の場合に$v$をrootに変更するときは，
$$
\begin{eqnarray}
    parent[root] &amp;amp;=&amp;amp; v\\&lt;br /&gt;
    parent[v] &amp;amp;=&amp;amp; -1
\end{eqnarray}
$$
とし，親子関係が変わるのは$2$点のみである．他は変更する必要がない．&lt;/p&gt;

&lt;p&gt;まず適当にrootを$0$にして，親子関係を構築し，そこからrootをdfsでrootを変更していく．現在のrootを$cur$，次にrootに変更しようと考えている頂点を$to$とすると，$parent[to] = cur$の関係が失われ，$parent[cur] = to$の関係が生まれる．これがAliceの質問に入っているかを見ればよい．Aliceの質問を満たしている親子関係をsetで持ったので$O(n log(g))$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second
#define MAX_N 200005

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

int par[MAX_N];
vector&amp;lt;int&amp;gt; G[MAX_N];

void dfs(int cur, int pre) {
	par[cur] = pre;

	rep(i, G[cur].size()) {
		int to = G[cur][i];
		if(to == pre) continue;
		dfs(to, cur);
	}
}

int ok = 0, K = 0;
vector&amp;lt;int&amp;gt; a, b;
set&amp;lt;P&amp;gt; st, input;

void dfs2(int cur, int pre) {
	if(st.size() &amp;gt;= K) ok++;

	rep(i, G[cur].size()) {
		int to = G[cur][i];
		if(to == pre) continue;

		// root - change (cur, to)
		par[cur] = to;
		par[to] = -1;

		P inP = mp(cur, to);
		P outP = mp(to, cur);

		bool in = false, out = false;
		if(st.find(outP) != st.end()) {
			out = true;
			st.erase(outP);
		}

		if(input.find(inP) != input.end() &amp;amp;&amp;amp; st.find(inP) == st.end()) {
			in = true;
			st.insert(inP);
		}

		dfs2(to, cur);

		if(out) {
			st.insert(outP);
		}

		if(in) {
			st.erase(inP);
		}

		par[cur] = -1;
		par[to] = cur;
	}
}

int main() {
	int q;
	cin &amp;gt;&amp;gt; q;

	rep(qq, q) {
		int n;
		cin &amp;gt;&amp;gt; n;

		rep(i, MAX_N) G[i].clear();
		rep(i, n - 1) {
			int u, v;
			cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;

			u--; v--;
			G[u].push_back(v);
			G[v].push_back(u);
		}

		int g, k;
		cin &amp;gt;&amp;gt; g &amp;gt;&amp;gt; k;
		K = k;

		a.clear(); a.resize(g);
		b.clear(); b.resize(g);

		rep(i, g) {
			cin &amp;gt;&amp;gt; a[i] &amp;gt;&amp;gt; b[i];
			a[i]--; b[i]--;
		}

		rep(i, MAX_N) par[i] = -1;
		dfs(0, -1);

		st.clear(); input.clear();
		rep(i, g) {
			P p = mp(b[i], a[i]);
			input.insert(p);
			if(par[b[i]] == a[i]) st.insert(p);
		}

		ok = 0;
		dfs2(0, -1);

		int d = __gcd(ok, n);

		int x = ok / d;
		int y = n / d;

		cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;quot;/&amp;quot; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl;

		// if(x == 0) cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; endl;
		// else if(x == y) cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; endl;
		// else cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;quot;/&amp;quot; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; endl;
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;余りの読解力の無さで&lt;code&gt;p/q&lt;/code&gt;と$q$のqの区別が分からず，ゲームを通しての確率を求めるものだと勘違いしていた．また&lt;code&gt;0/1&lt;/code&gt;が解となる時には&lt;code&gt;0&lt;/code&gt;を，&lt;code&gt;1/1&lt;/code&gt;が解となる時には&lt;code&gt;1&lt;/code&gt;を出力すると勘違いしてしまい，WAを重ねてしまった．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>University CodeSprint 2 Game of Two Stacks</title>
      <link>http://ry0u.github.io/comp/2017-02-21-University-CodeSprint-2-GameOfTwoStacks/</link>
      <pubDate>Tue, 21 Feb 2017 23:44:43 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-21-University-CodeSprint-2-GameOfTwoStacks/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.hackerrank.com/contests/university-codesprint-2/challenges/game-of-two-stacks&#34;&gt;https://www.hackerrank.com/contests/university-codesprint-2/challenges/game-of-two-stacks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2つのstack$A, B$が与えられる．どちらのstackからも数字を取ってよい．取った数字の和が$x$より大きくなった時点で失格となる．失格にならずに取った数字の和の最大値を求める．&lt;/p&gt;

&lt;p&gt;stackなので$A, B$どちらも上からのみ数字を取ることができる．$v[i] = $上から$i$番目まで取った時の数字の和とすれば，$v$は広義単調増加となる．片方を$i$番目まで取ると決め打ちすると，もう片方からは最大で$x - v[i]$まで取ることができ，これは二分探索で求めることができる．$n, m \leq 10 ^5$なので$O(n log n)$で間に合う．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

int main() {
	int g;
	cin &amp;gt;&amp;gt; g;

	vector&amp;lt;ll&amp;gt; a, b, A, B;
	rep(q, g) {
		int n, m; ll x;
		cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; x;

		a.clear(); b.clear();
		a.resize(n); b.resize(m);
		rep(i, n) cin &amp;gt;&amp;gt; a[i];
		rep(i, m) cin &amp;gt;&amp;gt; b[i];

		A = a; B = b;
		rep(i, n - 1) A[i+1] += A[i];
		rep(i, m - 1) B[i+1] += B[i];

		int ans = 0;

		rep(i, n + 1) {
			ll res = (i ? A[i-1] : 0);
			
			if(res &amp;lt;= x) ans = max(ans, i);
			else continue;

			ll diff = x - res + 1;
			vector&amp;lt;ll&amp;gt;::iterator it = lower_bound(B.begin(), B.end(), diff);
			int id = it - B.begin();

			if(id == 0) continue;
			ans = max(ans, i + id);

		}

		cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>