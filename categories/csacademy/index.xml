<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Csacademy on ry0u_ydのblog</title>
    <link>http://ry0u.github.io/categories/csacademy/index.xml</link>
    <description>Recent content in Csacademy on ry0u_ydのblog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <atom:link href="http://ry0u.github.io/categories/csacademy/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>CSAcademy round19 Smallest Array Permutation</title>
      <link>http://ry0u.github.io/comp/2017-02-26-CSAcademy-round19-Smallest-Array-Permutation/</link>
      <pubDate>Sun, 26 Feb 2017 22:59:41 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-26-CSAcademy-round19-Smallest-Array-Permutation/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://csacademy.com/contest/round-19/#task/smallest-array-permutation&#34;&gt;https://csacademy.com/contest/round-19/#task/smallest-array-permutation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;$N$個の要素を持つ配列が与えられる．同じ要素が隣り合わず，辞書順で最小のものを求める．&lt;/p&gt;

&lt;p&gt;辞書順最小にしたいので，小さい数から順番に並べたいが，前回置いたものと同じ数を置くことは出来ないため，前回置いた数以外の最小の数を並べていく．同じ数が隣り合わないために，まだ決めていない要素数が奇数の時かつ，同じ要素が$\frac{要素数+1}{2}$ある時は，$1$個飛ばしで並べなければならないことに注意する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,int&amp;gt; P;

int main() {
	int n;
	cin &amp;gt;&amp;gt; n;

	map&amp;lt;int, int&amp;gt; m;
	rep(i, n) {
		int x;
		cin &amp;gt;&amp;gt; x;

		m[x]++;
	}

	priority_queue&amp;lt;P&amp;gt; que;
	each(it, m) {
		if(it-&amp;gt;second &amp;gt; (n + 1) / 2) {
			cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
			return 0;
		}

		que.push(mp(it-&amp;gt;se, -it-&amp;gt;fi));
	}

	int len = n, pre = -1;
	vector&amp;lt;int&amp;gt; ans;

	while(que.size()) {
		int cnt = que.top().fi;
		int id = -que.top().se;

		while(m.count(id) == 0) {
			que.pop();
			cnt = que.top().fi;
			id = -que.top().se;
		}

		while(true) {
			cnt = m[id];
			que.pop();

			if(!que.size()) break;

			if(que.top().fi &amp;lt;= cnt) {
				que.push(mp(cnt, -id));
				break;
			} else {
				cnt = que.top().fi;
				id = -que.top().se;
			}
		}

		if(len % 2 == 1) {
			if(cnt == (len + 1) / 2) {
				m[id]--;
				if(m[id] == 0) m.erase(id);

				pre = id;
				ans.push_back(id);
				que.push(mp(cnt - 1, -id));
			} else {
				map&amp;lt;int, int&amp;gt;::iterator it = m.begin();

				if(it-&amp;gt;fi == pre) it++;
				m[it-&amp;gt;fi]--;
				if(m[it-&amp;gt;fi] == 0) m.erase(it-&amp;gt;fi);

				pre = it-&amp;gt;fi;
				ans.push_back(it-&amp;gt;fi);
			}
		} else {
			map&amp;lt;int, int&amp;gt;::iterator it = m.begin();
			if(it-&amp;gt;fi == pre) it++;
			m[it-&amp;gt;fi]--;
			if(m[it-&amp;gt;fi] == 0) m.erase(it-&amp;gt;fi);

			pre = it-&amp;gt;fi;
			ans.push_back(it-&amp;gt;fi);
		}

		len--;
		if(len == 0) break;
	}

	rep(i, ans.size()) {
		if(i) cout &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
		cout &amp;lt;&amp;lt; ans[i];
	}
	cout &amp;lt;&amp;lt; endl;

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>CSAcademy round19 Cities Robbery</title>
      <link>http://ry0u.github.io/comp/2017-02-26-CSAcademy-round19-Cities-Robbery/</link>
      <pubDate>Sun, 26 Feb 2017 22:42:04 +0900</pubDate>
      
      <guid>http://ry0u.github.io/comp/2017-02-26-CSAcademy-round19-Cities-Robbery/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://csacademy.com/contest/round-19/#task/cities-robbery&#34;&gt;https://csacademy.com/contest/round-19/#task/cities-robbery&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;$1$次元上に$N$個の都市があり，それぞれ座標が$x_i$で価値が$w_i$である．$X$にいて，$K$動くことが出来るときに，得られる価値の和を最大化する．&lt;/p&gt;

&lt;p&gt;現在の位置よりも右側にいるのか，左側にいるのかで分けて持つ．右側を折り返して左側に行くパターンと，左側を折り返して右側に行くパターンの$2$つに分かれる．何個まで持つかを配列にして持っておけば，価値にマイナスはないので単調増加列になるため，片方を決め打ちすると，残りの距離からその場合の最大の価値を二分探索で求めることができる．$(0, 0)$を追加して片方を何も取らない場合も一緒にした．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(i,n) for(int i=0;i&amp;lt;(int)(n);i++)
#define REP(i,k,n) for(int i=k;i&amp;lt;(int)(n);i++)
#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define INF 1&amp;lt;&amp;lt;30
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
typedef pair&amp;lt;int,ll&amp;gt; P;

int main() {
	int n, x, k;
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; x &amp;gt;&amp;gt; k;

	ll start = 0;
	vector&amp;lt;P&amp;gt; v(n);
	rep(i, n) {
		cin &amp;gt;&amp;gt; v[i].fi &amp;gt;&amp;gt; v[i].se;
		v[i].fi -= x;
	}

	vector&amp;lt;P&amp;gt; a, b;
	rep(i, n) {
		if(v[i].fi == 0) start += v[i].se;

		if(v[i].fi &amp;lt; 0) a.push_back(mp(-v[i].fi, v[i].se));
		else b.push_back(v[i]);
	}

	a.push_back(mp(0, 0));
	sort(a.begin(), a.end());

	b.push_back(mp(0, 0));
	sort(b.begin(), b.end());

	vector&amp;lt;ll&amp;gt; aid(a.size());
	vector&amp;lt;ll&amp;gt; aval(a.size());
	rep(i, a.size()) {
		aid[i] = a[i].fi;
		aval[i] = a[i].se;
	}

	REP(i, 1, a.size()) aval[i] += aval[i-1];

	vector&amp;lt;ll&amp;gt; bid(b.size());
	vector&amp;lt;ll&amp;gt; bval(b.size());
	rep(i, b.size()) {
		bid[i] = b[i].fi;
		bval[i] = b[i].se;
	}

	REP(i, 1, b.size()) bval[i] += bval[i-1];

	ll ans = 0;
	rep(i, a.size()) {
		if(aid[i] &amp;gt; k) break;
		ans = max(ans, aval[i] + start);

		// aからi個とる
		ll diff = k - 2 * aid[i];
		
		if(diff &amp;lt; 0) continue;

		vector&amp;lt;ll&amp;gt;::iterator it = upper_bound(bid.begin(), bid.end(), diff);
		if(it == bid.end()) {
			ans = max(ans, aval[i] + start + bval[bval.size()-1]);
		} else {
			int id = (it - bid.begin());
			if(id == 0) continue;
			id--;

			ans = max(ans, aval[i] + start + bval[id]);
		}
	}

	rep(i, b.size()) {
		if(bid[i] &amp;gt; k) break;
		ans = max(ans, bval[i] + start);

		// aからi個とる
		ll diff = k - 2 * bid[i];

		if(diff &amp;lt; 0) continue;

		vector&amp;lt;ll&amp;gt;::iterator it = upper_bound(aid.begin(), aid.end(), diff);
		if(it == aid.end()) {
			ans = max(ans, bval[i] + start + aval[aval.size()-1]);
		} else {
			int id = (it - aid.begin());
			if(id == 0) continue;
			id--;

			ans = max(ans, bval[i] + start + aval[id]);
		}
	}

	cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>